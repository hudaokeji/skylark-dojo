{"version":3,"sources":["date/locale.js"],"names":["define","lang","array","date","supplemental","i18n","regexp","string","gregorian","module","exports","formatPattern","dateObject","bundle","options","pattern","replace","match","s","pad","c","charAt","l","length","widthList","getFullYear","fullYear","String","substr","Math","ceil","getMonth","m","propM","join","_getWeekOfYear","getDate","_getDayOfYear","d","getDay","getFirstDayOfWeek","locale","propD","timePeriod","getHours","h","getMinutes","getSeconds","round","getMilliseconds","pow","_getZone","offset","tz","floor","abs","splice","Error","_processPattern","applyPattern","applyLiteral","applyAll","identity","x","chunks","literal","forEach","chunk","i","_buildDateTimeRE","tokens","escapeString","strict","p2","p3","am","pm","toLowerCase","indexOf","push","setObject","id","getName","getTimezoneName","getTimezoneOffset","format","normalizeLocale","formatLength","_getGregorianBundle","str","sauce","hitch","this","selector","timePattern","datePattern","key","_parseInfo","parse","value","controlChars","info","RegExp","exec","result","amPm","valid","every","v","token","Number","year","Date","century","substring","cutoff","min","months","concat","map","days","period","hours","setFullYear","allTokens","dateToken","monthToken","add","_customFormats","addCustomFormats","packageName","bundleName","pkg","name","desc","getLocalization","mixin","getNames","item","type","context","label","lookup","props","undefined","isWeekend","weekend","getWeekend","day","end","start","difference","firstDayOfWeek","arguments","firstDayOfYear","adj","week"],"mappings":"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","file":"../../date/locale.js","sourcesContent":["define([\r\n\t\"../_base/lang\",\r\n\t\"../_base/array\",\r\n\t\"../date\",\r\n\t/*===== \"../_base/declare\", =====*/\r\n\t\"../cldr/supplemental\",\r\n\t\"../i18n\",\r\n\t\"../regexp\",\r\n\t\"../string\",\r\n\t\"../i18n!../cldr/nls/gregorian\",\r\n\t\"module\"\r\n], function(lang, array, date, /*===== declare, =====*/ supplemental, i18n, regexp, string, gregorian, module){\r\n\r\n// module:\r\n//\t\tdojo/date/locale\r\n\r\nvar exports = {\r\n\t// summary:\r\n\t//\t\tThis modules defines dojo/date/locale, localization methods for Date.\r\n};\r\nlang.setObject(module.id.replace(/\\//g, \".\"), exports);\r\n\r\n// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.\r\n\r\n// Load the bundles containing localization information for\r\n// names and formats\r\n\r\n//NOTE: Everything in this module assumes Gregorian calendars.\r\n// Other calendars will be implemented in separate modules.\r\n\r\n\t// Format a pattern without literals\r\n\tfunction formatPattern(dateObject, bundle, options, pattern){\r\n\t\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\t\t\tvar s, pad,\r\n\t\t\t\tc = match.charAt(0),\r\n\t\t\t\tl = match.length,\r\n\t\t\t\twidthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\t\t\tswitch(c){\r\n\t\t\t\tcase 'G':\r\n\t\t\t\t\ts = bundle[(l < 4) ? \"eraAbbr\" : \"eraNames\"][dateObject.getFullYear() < 0 ? 0 : 1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'y':\r\n\t\t\t\t\ts = dateObject.getFullYear();\r\n\t\t\t\t\tswitch(l){\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\tif(!options.fullYear){\r\n\t\t\t\t\t\t\t\ts = String(s); s = s.substr(s.length - 2);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// fallthrough\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tpad = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Q':\r\n\t\t\t\tcase 'q':\r\n\t\t\t\t\ts = Math.ceil((dateObject.getMonth()+1)/3);\r\n//\t\t\t\t\tswitch(l){\r\n//\t\t\t\t\t\tcase 1: case 2:\r\n\t\t\t\t\t\t\tpad = true;\r\n//\t\t\t\t\t\t\tbreak;\r\n//\t\t\t\t\t\tcase 3: case 4: // unimplemented\r\n//\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'M':\r\n\t\t\t\tcase 'L':\r\n\t\t\t\t\tvar m = dateObject.getMonth();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\ts = m+1; pad = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar propM = [\r\n\t\t\t\t\t\t\t\"months\",\r\n\t\t\t\t\t\t\tc == 'L' ? \"standAlone\" : \"format\",\r\n\t\t\t\t\t\t\twidthList[l-3]\r\n\t\t\t\t\t\t].join(\"-\");\r\n\t\t\t\t\t\ts = bundle[propM][m];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'w':\r\n\t\t\t\t\tvar firstDay = 0;\r\n\t\t\t\t\ts = exports._getWeekOfYear(dateObject, firstDay); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\ts = dateObject.getDate(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'D':\r\n\t\t\t\t\ts = exports._getDayOfYear(dateObject); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'e':\r\n\t\t\t\tcase 'c':\r\n\t\t\t\t\tvar d = dateObject.getDay();\r\n\t\t\t\t\tif(l<2){\r\n\t\t\t\t\t\ts = (d - supplemental.getFirstDayOfWeek(options.locale) + 8) % 7\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// fallthrough\r\n\t\t\t\tcase 'E':\r\n\t\t\t\t\td = dateObject.getDay();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\ts = d+1; pad = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar propD = [\r\n\t\t\t\t\t\t\t\"days\",\r\n\t\t\t\t\t\t\tc == 'c' ? \"standAlone\" : \"format\",\r\n\t\t\t\t\t\t\twidthList[l-3]\r\n\t\t\t\t\t\t].join(\"-\");\r\n\t\t\t\t\t\ts = bundle[propD][d];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'a':\r\n\t\t\t\t\tvar timePeriod = dateObject.getHours() < 12 ? 'am' : 'pm';\r\n\t\t\t\t\ts = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'h':\r\n\t\t\t\tcase 'H':\r\n\t\t\t\tcase 'K':\r\n\t\t\t\tcase 'k':\r\n\t\t\t\t\tvar h = dateObject.getHours();\r\n\t\t\t\t\t// strange choices in the date format make it impossible to write this succinctly\r\n\t\t\t\t\tswitch (c){\r\n\t\t\t\t\t\tcase 'h': // 1-12\r\n\t\t\t\t\t\t\ts = (h % 12) || 12;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'H': // 0-23\r\n\t\t\t\t\t\t\ts = h;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'K': // 0-11\r\n\t\t\t\t\t\t\ts = (h % 12);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'k': // 1-24\r\n\t\t\t\t\t\t\ts = h || 24;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'm':\r\n\t\t\t\t\ts = dateObject.getMinutes(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\ts = dateObject.getSeconds(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'S':\r\n\t\t\t\t\ts = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'v': // FIXME: don't know what this is. seems to be same as z?\r\n\t\t\t\tcase 'z':\r\n\t\t\t\t\t// We only have one timezone to offer; the one from the browser\r\n\t\t\t\t\ts = exports._getZone(dateObject, true, options);\r\n\t\t\t\t\tif(s){break;}\r\n\t\t\t\t\tl=4;\r\n\t\t\t\t\t// fallthrough... use GMT if tz not available\r\n\t\t\t\tcase 'Z':\r\n\t\t\t\t\tvar offset = exports._getZone(dateObject, false, options);\r\n\t\t\t\t\tvar tz = [\r\n\t\t\t\t\t\t(offset<=0 ? \"+\" : \"-\"),\r\n\t\t\t\t\t\tstring.pad(Math.floor(Math.abs(offset)/60), 2),\r\n\t\t\t\t\t\tstring.pad(Math.abs(offset)% 60, 2)\r\n\t\t\t\t\t];\r\n\t\t\t\t\tif(l==4){\r\n\t\t\t\t\t\ttz.splice(0, 0, \"GMT\");\r\n\t\t\t\t\t\ttz.splice(3, 0, \":\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\ts = tz.join(\"\");\r\n\t\t\t\t\tbreak;\r\n//\t\t\t\tcase 'Y': case 'u': case 'W': case 'F': case 'g': case 'A':\r\n//\t\t\t\t\tconsole.log(match+\" modifier unimplemented\");\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"dojo.date.locale.format: invalid pattern char: \"+pattern);\r\n\t\t\t}\r\n\t\t\tif(pad){ s = string.pad(s, l); }\r\n\t\t\treturn s;\r\n\t\t});\r\n\t}\r\n\r\n/*=====\r\nvar __FormatOptions = exports.__FormatOptions = declare(null, {\r\n\t// selector: String\r\n\t//\t\tchoice of 'time','date' (default: date and time)\r\n\t// formatLength: String\r\n\t//\t\tchoice of long, short, medium or full (plus any custom additions).  Defaults to 'short'\r\n\t// datePattern:String\r\n\t//\t\toverride pattern with this string\r\n\t// timePattern:String\r\n\t//\t\toverride pattern with this string\r\n\t// am: String\r\n\t//\t\toverride strings for am in times\r\n\t// pm: String\r\n\t//\t\toverride strings for pm in times\r\n\t// locale: String\r\n\t//\t\toverride the locale used to determine formatting rules\r\n\t// fullYear: Boolean\r\n\t//\t\t(format only) use 4 digit years whenever 2 digit years are called for\r\n\t// strict: Boolean\r\n\t//\t\t(parse only) strict parsing, off by default\r\n});\r\n=====*/\r\n\r\nexports._getZone = function(/*Date*/ dateObject, /*boolean*/ getName, /*__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tReturns the zone (or offset) for the given date and options.  This\r\n\t//\t\tis broken out into a separate function so that it can be overridden\r\n\t//\t\tby timezone-aware code.\r\n\t//\r\n\t// dateObject:\r\n\t//\t\tthe date and/or time being formatted.\r\n\t//\r\n\t// getName:\r\n\t//\t\tWhether to return the timezone string (if true), or the offset (if false)\r\n\t//\r\n\t// options:\r\n\t//\t\tThe options being used for formatting\r\n\tif(getName){\r\n\t\treturn date.getTimezoneName(dateObject);\r\n\t}else{\r\n\t\treturn dateObject.getTimezoneOffset();\r\n\t}\r\n};\r\n\r\n\r\nexports.format = function(/*Date*/ dateObject, /*__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tFormat a Date object as a String, using locale-specific settings.\r\n\t//\r\n\t// description:\r\n\t//\t\tCreate a string from a Date object using a known localized pattern.\r\n\t//\t\tBy default, this method formats both date and time from dateObject.\r\n\t//\t\tFormatting patterns are chosen appropriate to the locale.  Different\r\n\t//\t\tformatting lengths may be chosen, with \"full\" used by default.\r\n\t//\t\tCustom patterns may be used or registered with translations using\r\n\t//\t\tthe dojo/date/locale.addCustomFormats() method.\r\n\t//\t\tFormatting patterns are implemented using [the syntax described at\r\n\t//\t\tunicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)\r\n\t//\r\n\t// dateObject:\r\n\t//\t\tthe date and/or time to be formatted.  If a time only is formatted,\r\n\t//\t\tthe values in the year, month, and day fields are irrelevant.  The\r\n\t//\t\topposite is true when formatting only dates.\r\n\r\n\toptions = options || {};\r\n\r\n\tvar locale = i18n.normalizeLocale(options.locale),\r\n\t\tformatLength = options.formatLength || 'short',\r\n\t\tbundle = exports._getGregorianBundle(locale),\r\n\t\tstr = [],\r\n\t\tsauce = lang.hitch(this, formatPattern, dateObject, bundle, options);\r\n\tif(options.selector == \"year\"){\r\n\t\treturn _processPattern(bundle[\"dateFormatItem-yyyy\"] || \"yyyy\", sauce);\r\n\t}\r\n\tvar pattern;\r\n\tif(options.selector != \"date\"){\r\n\t\tpattern = options.timePattern || bundle[\"timeFormat-\"+formatLength];\r\n\t\tif(pattern){str.push(_processPattern(pattern, sauce));}\r\n\t}\r\n\tif(options.selector != \"time\"){\r\n\t\tpattern = options.datePattern || bundle[\"dateFormat-\"+formatLength];\r\n\t\tif(pattern){str.push(_processPattern(pattern, sauce));}\r\n\t}\r\n\r\n\treturn str.length == 1 ? str[0] : bundle[\"dateTimeFormat-\"+formatLength].replace(/\\'/g,'').replace(/\\{(\\d+)\\}/g,\r\n\t\tfunction(match, key){ return str[key]; }); // String\r\n};\r\n\r\nexports.regexp = function(/*__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tBuilds the regular needed to parse a localized date\r\n\r\n\treturn exports._parseInfo(options).regexp; // String\r\n};\r\n\r\nexports._parseInfo = function(/*__FormatOptions?*/ options){\r\n\toptions = options || {};\r\n\tvar locale = i18n.normalizeLocale(options.locale),\r\n\t\tbundle = exports._getGregorianBundle(locale),\r\n\t\tformatLength = options.formatLength || 'short',\r\n\t\tdatePattern = options.datePattern || bundle[\"dateFormat-\" + formatLength],\r\n\t\ttimePattern = options.timePattern || bundle[\"timeFormat-\" + formatLength],\r\n\t\tpattern;\r\n\tif(options.selector == 'date'){\r\n\t\tpattern = datePattern;\r\n\t}else if(options.selector == 'time'){\r\n\t\tpattern = timePattern;\r\n\t}else{\r\n\t\tpattern = bundle[\"dateTimeFormat-\"+formatLength].replace(/\\{(\\d+)\\}/g,\r\n\t\t\tfunction(match, key){ return [timePattern, datePattern][key]; });\r\n\t}\r\n\r\n\tvar tokens = [],\r\n\t\tre = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));\r\n\treturn {regexp: re, tokens: tokens, bundle: bundle};\r\n};\r\n\r\nexports.parse = function(/*String*/ value, /*__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tConvert a properly formatted string to a primitive Date object,\r\n\t//\t\tusing locale-specific settings.\r\n\t//\r\n\t// description:\r\n\t//\t\tCreate a Date object from a string using a known localized pattern.\r\n\t//\t\tBy default, this method parses looking for both date and time in the string.\r\n\t//\t\tFormatting patterns are chosen appropriate to the locale.  Different\r\n\t//\t\tformatting lengths may be chosen, with \"full\" used by default.\r\n\t//\t\tCustom patterns may be used or registered with translations using\r\n\t//\t\tthe dojo/date/locale.addCustomFormats() method.\r\n\t//\r\n\t//\t\tFormatting patterns are implemented using [the syntax described at\r\n\t//\t\tunicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)\r\n\t//\t\tWhen two digit years are used, a century is chosen according to a sliding\r\n\t//\t\twindow of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.\r\n\t//\t\tyear < 100CE requires strict mode.\r\n\t//\r\n\t// value:\r\n\t//\t\tA string representation of a date\r\n\r\n\t// remove non-printing bidi control chars from input and pattern\r\n\tvar controlChars = /[\\u200E\\u200F\\u202A\\u202E]/g,\r\n\t\tinfo = exports._parseInfo(options),\r\n\t\ttokens = info.tokens, bundle = info.bundle,\r\n\t\tre = new RegExp(\"^\" + info.regexp.replace(controlChars, \"\") + \"$\",\r\n\t\t\tinfo.strict ? \"\" : \"i\"),\r\n\t\tmatch = re.exec(value && value.replace(controlChars, \"\"));\r\n\r\n\tif(!match){ return null; } // null\r\n\r\n\tvar widthList = ['abbr', 'wide', 'narrow'],\r\n\t\tresult = [1970,0,1,0,0,0,0], // will get converted to a Date at the end\r\n\t\tamPm = \"\",\r\n\t\tvalid = array.every(match, function(v, i){\r\n\t\tif(!i){return true;}\r\n\t\tvar token = tokens[i-1],\r\n\t\t\tl = token.length,\r\n\t\t\tc = token.charAt(0);\r\n\t\tswitch(c){\r\n\t\t\tcase 'y':\r\n\t\t\t\tif(l != 2 && options.strict){\r\n\t\t\t\t\t//interpret year literally, so '5' would be 5 A.D.\r\n\t\t\t\t\tresult[0] = v;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(v<100){\r\n\t\t\t\t\t\tv = Number(v);\r\n\t\t\t\t\t\t//choose century to apply, according to a sliding window\r\n\t\t\t\t\t\t//of 80 years before and 20 years after present year\r\n\t\t\t\t\t\tvar year = '' + new Date().getFullYear(),\r\n\t\t\t\t\t\t\tcentury = year.substring(0, 2) * 100,\r\n\t\t\t\t\t\t\tcutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);\r\n\t\t\t\t\t\tresult[0] = (v < cutoff) ? century + v : century - 100 + v;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//we expected 2 digits and got more...\r\n\t\t\t\t\t\tif(options.strict){\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//interpret literally, so '150' would be 150 A.D.\r\n\t\t\t\t\t\t//also tolerate '1950', if 'yyyy' input passed to 'yy' format\r\n\t\t\t\t\t\tresult[0] = v;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'M':\r\n\t\t\tcase 'L':\r\n\t\t\t\tif(l>2){\r\n\t\t\t\t\tvar months = bundle['months-' +\r\n\t\t\t\t\t\t\t    (c == 'L' ? 'standAlone' : 'format') +\r\n\t\t\t\t\t\t\t    '-' + widthList[l-3]].concat();\r\n\t\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t\t//Tolerate abbreviating period in month part\r\n\t\t\t\t\t\t//Case-insensitive comparison\r\n\t\t\t\t\t\tv = v.replace(\".\",\"\").toLowerCase();\r\n\t\t\t\t\t\tmonths = array.map(months, function(s){ return s.replace(\".\",\"\").toLowerCase(); } );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tv = array.indexOf(months, v);\r\n\t\t\t\t\tif(v == -1){\r\n//\t\t\t\t\t\tconsole.log(\"dojo/date/locale.parse: Could not parse month name: '\" + v + \"'.\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tv--;\r\n\t\t\t\t}\r\n\t\t\t\tresult[1] = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'E':\r\n\t\t\tcase 'e':\r\n\t\t\tcase 'c':\r\n\t\t\t\tvar days = bundle['days-' +\r\n\t\t\t\t\t\t  (c == 'c' ? 'standAlone' : 'format') +\r\n\t\t\t\t\t\t  '-' + widthList[l-3]].concat();\r\n\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t//Case-insensitive comparison\r\n\t\t\t\t\tv = v.toLowerCase();\r\n\t\t\t\t\tdays = array.map(days, function(d){return d.toLowerCase();});\r\n\t\t\t\t}\r\n\t\t\t\tv = array.indexOf(days, v);\r\n\t\t\t\tif(v == -1){\r\n//\t\t\t\t\tconsole.log(\"dojo/date/locale.parse: Could not parse weekday name: '\" + v + \"'.\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//TODO: not sure what to actually do with this input,\r\n\t\t\t\t//in terms of setting something on the Date obj...?\r\n\t\t\t\t//without more context, can't affect the actual date\r\n\t\t\t\t//TODO: just validate?\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'D':\r\n\t\t\t\tresult[1] = 0;\r\n\t\t\t\t// fallthrough...\r\n\t\t\tcase 'd':\r\n\t\t\t\tresult[2] = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'a': //am/pm\r\n\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\tif(!options.strict){\r\n\t\t\t\t\tvar period = /\\./g;\r\n\t\t\t\t\tv = v.replace(period,'').toLowerCase();\r\n\t\t\t\t\tam = am.replace(period,'').toLowerCase();\r\n\t\t\t\t\tpm = pm.replace(period,'').toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\tif(options.strict && v != am && v != pm){\r\n//\t\t\t\t\tconsole.log(\"dojo/date/locale.parse: Could not parse am/pm part.\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// we might not have seen the hours field yet, so store the state and apply hour change later\r\n\t\t\t\tamPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\tif(v == 24){ v = 0; }\r\n\t\t\t\t// fallthrough...\r\n\t\t\tcase 'h': //hour (1-12)\r\n\t\t\tcase 'H': //hour (0-23)\r\n\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\t//TODO: strict bounds checking, padding\r\n\t\t\t\tif(v > 23){\r\n//\t\t\t\t\tconsole.log(\"dojo/date/locale.parse: Illegal hours value\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//in the 12-hour case, adjusting for am/pm requires the 'a' part\r\n\t\t\t\t//which could come before or after the hour, so we will adjust later\r\n\t\t\t\tresult[3] = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'm': //minutes\r\n\t\t\t\tresult[4] = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 's': //seconds\r\n\t\t\t\tresult[5] = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'S': //milliseconds\r\n\t\t\t\tresult[6] = v;\r\n//\t\t\t\tbreak;\r\n//\t\t\tcase 'w':\r\n//TODO\t\t\t\tvar firstDay = 0;\r\n//\t\t\tdefault:\r\n//TODO: throw?\r\n//\t\t\t\tconsole.log(\"dojo/date/locale.parse: unsupported pattern char=\" + token.charAt(0));\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tvar hours = +result[3];\r\n\tif(amPm === 'p' && hours < 12){\r\n\t\tresult[3] = hours + 12; //e.g., 3pm -> 15\r\n\t}else if(amPm === 'a' && hours == 12){\r\n\t\tresult[3] = 0; //12am -> 0\r\n\t}\r\n\r\n\t//TODO: implement a getWeekday() method in order to test\r\n\t//validity of input strings containing 'EEE' or 'EEEE'...\r\n\r\n\tvar dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date\r\n\tif(options.strict){\r\n\t\tdateObject.setFullYear(result[0]);\r\n\t}\r\n\r\n\t// Check for overflow.  The Date() constructor normalizes things like April 32nd...\r\n\t//TODO: why isn't this done for times as well?\r\n\tvar allTokens = tokens.join(\"\"),\r\n\t\tdateToken = allTokens.indexOf('d') != -1,\r\n\t\tmonthToken = allTokens.indexOf('M') != -1;\r\n\r\n\tif(!valid ||\r\n\t\t(monthToken && dateObject.getMonth() > result[1]) ||\r\n\t\t(dateToken && dateObject.getDate() > result[2])){\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Check for underflow, due to DST shifts.  See #9366\r\n\t// This assumes a 1 hour dst shift correction at midnight\r\n\t// We could compare the timezone offset after the shift and add the difference instead.\r\n\tif((monthToken && dateObject.getMonth() < result[1]) ||\r\n\t\t(dateToken && dateObject.getDate() < result[2])){\r\n\t\tdateObject = date.add(dateObject, \"hour\", 1);\r\n\t}\r\n\r\n\treturn dateObject; // Date\r\n};\r\n\r\nfunction _processPattern(pattern, applyPattern, applyLiteral, applyAll){\r\n\t//summary: Process a pattern with literals in it\r\n\r\n\t// Break up on single quotes, treat every other one as a literal, except '' which becomes '\r\n\tvar identity = function(x){return x;};\r\n\tapplyPattern = applyPattern || identity;\r\n\tapplyLiteral = applyLiteral || identity;\r\n\tapplyAll = applyAll || identity;\r\n\r\n\t//split on single quotes (which escape literals in date format strings)\r\n\t//but preserve escaped single quotes (e.g., o''clock)\r\n\tvar chunks = pattern.match(/(''|[^'])+/g),\r\n\t\tliteral = pattern.charAt(0) == \"'\";\r\n\r\n\tarray.forEach(chunks, function(chunk, i){\r\n\t\tif(!chunk){\r\n\t\t\tchunks[i]='';\r\n\t\t}else{\r\n\t\t\tchunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, \"'\"));\r\n\t\t\tliteral = !literal;\r\n\t\t}\r\n\t});\r\n\treturn applyAll(chunks.join(''));\r\n}\r\n\r\nfunction _buildDateTimeRE(tokens, bundle, options, pattern){\r\n\tpattern = regexp.escapeString(pattern);\r\n\tif(!options.strict){ pattern = pattern.replace(\" a\", \" ?a\"); } // kludge to tolerate no space before am/pm\r\n\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\t\t// Build a simple regexp.  Avoid captures, which would ruin the tokens list\r\n\t\tvar s,\r\n\t\t\tc = match.charAt(0),\r\n\t\t\tl = match.length,\r\n\t\t\tp2 = '', p3 = '';\r\n\t\tif(options.strict){\r\n\t\t\tif(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }\r\n\t\t\tif(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }\r\n\t\t}else{\r\n\t\t\tp2 = '0?'; p3 = '0{0,2}';\r\n\t\t}\r\n\t\tswitch(c){\r\n\t\t\tcase 'y':\r\n\t\t\t\ts = '\\\\d{2,4}';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'M':\r\n\t\t\tcase 'L':\r\n\t\t\t\ts = (l>2) ? '\\\\S+?' : '1[0-2]|'+p2+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'D':\r\n\t\t\t\ts = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'd':\r\n\t\t\t\ts = '3[01]|[12]\\\\d|'+p2+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'w':\r\n\t\t\t\ts = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'E':\r\n\t\t\tcase 'e':\r\n\t\t\tcase 'c':\r\n\t\t\t\ts = '.+?'; // match anything including spaces until the first pattern delimiter is found such as a comma or space\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'h': //hour (1-12)\r\n\t\t\t\ts = '1[0-2]|'+p2+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\ts = '1[01]|'+p2+'\\\\d';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'H': //hour (0-23)\r\n\t\t\t\ts = '1\\\\d|2[0-3]|'+p2+'\\\\d';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\ts = '1\\\\d|2[0-4]|'+p2+'[1-9]';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'm':\r\n\t\t\tcase 's':\r\n\t\t\t\ts = '[0-5]\\\\d';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'S':\r\n\t\t\t\ts = '\\\\d{'+l+'}';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'a':\r\n\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\t\ts = am + '|' + pm;\r\n\t\t\t\tif(!options.strict){\r\n\t\t\t\t\tif(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }\r\n\t\t\t\t\tif(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }\r\n\t\t\t\t\tif(s.indexOf('.') != -1){ s += '|' + s.replace(/\\./g, \"\"); }\r\n\t\t\t\t}\r\n\t\t\t\ts = s.replace(/\\./g, \"\\\\.\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t// case 'v':\r\n\t\t\t// case 'z':\r\n\t\t\t// case 'Z':\r\n\t\t\t\ts = \".*\";\r\n//\t\t\t\tconsole.log(\"parse of date format, pattern=\" + pattern);\r\n\t\t}\r\n\r\n\t\tif(tokens){ tokens.push(match); }\r\n\r\n\t\treturn \"(\" + s + \")\"; // add capture\r\n\t}).replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"); // normalize whitespace.  Need explicit handling of \\xa0 for IE.\r\n}\r\n\r\nvar _customFormats = [];\r\nexports.addCustomFormats = function(/*String*/ packageName, /*String*/ bundleName){\r\n\t// summary:\r\n\t//\t\tAdd a reference to a bundle containing localized custom formats to be\r\n\t//\t\tused by date/time formatting and parsing routines.\r\n\t//\r\n\t// description:\r\n\t//\t\tThe user may add custom localized formats where the bundle has properties following the\r\n\t//\t\tsame naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`\r\n\t//\t\tThe pattern string should match the format used by the CLDR.\r\n\t//\t\tSee dojo/date/locale.format() for details.\r\n\t//\t\tThe resources must be loaded by dojo.requireLocalization() prior to use\r\n\r\n\t_customFormats.push({pkg:packageName,name:bundleName});\r\n};\r\n\r\nexports._getGregorianBundle = function(/*String*/ locale){\r\n\tvar gregorian = {};\r\n\tarray.forEach(_customFormats, function(desc){\r\n\t\tvar bundle = i18n.getLocalization(desc.pkg, desc.name, locale);\r\n\t\tgregorian = lang.mixin(gregorian, bundle);\r\n\t}, this);\r\n\treturn gregorian; /*Object*/\r\n};\r\n\r\nexports.addCustomFormats(module.id.replace(/\\/date\\/locale$/, \".cldr\"),\"gregorian\");\r\n\r\nexports.getNames = function(/*String*/ item, /*String*/ type, /*String?*/ context, /*String?*/ locale){\r\n\t// summary:\r\n\t//\t\tUsed to get localized strings from dojo.cldr for day or month names.\r\n\t//\r\n\t// item:\r\n\t//\t'months' || 'days'\r\n\t// type:\r\n\t//\t'wide' || 'abbr' || 'narrow' (e.g. \"Monday\", \"Mon\", or \"M\" respectively, in English)\r\n\t// context:\r\n\t//\t'standAlone' || 'format' (default)\r\n\t// locale:\r\n\t//\toverride locale used to find the names\r\n\r\n\tvar label,\r\n\t\tlookup = exports._getGregorianBundle(locale),\r\n\t\tprops = [item, context, type];\r\n\tif(context == 'standAlone'){\r\n\t\tvar key = props.join('-');\r\n\t\tlabel = lookup[key];\r\n\t\t// Fall back to 'format' flavor of name\r\n\t\tif(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr\r\n\t}\r\n\tprops[1] = 'format';\r\n\r\n\t// return by copy so changes won't be made accidentally to the in-memory model\r\n\treturn (label || lookup[props.join('-')]).concat(); /*Array*/\r\n};\r\n\r\nexports.isWeekend = function(/*Date?*/ dateObject, /*String?*/ locale){\r\n\t// summary:\r\n\t//\tDetermines if the date falls on a weekend, according to local custom.\r\n\r\n\tvar weekend = supplemental.getWeekend(locale),\r\n\t\tday = (dateObject || new Date()).getDay();\r\n\tif(weekend.end < weekend.start){\r\n\t\tweekend.end += 7;\r\n\t\tif(day < weekend.start){ day += 7; }\r\n\t}\r\n\treturn day >= weekend.start && day <= weekend.end; // Boolean\r\n};\r\n\r\n// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?\r\n\r\nexports._getDayOfYear = function(/*Date*/ dateObject){\r\n\t// summary:\r\n\t//\t\tgets the day of the year as represented by dateObject\r\n\treturn date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number\r\n};\r\n\r\nexports._getWeekOfYear = function(/*Date*/ dateObject, /*Number*/ firstDayOfWeek){\r\n\tif(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday\r\n\r\n\tvar firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),\r\n\t\tadj = (firstDayOfYear - firstDayOfWeek + 7) % 7,\r\n\t\tweek = Math.floor((exports._getDayOfYear(dateObject) + adj - 1) / 7);\r\n\r\n\t// if year starts on the specified day, start counting weeks at 1\r\n\tif(firstDayOfYear == firstDayOfWeek){ week++; }\r\n\r\n\treturn week; // Number\r\n};\r\n\r\nreturn exports;\r\n});\r\n"]}