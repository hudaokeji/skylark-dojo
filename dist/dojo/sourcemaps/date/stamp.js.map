{"version":3,"sources":["date/stamp.js"],"names":["define","lang","array","stamp","setObject","fromISOString","formattedString","defaultTime","_isoRegExp","match","exec","result","shift","Date","forEach","map","prop","value","index","setFullYear","offset","zoneSign","charAt","Number","getTimezoneOffset","setTime","getTime","toISOString","dateObject","options","_","n","formattedDate","getter","zulu","date","selector","year","substr","length","join","push","time","millis","milliseconds","timezoneOffset","absOffset","Math","abs","floor"],"mappings":";;;;;;;AAAAA,QAAQ,gBAAiB,kBAAmB,SAASC,EAAMC,GAK3D,IAAIC,KAyIJ,OArIAF,EAAKG,UAAU,kBAAmBD,GAIlCA,EAAME,cAAgB,SAAoBC,EAA6BC,GA+BlEJ,EAAMK,aACTL,EAAMK,WAEL,iHAGF,IAAIC,EAAQN,EAAMK,WAAWE,KAAKJ,GACjCK,EAAS,KAEV,GAAGF,EAAM,CACRA,EAAMG,QACHH,EAAM,IAAIA,EAAM,KAChBA,EAAM,KAAIA,EAAM,IAAM,KAEtBF,IAEFA,EAAc,IAAIM,KAAKN,GACvBL,EAAMY,QAAQZ,EAAMa,KAAK,WAAY,QAAS,OAAQ,QAAS,UAAW,UAAW,gBAAiB,SAASC,GAC9G,OAAOT,EAAY,MAAQS,OACxB,SAASC,EAAOC,GACnBT,EAAMS,GAAST,EAAMS,IAAUD,KAGjCN,EAAS,IAAIE,KAAKJ,EAAM,IAAI,KAAMA,EAAM,IAAI,EAAGA,EAAM,IAAI,EAAGA,EAAM,IAAI,EAAGA,EAAM,IAAI,EAAGA,EAAM,IAAI,EAAGA,EAAM,IAAI,GAC1GA,EAAM,GAAK,KACbE,EAAOQ,YAAYV,EAAM,IAAM,MAGhC,IAAIW,EAAS,EACZC,EAAWZ,EAAM,IAAMA,EAAM,GAAGa,OAAO,GACzB,KAAZD,IACFD,EAA4B,IAAjBX,EAAM,IAAM,IAAYc,OAAOd,EAAM,KAAO,GACxC,KAAZY,IAAkBD,IAAW,IAE9BC,IACFD,GAAUT,EAAOa,qBAEfJ,GACFT,EAAOc,QAAQd,EAAOe,UAAqB,IAATN,GAIpC,OAAOT,GAeRR,EAAMwB,YAAc,SAAkBC,EAA2BC,GAYhE,IAAIC,EAAI,SAASC,GAAI,OAAQA,EAAI,GAAM,IAAMA,EAAIA,GAE7CC,KACHC,GAFDJ,EAAUA,OAEQK,KAAO,SAAW,MACnCC,EAAO,GACR,GAAuB,QAApBN,EAAQO,SAAmB,CAC7B,IAAIC,EAAOT,EAAWK,EAAO,cAC7BE,GAAQ,OAAOG,QAAQD,EAAK,IAAIE,QAAQF,EAAMP,EAAEF,EAAWK,EAAO,WAAW,GAAIH,EAAEF,EAAWK,EAAO,YAAYO,KAAK,KAGvH,GADAR,EAAcS,KAAKN,GACI,QAApBN,EAAQO,SAAmB,CAC7B,IAAIM,GAAQZ,EAAEF,EAAWK,EAAO,YAAaH,EAAEF,EAAWK,EAAO,cAAeH,EAAEF,EAAWK,EAAO,eAAeO,KAAK,KACpHG,EAASf,EAAWK,EAAO,kBAI/B,GAHGJ,EAAQe,eACVF,GAAQ,KAAMC,EAAS,IAAM,IAAM,IAAMb,EAAEa,IAEzCd,EAAQK,KACVQ,GAAQ,SACH,GAAuB,QAApBb,EAAQO,SAAmB,CACnC,IAAIS,EAAiBjB,EAAWJ,oBAC5BsB,EAAYC,KAAKC,IAAIH,GACzBH,IAASG,EAAiB,EAAI,IAAM,KACnCf,EAAEiB,KAAKE,MAAMH,EAAU,KAAO,IAAMhB,EAAEgB,EAAU,IAElDd,EAAcS,KAAKC,GAEpB,OAAOV,EAAcQ,KAAK,MAGpBrC","file":"../../date/stamp.js","sourcesContent":["define([\"../_base/lang\", \"../_base/array\"], function(lang, array){\r\n\r\n// module:\r\n//\t\tdojo/date/stamp\r\n\r\nvar stamp = {\r\n\t// summary:\r\n\t//\t\tTODOC\r\n};\r\nlang.setObject(\"dojo.date.stamp\", stamp);\r\n\r\n// Methods to convert dates to or from a wire (string) format using well-known conventions\r\n\r\nstamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){\r\n\t// summary:\r\n\t//\t\tReturns a Date object given a string formatted according to a subset of the ISO-8601 standard.\r\n\t//\r\n\t// description:\r\n\t//\t\tAccepts a string formatted according to a profile of ISO8601 as defined by\r\n\t//\t\t[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.\r\n\t//\t\tCan also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)\r\n\t//\t\tThe following combinations are valid:\r\n\t//\r\n\t//\t\t- dates only\r\n\t//\t\t\t- yyyy\r\n\t//\t\t\t- yyyy-MM\r\n\t//\t\t\t- yyyy-MM-dd\r\n\t//\t\t- times only, with an optional time zone appended\r\n\t//\t\t\t- THH:mm\r\n\t//\t\t\t- THH:mm:ss\r\n\t//\t\t\t- THH:mm:ss.SSS\r\n\t//\t\t- and \"datetimes\" which could be any combination of the above\r\n\t//\r\n\t//\t\ttimezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm\r\n\t//\t\tAssumes the local time zone if not specified.  Does not validate.  Improperly formatted\r\n\t//\t\tinput may return null.  Arguments which are out of bounds will be handled\r\n\t//\t\tby the Date constructor (e.g. January 32nd typically gets resolved to February 1st)\r\n\t//\t\tOnly years between 100 and 9999 are supported.\r\n  \t// formattedString:\r\n\t//\t\tA string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00\r\n\t// defaultTime:\r\n\t//\t\tUsed for defaults for fields omitted in the formattedString.\r\n\t//\t\tUses 1970-01-01T00:00:00.0Z by default.\r\n\r\n\tif(!stamp._isoRegExp){\r\n\t\tstamp._isoRegExp =\r\n//TODO: could be more restrictive and check for 00-59, etc.\r\n\t\t\t/^(?:(\\d{4})(?:-(\\d{2})(?:-(\\d{2}))?)?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(.\\d+)?)?((?:[+-](\\d{2}):(\\d{2}))|Z)?)?$/;\r\n\t}\r\n\r\n\tvar match = stamp._isoRegExp.exec(formattedString),\r\n\t\tresult = null;\r\n\r\n\tif(match){\r\n\t\tmatch.shift();\r\n\t\tif(match[1]){match[1]--;} // Javascript Date months are 0-based\r\n\t\tif(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds\r\n\r\n\t\tif(defaultTime){\r\n\t\t\t// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0\r\n\t\t\tdefaultTime = new Date(defaultTime);\r\n\t\t\tarray.forEach(array.map([\"FullYear\", \"Month\", \"Date\", \"Hours\", \"Minutes\", \"Seconds\", \"Milliseconds\"], function(prop){\r\n\t\t\t\treturn defaultTime[\"get\" + prop]();\r\n\t\t\t}), function(value, index){\r\n\t\t\t\tmatch[index] = match[index] || value;\r\n\t\t\t});\r\n\t\t}\r\n\t\tresult = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults\r\n\t\tif(match[0] < 100){\r\n\t\t\tresult.setFullYear(match[0] || 1970);\r\n\t\t}\r\n\r\n\t\tvar offset = 0,\r\n\t\t\tzoneSign = match[7] && match[7].charAt(0);\r\n\t\tif(zoneSign != 'Z'){\r\n\t\t\toffset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);\r\n\t\t\tif(zoneSign != '-'){ offset *= -1; }\r\n\t\t}\r\n\t\tif(zoneSign){\r\n\t\t\toffset -= result.getTimezoneOffset();\r\n\t\t}\r\n\t\tif(offset){\r\n\t\t\tresult.setTime(result.getTime() + offset * 60000);\r\n\t\t}\r\n\t}\r\n\r\n\treturn result; // Date or null\r\n};\r\n\r\n/*=====\r\nvar __Options = {\r\n\t// selector: String\r\n\t//\t\t\"date\" or \"time\" for partial formatting of the Date object.\r\n\t//\t\tBoth date and time will be formatted by default.\r\n\t// zulu: Boolean\r\n\t//\t\tif true, UTC/GMT is used for a timezone\r\n\t// milliseconds: Boolean\r\n\t//\t\tif true, output milliseconds\r\n};\r\n=====*/\r\n\r\nstamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){\r\n\t// summary:\r\n\t//\t\tFormat a Date object as a string according a subset of the ISO-8601 standard\r\n\t//\r\n\t// description:\r\n\t//\t\tWhen options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)\r\n\t//\t\tThe local time zone is included as an offset from GMT, except when selector=='time' (time without a date)\r\n\t//\t\tDoes not check bounds.  Only years between 100 and 9999 are supported.\r\n\t//\r\n\t// dateObject:\r\n\t//\t\tA Date object\r\n\r\n\tvar _ = function(n){ return (n < 10) ? \"0\" + n : n; };\r\n\toptions = options || {};\r\n\tvar formattedDate = [],\r\n\t\tgetter = options.zulu ? \"getUTC\" : \"get\",\r\n\t\tdate = \"\";\r\n\tif(options.selector != \"time\"){\r\n\t\tvar year = dateObject[getter+\"FullYear\"]();\r\n\t\tdate = [\"0000\".substr((year+\"\").length)+year, _(dateObject[getter+\"Month\"]()+1), _(dateObject[getter+\"Date\"]())].join('-');\r\n\t}\r\n\tformattedDate.push(date);\r\n\tif(options.selector != \"date\"){\r\n\t\tvar time = [_(dateObject[getter+\"Hours\"]()), _(dateObject[getter+\"Minutes\"]()), _(dateObject[getter+\"Seconds\"]())].join(':');\r\n\t\tvar millis = dateObject[getter+\"Milliseconds\"]();\r\n\t\tif(options.milliseconds){\r\n\t\t\ttime += \".\"+ (millis < 100 ? \"0\" : \"\") + _(millis);\r\n\t\t}\r\n\t\tif(options.zulu){\r\n\t\t\ttime += \"Z\";\r\n\t\t}else if(options.selector != \"time\"){\r\n\t\t\tvar timezoneOffset = dateObject.getTimezoneOffset();\r\n\t\t\tvar absOffset = Math.abs(timezoneOffset);\r\n\t\t\ttime += (timezoneOffset > 0 ? \"-\" : \"+\") +\r\n\t\t\t\t_(Math.floor(absOffset/60)) + \":\" + _(absOffset%60);\r\n\t\t}\r\n\t\tformattedDate.push(time);\r\n\t}\r\n\treturn formattedDate.join('T'); // String\r\n};\r\n\r\nreturn stamp;\r\n});\r\n"]}