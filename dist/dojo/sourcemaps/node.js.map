{"version":3,"sources":["node.js"],"names":["define","kernel","has","require","nodeRequire","global","Error","module","load","id","contextRequire","_findPath","_nodeModulePaths","localModulePath","toUrl","result","oldDefine","undefined","normalize","charAt"],"mappings":";;;;;;;AAAAA,QAAQ,iBAAkB,QAAS,WAAY,SAASC,EAAQC,EAAKC,GACpE,IAAIC,EAAcH,EAAOI,OAAOF,SAAWF,EAAOI,OAAOF,QAAQC,YAEjE,IAAKA,EACJ,MAAM,IAAIE,MAAM,mCAGjB,IAAIC,EAASH,EAAY,UAEzB,OAWCI,KAAM,SAAoBC,EAAiBC,EAA6BF,GAevE,GAAGD,EAAOI,WAAaJ,EAAOK,iBAAiB,CAC9C,IAAIC,EAAkBN,EAAOI,UAAUF,EAAIF,EAAOK,iBAAiBF,EAAeI,MAAM,QAChE,IAApBD,IACHJ,EAAKI,GAIP,IACCE,EADGC,EAAYhB,OAMhBA,YAASiB,EAET,IACCF,EAASX,EAAYK,GAEtB,QACCT,OAASgB,EAGVR,EAAKO,IAGNG,UAAW,SAAsBT,EAAiBS,GAajD,MAPqB,MAAjBT,EAAGU,OAAO,KAIbV,EAAKN,EAAQW,MAAMI,EAAU,KAAOT,KAG9BA","file":"../node.js","sourcesContent":["define([\"./_base/kernel\", \"./has\", \"require\"], function(kernel, has, require){\r\n\tvar nodeRequire = kernel.global.require && kernel.global.require.nodeRequire;\r\n\r\n\tif (!nodeRequire) {\r\n\t\tthrow new Error(\"Cannot find the Node.js require\");\r\n\t}\r\n\r\n\tvar module = nodeRequire(\"module\");\r\n\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tThis AMD plugin module allows native Node.js modules to be loaded by AMD modules using the Dojo\r\n\t\t//\t\tloader. This plugin will not work with AMD loaders that do not expose the Node.js require function\r\n\t\t//\t\tat `require.nodeRequire`.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\trequire([\"dojo/node!fs\"], function(fs){\r\n\t\t//\t|\t\tvar fileData = fs.readFileSync(\"foo.txt\", \"utf-8\");\r\n\t\t//\t|\t});\r\n\r\n\t\tload: function(/*string*/ id, /*Function*/ contextRequire, /*Function*/ load){\r\n\t\t\t/*global define:true */\r\n\r\n\t\t\t// The `nodeRequire` function comes from the Node.js module of the AMD loader, so module ID resolution is\r\n\t\t\t// relative to the loader's path, not the calling AMD module's path. This means that loading Node.js\r\n\t\t\t// modules that exist in a higher level or sibling path to the loader will cause those modules to fail to\r\n\t\t\t// resolve.\r\n\t\t\t//\r\n\t\t\t// Node.js does not expose a public API for performing module filename resolution relative to an arbitrary\r\n\t\t\t// directory root, so we are forced to dig into the internal functions of the Node.js `module` module to\r\n\t\t\t// use Node.js's own path resolution code instead of having to duplicate its rules ourselves.\r\n\t\t\t//\r\n\t\t\t// Sooner or later, probably around the time that Node.js internal code is reworked to use ES6, these\r\n\t\t\t// methods will no longer be exposed and we will have to find another workaround if they have not exposed\r\n\t\t\t// an API for doing this by then.\r\n\t\t\tif(module._findPath && module._nodeModulePaths){\r\n\t\t\t\tvar localModulePath = module._findPath(id, module._nodeModulePaths(contextRequire.toUrl(\".\")));\r\n\t\t\t\tif (localModulePath !== false) {\r\n\t\t\t\t\tid = localModulePath;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar oldDefine = define,\r\n\t\t\t\tresult;\r\n\r\n\t\t\t// Some modules attempt to detect an AMD loader by looking for global AMD `define`. This causes issues\r\n\t\t\t// when other CommonJS modules attempt to load them via the standard Node.js `require`, so hide it\r\n\t\t\t// during the load\r\n\t\t\tdefine = undefined;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tresult = nodeRequire(id);\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tdefine = oldDefine;\r\n\t\t\t}\r\n\r\n\t\t\tload(result);\r\n\t\t},\r\n\r\n\t\tnormalize: function (/**string*/ id, /*Function*/ normalize){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProduces a normalized CommonJS module ID to be used by Node.js `require`. Relative IDs\r\n\t\t\t//\t\tare resolved relative to the requesting module's location in the filesystem and will\r\n\t\t\t//\t\treturn an ID with path separators appropriate for the local filesystem\r\n\r\n\t\t\tif (id.charAt(0) === \".\") {\r\n\t\t\t\t// absolute module IDs need to be generated based on the AMD loader's knowledge of the parent module,\r\n\t\t\t\t// since Node.js will try to use the directory containing `dojo.js` as the relative root if a\r\n\t\t\t\t// relative module ID is provided\r\n\t\t\t\tid = require.toUrl(normalize(\"./\" + id));\r\n\t\t\t}\r\n\r\n\t\t\treturn id;\r\n\t\t}\r\n\t};\r\n});\r\n"]}