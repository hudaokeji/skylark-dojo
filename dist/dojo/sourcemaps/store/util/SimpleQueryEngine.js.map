{"version":3,"sources":["store/util/SimpleQueryEngine.js"],"names":["define","arrayUtil","query","options","Error","queryObject","object","key","required","test","this","execute","array","results","filter","sortSet","sort","a","b","i","aValue","attribute","bValue","valueOf","descending","start","count","total","length","slice","Infinity","matches"],"mappings":";;;;;;;AAAAA,QAAQ,qBAAsD,SAASC,GAKvE,OAAO,SAASC,EAAOC,GA6CtB,cAAcD,GACb,QACC,MAAM,IAAIE,MAAM,+BAAiCF,GAClD,IAAK,SAAU,IAAK,YACnB,IAAIG,EAAcH,EAClBA,EAAQ,SAASI,GAChB,IAAI,IAAIC,KAAOF,EAAY,CAC1B,IAAIG,EAAWH,EAAYE,GAC3B,GAAGC,GAAYA,EAASC,MAEvB,IAAID,EAASC,KAAKH,EAAOC,GAAMD,GAC9B,OAAO,OAEH,GAAGE,GAAYF,EAAOC,GAC3B,OAAO,EAGT,OAAO,GAER,MACD,IAAK,SAEJ,IAAIG,KAAKR,GACR,MAAM,IAAIE,MAAM,sBAAwBF,EAAQ,uBAEjDA,EAAQQ,KAAKR,GAEd,IAAK,YAGN,SAASS,EAAQC,GAEhB,IAAIC,EAAUZ,EAAUa,OAAOF,EAAOV,GAElCa,EAAUZ,GAAWA,EAAQa,KAiBjC,GAhBGD,GACFF,EAAQG,KAAuB,mBAAXD,EAAwBA,EAAU,SAASE,EAAGC,GACjE,IAAI,IAAIF,EAAMG,EAAE,EAAGH,EAAOD,EAAQI,GAAIA,IAAI,CACzC,IAAIC,EAASH,EAAED,EAAKK,WAChBC,EAASJ,EAAEF,EAAKK,WAIpB,IAFAD,EAAmB,MAAVA,EAAiBA,EAAOG,UAAYH,KAC7CE,EAAmB,MAAVA,EAAiBA,EAAOC,UAAYD,GAE5C,QAASN,EAAKQ,aAAyB,MAAVJ,GAAkBA,EAASE,IAAW,EAAI,EAGzE,OAAO,IAINnB,IAAYA,EAAQsB,OAAStB,EAAQuB,OAAO,CAC9C,IAAIC,EAAQd,EAAQe,QACpBf,EAAUA,EAAQgB,MAAM1B,EAAQsB,OAAS,GAAItB,EAAQsB,OAAS,IAAMtB,EAAQuB,OAASI,EAAAA,KAC7EH,MAAQA,EAEjB,OAAOd,EAGR,OADAF,EAAQoB,QAAU7B,EACXS","file":"../../../store/util/SimpleQueryEngine.js","sourcesContent":["define([\"../../_base/array\" /*=====, \"../api/Store\" =====*/], function(arrayUtil /*=====, Store =====*/){\r\n\r\n// module:\r\n//\t\tdojo/store/util/SimpleQueryEngine\r\n\r\nreturn function(query, options){\r\n\t// summary:\r\n\t//\t\tSimple query engine that matches using filter functions, named filter\r\n\t//\t\tfunctions or objects by name-value on a query object hash\r\n\t//\r\n\t// description:\r\n\t//\t\tThe SimpleQueryEngine provides a way of getting a QueryResults through\r\n\t//\t\tthe use of a simple object hash as a filter.  The hash will be used to\r\n\t//\t\tmatch properties on data objects with the corresponding value given. In\r\n\t//\t\tother words, only exact matches will be returned.\r\n\t//\r\n\t//\t\tThis function can be used as a template for more complex query engines;\r\n\t//\t\tfor example, an engine can be created that accepts an object hash that\r\n\t//\t\tcontains filtering functions, or a string that gets evaluated, etc.\r\n\t//\r\n\t//\t\tWhen creating a new dojo.store, simply set the store's queryEngine\r\n\t//\t\tfield as a reference to this function.\r\n\t//\r\n\t// query: Object\r\n\t//\t\tAn object hash with fields that may match fields of items in the store.\r\n\t//\t\tValues in the hash will be compared by normal == operator, but regular expressions\r\n\t//\t\tor any object that provides a test() method are also supported and can be\r\n\t//\t\tused to match strings by more complex expressions\r\n\t//\t\t(and then the regex's or object's test() method will be used to match values).\r\n\t//\r\n\t// options: dojo/store/api/Store.QueryOptions?\r\n\t//\t\tAn object that contains optional information such as sort, start, and count.\r\n\t//\r\n\t// returns: Function\r\n\t//\t\tA function that caches the passed query under the field \"matches\".  See any\r\n\t//\t\tof the \"query\" methods on dojo.stores.\r\n\t//\r\n\t// example:\r\n\t//\t\tDefine a store with a reference to this engine, and set up a query method.\r\n\t//\r\n\t//\t|\tvar myStore = function(options){\r\n\t//\t|\t\t//\t...more properties here\r\n\t//\t|\t\tthis.queryEngine = SimpleQueryEngine;\r\n\t//\t|\t\t//\tdefine our query method\r\n\t//\t|\t\tthis.query = function(query, options){\r\n\t//\t|\t\t\treturn QueryResults(this.queryEngine(query, options)(this.data));\r\n\t//\t|\t\t};\r\n\t//\t|\t};\r\n\r\n\t// create our matching query function\r\n\tswitch(typeof query){\r\n\t\tdefault:\r\n\t\t\tthrow new Error(\"Can not query with a \" + typeof query);\r\n\t\tcase \"object\": case \"undefined\":\r\n\t\t\tvar queryObject = query;\r\n\t\t\tquery = function(object){\r\n\t\t\t\tfor(var key in queryObject){\r\n\t\t\t\t\tvar required = queryObject[key];\r\n\t\t\t\t\tif(required && required.test){\r\n\t\t\t\t\t\t// an object can provide a test method, which makes it work with regex\r\n\t\t\t\t\t\tif(!required.test(object[key], object)){\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(required != object[key]){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\t\t\tbreak;\r\n\t\tcase \"string\":\r\n\t\t\t// named query\r\n\t\t\tif(!this[query]){\r\n\t\t\t\tthrow new Error(\"No filter function \" + query + \" was found in store\");\r\n\t\t\t}\r\n\t\t\tquery = this[query];\r\n\t\t\t// fall through\r\n\t\tcase \"function\":\r\n\t\t\t// fall through\r\n\t}\r\n\tfunction execute(array){\r\n\t\t// execute the whole query, first we filter\r\n\t\tvar results = arrayUtil.filter(array, query);\r\n\t\t// next we sort\r\n\t\tvar sortSet = options && options.sort;\r\n\t\tif(sortSet){\r\n\t\t\tresults.sort(typeof sortSet == \"function\" ? sortSet : function(a, b){\r\n\t\t\t\tfor(var sort, i=0; sort = sortSet[i]; i++){\r\n\t\t\t\t\tvar aValue = a[sort.attribute];\r\n\t\t\t\t\tvar bValue = b[sort.attribute];\r\n\t\t\t\t\t// valueOf enables proper comparison of dates\r\n\t\t\t\t\taValue = aValue != null ? aValue.valueOf() : aValue;\r\n\t\t\t\t\tbValue = bValue != null ? bValue.valueOf() : bValue;\r\n\t\t\t\t\tif (aValue != bValue){\r\n\t\t\t\t\t\treturn !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t\t});\r\n\t\t}\r\n\t\t// now we paginate\r\n\t\tif(options && (options.start || options.count)){\r\n\t\t\tvar total = results.length;\r\n\t\t\tresults = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));\r\n\t\t\tresults.total = total;\r\n\t\t}\r\n\t\treturn results;\r\n\t}\r\n\texecute.matches = query;\r\n\treturn execute;\r\n};\r\n\r\n});\r\n"]}