{"version":3,"sources":["store/Observable.js"],"names":["define","kernel","lang","when","array","Observable","store","queryUpdaters","revision","delegate","notify","object","existingId","updaters","slice","i","l","length","inMethod","originalQuery","query","whenFinished","method","action","original","value","originalId","getIdentity","apply","this","arguments","results","options","forEach","nonPagedOptions","mixin","start","count","queryUpdater","queryExecutor","queryEngine","queryRevision","listeners","observe","listener","includeObjectUpdates","push","changed","resultsArray","atEnd","Error","removedObject","removedFrom","insertedInto","undef","splice","matches","firstInsertedInto","indexOf","defaultIndex","copyListeners","handle","remove","cancel","index","id","undefined","setObject"],"mappings":"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","file":"../../store/Observable.js","sourcesContent":["define([\"../_base/kernel\", \"../_base/lang\", \"../when\", \"../_base/array\" /*=====, \"./api/Store\" =====*/\r\n], function(kernel, lang, when, array /*=====, Store =====*/){\r\n\r\n// module:\r\n//\t\tdojo/store/Observable\r\n\r\nvar Observable = function(/*Store*/ store){\r\n\t// summary:\r\n\t//\t\tThe Observable store wrapper takes a store and sets an observe method on query()\r\n\t//\t\tresults that can be used to monitor results for changes.\r\n\t//\r\n\t// description:\r\n\t//\t\tObservable wraps an existing store so that notifications can be made when a query\r\n\t//\t\tis performed.\r\n\t//\r\n\t// example:\r\n\t//\t\tCreate a Memory store that returns an observable query, and then log some\r\n\t//\t\tinformation about that query.\r\n\t//\r\n\t//\t|\tvar store = Observable(new Memory({\r\n\t//\t|\t\tdata: [\r\n\t//\t|\t\t\t{id: 1, name: \"one\", prime: false},\r\n\t//\t|\t\t\t{id: 2, name: \"two\", even: true, prime: true},\r\n\t//\t|\t\t\t{id: 3, name: \"three\", prime: true},\r\n\t//\t|\t\t\t{id: 4, name: \"four\", even: true, prime: false},\r\n\t//\t|\t\t\t{id: 5, name: \"five\", prime: true}\r\n\t//\t|\t\t]\r\n\t//\t|\t}));\r\n\t//\t|\tvar changes = [], results = store.query({ prime: true });\r\n\t//\t|\tvar observer = results.observe(function(object, previousIndex, newIndex){\r\n\t//\t|\t\tchanges.push({previousIndex:previousIndex, newIndex:newIndex, object:object});\r\n\t//\t|\t});\r\n\t//\r\n\t//\t\tSee the Observable tests for more information.\r\n\r\n\tvar undef, queryUpdaters = [], revision = 0;\r\n\t// a Comet driven store could directly call notify to notify observers when data has\r\n\t// changed on the backend\r\n\t// create a new instance\r\n\tstore = lang.delegate(store);\r\n\t\r\n\tstore.notify = function(object, existingId){\r\n\t\trevision++;\r\n\t\tvar updaters = queryUpdaters.slice();\r\n\t\tfor(var i = 0, l = updaters.length; i < l; i++){\r\n\t\t\tupdaters[i](object, existingId);\r\n\t\t}\r\n\t};\r\n\tvar originalQuery = store.query;\r\n\tstore.query = function(query, options){\r\n\t\toptions = options || {};\r\n\t\tvar results = originalQuery.apply(this, arguments);\r\n\t\tif(results && results.forEach){\r\n\t\t\tvar nonPagedOptions = lang.mixin({}, options);\r\n\t\t\tdelete nonPagedOptions.start;\r\n\t\t\tdelete nonPagedOptions.count;\r\n\r\n\t\t\tvar queryExecutor = store.queryEngine && store.queryEngine(query, nonPagedOptions);\r\n\t\t\tvar queryRevision = revision;\r\n\t\t\tvar listeners = [], queryUpdater;\r\n\t\t\tresults.observe = function(listener, includeObjectUpdates){\r\n\t\t\t\tif(listeners.push(listener) == 1){\r\n\t\t\t\t\t// first listener was added, create the query checker and updater\r\n\t\t\t\t\tqueryUpdaters.push(queryUpdater = function(changed, existingId){\r\n\t\t\t\t\t\twhen(results, function(resultsArray){\r\n\t\t\t\t\t\t\tvar atEnd = resultsArray.length != options.count;\r\n\t\t\t\t\t\t\tvar i, l, listener;\r\n\t\t\t\t\t\t\tif(++queryRevision != revision){\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Query is out of date, you must observe() the query prior to any data modifications\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar removedObject, removedFrom = -1, insertedInto = -1;\r\n\t\t\t\t\t\t\tif(existingId !== undef){\r\n\t\t\t\t\t\t\t\t// remove the old one\r\n\t\t\t\t\t\t\t\tfor(i = 0, l = resultsArray.length; i < l; i++){\r\n\t\t\t\t\t\t\t\t\tvar object = resultsArray[i];\r\n\t\t\t\t\t\t\t\t\tif(store.getIdentity(object) == existingId){\r\n\t\t\t\t\t\t\t\t\t\tremovedObject = object;\r\n\t\t\t\t\t\t\t\t\t\tremovedFrom = i;\r\n\t\t\t\t\t\t\t\t\t\tif(queryExecutor || !changed){// if it was changed and we don't have a queryExecutor, we shouldn't remove it because updated objects would be eliminated\r\n\t\t\t\t\t\t\t\t\t\t\tresultsArray.splice(i, 1);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(queryExecutor){\r\n\t\t\t\t\t\t\t\t// add the new one\r\n\t\t\t\t\t\t\t\tif(changed &&\r\n\t\t\t\t\t\t\t\t\t\t// if a matches function exists, use that (probably more efficient)\r\n\t\t\t\t\t\t\t\t\t\t(queryExecutor.matches ? queryExecutor.matches(changed) : queryExecutor([changed]).length)){\r\n\r\n\t\t\t\t\t\t\t\t\tvar firstInsertedInto = removedFrom > -1 ? \r\n\t\t\t\t\t\t\t\t\t\tremovedFrom : // put back in the original slot so it doesn't move unless it needs to (relying on a stable sort below)\r\n\t\t\t\t\t\t\t\t\t\tresultsArray.length;\r\n\t\t\t\t\t\t\t\t\tresultsArray.splice(firstInsertedInto, 0, changed); // add the new item\r\n\t\t\t\t\t\t\t\t\tinsertedInto = array.indexOf(queryExecutor(resultsArray), changed); // sort it\r\n\t\t\t\t\t\t\t\t\t// we now need to push the change back into the original results array\r\n\t\t\t\t\t\t\t\t\tresultsArray.splice(firstInsertedInto, 1); // remove the inserted item from the previous index\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif((options.start && insertedInto == 0) ||\r\n\t\t\t\t\t\t\t\t\t\t(!atEnd && insertedInto == resultsArray.length)){\r\n\t\t\t\t\t\t\t\t\t\t// if it is at the end of the page, assume it goes into the prev or next page\r\n\t\t\t\t\t\t\t\t\t\tinsertedInto = -1;\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tresultsArray.splice(insertedInto, 0, changed); // and insert into the results array with the correct index\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}else if(changed){\r\n\t\t\t\t\t\t\t\t// we don't have a queryEngine, so we can't provide any information\r\n\t\t\t\t\t\t\t\t// about where it was inserted or moved to. If it is an update, we leave it's position alone, other we at least indicate a new object\r\n\t\t\t\t\t\t\t\tif(existingId !== undef){\r\n\t\t\t\t\t\t\t\t\t// an update, keep the index the same\r\n\t\t\t\t\t\t\t\t\tinsertedInto = removedFrom;\r\n\t\t\t\t\t\t\t\t}else if(!options.start){\r\n\t\t\t\t\t\t\t\t\t// a new object\r\n\t\t\t\t\t\t\t\t\tinsertedInto = store.defaultIndex || 0;\r\n\t\t\t\t\t\t\t\t\tresultsArray.splice(insertedInto, 0, changed);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif((removedFrom > -1 || insertedInto > -1) &&\r\n\t\t\t\t\t\t\t\t\t(includeObjectUpdates || !queryExecutor || (removedFrom != insertedInto))){\r\n\t\t\t\t\t\t\t\tvar copyListeners = listeners.slice();\r\n\t\t\t\t\t\t\t\tfor(i = 0;listener = copyListeners[i]; i++){\r\n\t\t\t\t\t\t\t\t\tlistener(changed || removedObject, removedFrom, insertedInto);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tvar handle = {};\r\n\t\t\t\t// TODO: Remove cancel in 2.0.\r\n\t\t\t\thandle.remove = handle.cancel = function(){\r\n\t\t\t\t\t// remove this listener\r\n\t\t\t\t\tvar index = array.indexOf(listeners, listener);\r\n\t\t\t\t\tif(index > -1){ // check to make sure we haven't already called cancel\r\n\t\t\t\t\t\tlisteners.splice(index, 1);\r\n\t\t\t\t\t\tif(!listeners.length){\r\n\t\t\t\t\t\t\t// no more listeners, remove the query updater too\r\n\t\t\t\t\t\t\tqueryUpdaters.splice(array.indexOf(queryUpdaters, queryUpdater), 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\treturn handle;\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\tvar inMethod;\r\n\tfunction whenFinished(method, action){\r\n\t\tvar original = store[method];\r\n\t\tif(original){\r\n\t\t\tstore[method] = function(value){\r\n\t\t\t\tvar originalId;\r\n\t\t\t\tif(method === 'put'){\r\n\t\t\t\t\toriginalId = store.getIdentity(value);\r\n\t\t\t\t}\r\n\t\t\t\tif(inMethod){\r\n\t\t\t\t\t// if one method calls another (like add() calling put()) we don't want two events\r\n\t\t\t\t\treturn original.apply(this, arguments);\r\n\t\t\t\t}\r\n\t\t\t\tinMethod = true;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tvar results = original.apply(this, arguments);\r\n\t\t\t\t\twhen(results, function(results){\r\n\t\t\t\t\t\taction((typeof results == \"object\" && results) || value, originalId);\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}finally{\r\n\t\t\t\t\tinMethod = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\t// monitor for updates by listening to these methods\r\n\twhenFinished(\"put\", function(object, originalId){\r\n\t\tstore.notify(object, originalId);\r\n\t});\r\n\twhenFinished(\"add\", function(object){\r\n\t\tstore.notify(object);\r\n\t});\r\n\twhenFinished(\"remove\", function(id){\r\n\t\tstore.notify(undefined, id);\r\n\t});\r\n\r\n\treturn store;\r\n};\r\n\r\nlang.setObject(\"dojo.store.Observable\", Observable);\r\n\r\nreturn Observable;\r\n});\r\n"]}