{"version":3,"sources":["AdapterRegistry.js"],"names":["define","dojo","lang","AdapterRegistry","returnWrappers","this","pairs","extend","register","name","check","wrap","directReturn","override","match","i","length","pair","apply","arguments","Error","unregister","splice"],"mappings":";;;;;;;AAAAA,QAAQ,iBAAkB,gBAAiB,SAASC,EAAMC,GAI1D,IAAIC,EAAkBF,EAAKE,gBAAkB,SAAsBC,GAkClEC,KAAKC,SACLD,KAAKD,eAAiBA,IAAkB,GAsEzC,OAnEAF,EAAKK,OAAOJ,GACXK,SAAU,SAAoBC,EAAmBC,EAAoBC,EAAmBC,EAA2BC,GAqBlHR,KAAKC,MAAO,EAAa,UAAY,SAAUG,EAAMC,EAAOC,EAAMC,KAGnEE,MAAO,WAMN,IAAI,IAAIC,EAAI,EAAGA,EAAIV,KAAKC,MAAMU,OAAQD,IAAI,CACzC,IAAIE,EAAOZ,KAAKC,MAAMS,GACtB,GAAGE,EAAK,GAAGC,MAAMb,KAAMc,WACtB,OAAIF,EAAK,IAAMZ,KAAmB,eAC1BY,EAAK,GAELA,EAAK,GAAGC,MAAMb,KAAMc,WAI9B,MAAM,IAAIC,MAAM,mBAGjBC,WAAY,SAASZ,GAYpB,IAAI,IAAIM,EAAI,EAAGA,EAAIV,KAAKC,MAAMU,OAAQD,IAAI,CAEzC,GADWV,KAAKC,MAAMS,GACd,IAAMN,EAEb,OADAJ,KAAKC,MAAMgB,OAAOP,EAAG,IACd,EAGT,OAAO,KAIFZ","file":"../AdapterRegistry.js","sourcesContent":["define([\"./_base/kernel\", \"./_base/lang\"], function(dojo, lang){\r\n// module:\r\n//\t\tdojo/AdapterRegistry\r\n\r\nvar AdapterRegistry = dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){\r\n\t// summary:\r\n\t//\t\tA registry to make contextual calling/searching easier.\r\n\t// description:\r\n\t//\t\tObjects of this class keep list of arrays in the form [name, check,\r\n\t//\t\twrap, directReturn] that are used to determine what the contextual\r\n\t//\t\tresult of a set of checked arguments is. All check/wrap functions\r\n\t//\t\tin this registry should be of the same arity.\r\n\t// example:\r\n\t//\t|\t// create a new registry\r\n\t//\t|\trequire([\"dojo/AdapterRegistry\"],\r\n\t//\t|\tfunction(AdapterRegistry){\r\n\t//\t|\t\tvar reg = new AdapterRegistry();\r\n\t//\t|\t\treg.register(\"handleString\",\r\n\t//\t|\t\t\tfunction(str){\r\n\t//\t|\t\t\t\treturn typeof val == \"string\"\r\n\t//\t|\t\t\t},\r\n\t//\t|\t\t\tfunction(str){\r\n\t//\t|\t\t\t\t// do something with the string here\r\n\t//\t|\t\t\t}\r\n\t//\t|\t\t);\r\n\t//\t|\t\treg.register(\"handleArr\",\r\n\t//\t|\t\t\tdojo.isArray,\r\n\t//\t|\t\t\tfunction(arr){\r\n\t//\t|\t\t\t\t// do something with the array here\r\n\t//\t|\t\t\t}\r\n\t//\t|\t\t);\r\n\t//\t|\r\n\t//\t|\t\t// now we can pass reg.match() *either* an array or a string and\r\n\t//\t|\t\t// the value we pass will get handled by the right function\r\n\t//\t|\t\treg.match(\"someValue\"); // will call the first function\r\n\t//\t|\t\treg.match([\"someValue\"]); // will call the second\r\n\t//\t|\t});\r\n\r\n\tthis.pairs = [];\r\n\tthis.returnWrappers = returnWrappers || false; // Boolean\r\n};\r\n\r\nlang.extend(AdapterRegistry, {\r\n\tregister: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){\r\n\t\t// summary:\r\n\t\t//\t\tregister a check function to determine if the wrap function or\r\n\t\t//\t\tobject gets selected\r\n\t\t// name:\r\n\t\t//\t\ta way to identify this matcher.\r\n\t\t// check:\r\n\t\t//\t\ta function that arguments are passed to from the adapter's\r\n\t\t//\t\tmatch() function.  The check function should return true if the\r\n\t\t//\t\tgiven arguments are appropriate for the wrap function.\r\n\t\t// directReturn:\r\n\t\t//\t\tIf directReturn is true, the value passed in for wrap will be\r\n\t\t//\t\treturned instead of being called. Alternately, the\r\n\t\t//\t\tAdapterRegistry can be set globally to \"return not call\" using\r\n\t\t//\t\tthe returnWrappers property. Either way, this behavior allows\r\n\t\t//\t\tthe registry to act as a \"search\" function instead of a\r\n\t\t//\t\tfunction interception library.\r\n\t\t// override:\r\n\t\t//\t\tIf override is given and true, the check function will be given\r\n\t\t//\t\thighest priority. Otherwise, it will be the lowest priority\r\n\t\t//\t\tadapter.\r\n\t\tthis.pairs[((override) ? \"unshift\" : \"push\")]([name, check, wrap, directReturn]);\r\n\t},\r\n\r\n\tmatch: function(/* ... */){\r\n\t\t// summary:\r\n\t\t//\t\tFind an adapter for the given arguments. If no suitable adapter\r\n\t\t//\t\tis found, throws an exception. match() accepts any number of\r\n\t\t//\t\targuments, all of which are passed to all matching functions\r\n\t\t//\t\tfrom the registered pairs.\r\n\t\tfor(var i = 0; i < this.pairs.length; i++){\r\n\t\t\tvar pair = this.pairs[i];\r\n\t\t\tif(pair[1].apply(this, arguments)){\r\n\t\t\t\tif((pair[3])||(this.returnWrappers)){\r\n\t\t\t\t\treturn pair[2];\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn pair[2].apply(this, arguments);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error(\"No match found\");\r\n\t},\r\n\r\n\tunregister: function(name){\r\n\t\t// summary:\r\n\t\t//\t\tRemove a named adapter from the registry\r\n\t\t// name: String\r\n\t\t//\t\tThe name of the adapter.\r\n\t\t// returns: Boolean\r\n\t\t//\t\tReturns true if operation is successful.\r\n\t\t//\t\tReturns false if operation fails.\r\n\t\r\n\t\t// FIXME: this is kind of a dumb way to handle this. On a large\r\n\t\t// registry this will be slow-ish and we can use the name as a lookup\r\n\t\t// should we choose to trade memory for speed.\r\n\t\tfor(var i = 0; i < this.pairs.length; i++){\r\n\t\t\tvar pair = this.pairs[i];\r\n\t\t\tif(pair[0] == name){\r\n\t\t\t\tthis.pairs.splice(i, 1);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\nreturn AdapterRegistry;\r\n});\r\n"]}