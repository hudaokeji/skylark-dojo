{"version":3,"sources":["NodeList-data.js"],"names":["define","dojo","query","lang","array","attr","NodeList","dataCache","x","dataattr","dopid","node","pid","get","set","_nodeDataCache","dodata","_nodeData","key","value","r","arguments","length","mixin","removeData","_removeNodeData","_gcNodeData","livePids","map","i","indexOf","extend","data","_adaptWithCondition","a","_adaptAsForEach"],"mappings":";;;;;;;AAAAA,QACC,iBAAkB,UAAW,eAAgB,gBAAiB,cAC5D,SAASC,EAAMC,EAAOC,EAAMC,EAAOC,GAYrC,IAAIC,EAAWJ,EAAMI,SAEjBC,KAAgBC,EAAI,EAAGC,EAAW,mBACrCC,EAAQ,SAASC,GAGhB,IAAIC,EAAMP,EAAKQ,IAAIF,EAAMF,GAKzB,OAJIG,IACHA,EAAM,MAASJ,IACfH,EAAKS,IAAIH,EAAMF,EAAUG,IAEnBA,GAQTN,EAASS,eAAiBd,EAAKc,eAAiBR,EAGhD,IAAIS,EAASf,EAAKgB,UAAY,SAASN,EAAMO,EAAKC,GAgBjD,IAAuBC,EAAnBR,EAAMF,EAAMC,GAIhB,OAHIJ,EAAUK,KAAOL,EAAUK,OAGR,GAApBS,UAAUC,OAAqBf,EAAUK,IAC3B,iBAAPM,EAENG,UAAUC,OAAS,EACrBf,EAAUK,GAAKM,GAAOC,EAEtBC,EAAIb,EAAUK,GAAKM,GAKpBE,EAAIjB,EAAKoB,MAAMhB,EAAUK,GAAMM,GAGzBE,IAGJI,EAAavB,EAAKwB,gBAAkB,SAASd,EAAMO,GAQtD,IAAIN,EAAMF,EAAMC,GACbJ,EAAUK,KACTM,SACKX,EAAUK,GAAKM,UAEfX,EAAUK,KAmHpB,OA9GAN,EAASoB,YAAczB,EAAKyB,YAAc,WAUzC,IAAIC,EAAWzB,EAAM,IAAMO,EAAW,KAAKmB,IAAIlB,GAC/C,IAAI,IAAImB,KAAKtB,EACTH,EAAM0B,QAAQH,EAAUE,GAAK,UAAWtB,EAAUsB,IAKvD1B,EAAK4B,OAAOzB,GACX0B,KAAM1B,EAAS2B,oBAAoBjB,EAAQ,SAASkB,GACnD,OAAoB,IAAbA,EAAEZ,QAA4B,GAAZY,EAAEZ,QAA+B,iBAARY,EAAE,KAErDV,WAAYlB,EAAS6B,gBAAgBX,KAyF/BlB","file":"../NodeList-data.js","sourcesContent":["define([\r\n\t\"./_base/kernel\", \"./query\", \"./_base/lang\", \"./_base/array\", \"./dom-attr\"\r\n], function(dojo, query, lang, array, attr){\r\n\r\n\t// module:\r\n\t//\t\tdojo/NodeList-data\r\n\r\n\t/*=====\r\n\treturn function(){\r\n\t\t// summary:\r\n\t\t//\t\tAdds data() and removeData() methods to NodeList, and returns NodeList constructor.\r\n\t};\r\n\t=====*/\r\n\r\n\tvar NodeList = query.NodeList;\r\n\r\n\tvar dataCache = {}, x = 0, dataattr = \"data-dojo-dataid\",\r\n\t\tdopid = function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn a uniqueish ID for the passed node reference\r\n\t\t\tvar pid = attr.get(node, dataattr);\r\n\t\t\tif(!pid){\r\n\t\t\t\tpid = \"pid\" + (x++);\r\n\t\t\t\tattr.set(node, dataattr, pid);\r\n\t\t\t}\r\n\t\t\treturn pid;\r\n\t\t}\r\n\t;\r\n\r\n\t//>>excludeStart(\"debugging\", true);\r\n\t// An alias to the private dataCache for NodeList-data. NEVER USE THIS!\r\n\t// This private is only exposed for the benefit of unit testing, and is\r\n\t// removed during the build process.\r\n\tNodeList._nodeDataCache = dojo._nodeDataCache = dataCache;\r\n\t//>>excludeEnd(\"debugging\");\r\n\r\n\tvar dodata = dojo._nodeData = function(node, key, value){\r\n\t\t// summary:\r\n\t\t//\t\tPrivate helper for dojo/NodeList.data for single node data access. Refer to NodeList.data\r\n\t\t//\t\tdocumentation for more information.\r\n\t\t//\r\n\t\t// node: String|DomNode\r\n\t\t//\t\tThe node to associate data with\r\n\t\t//\r\n\t\t// key: Object|String?\r\n\t\t//\t\tIf an object, act as a setter and iterate over said object setting data items as defined.\r\n\t\t//\t\tIf a string, and `value` present, set the data for defined `key` to `value`\r\n\t\t//\t\tIf a string, and `value` absent, act as a getter, returning the data associated with said `key`\r\n\t\t//\r\n\t\t// value: Anything?\r\n\t\t//\t\tThe value to set for said `key`, provided `key` is a string (and not an object)\r\n\t\t//\r\n\t\tvar pid = dopid(node), r;\r\n\t\tif(!dataCache[pid]){ dataCache[pid] = {}; }\r\n\r\n\t\t// API discrepency: calling with only a node returns the whole object. $.data throws\r\n\t\tif(arguments.length == 1){ return dataCache[pid]; }\r\n\t\tif(typeof key == \"string\"){\r\n\t\t\t// either getter or setter, based on `value` presence\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\tdataCache[pid][key] = value;\r\n\t\t\t}else{\r\n\t\t\t\tr = dataCache[pid][key];\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// must be a setter, mix `value` into data hash\r\n\t\t\t// API discrepency: using object as setter works here\r\n\t\t\tr = lang.mixin(dataCache[pid], key);\r\n\t\t}\r\n\r\n\t\treturn r; // Object|Anything|Nothing\r\n\t};\r\n\r\n\tvar removeData = dojo._removeNodeData = function(node, key){\r\n\t\t// summary:\r\n\t\t//\t\tRemove some data from this node\r\n\t\t// node: String|DomNode\r\n\t\t//\t\tThe node reference to remove data from\r\n\t\t// key: String?\r\n\t\t//\t\tIf omitted, remove all data in this dataset.\r\n\t\t//\t\tIf passed, remove only the passed `key` in the associated dataset\r\n\t\tvar pid = dopid(node);\r\n\t\tif(dataCache[pid]){\r\n\t\t\tif(key){\r\n\t\t\t\tdelete dataCache[pid][key];\r\n\t\t\t}else{\r\n\t\t\t\tdelete dataCache[pid];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tNodeList._gcNodeData = dojo._gcNodeData = function(){\r\n\t\t// summary:\r\n\t\t//\t\tsuper expensive: GC all data in the data for nodes that no longer exist in the dom.\r\n\t\t// description:\r\n\t\t//\t\tsuper expensive: GC all data in the data for nodes that no longer exist in the dom.\r\n\t\t//\t\tMUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)\r\n\t\t//\t\tprovided as a stop-gap for exceptionally large/complex applications with constantly changing\r\n\t\t//\t\tcontent regions (eg: a dijit/layout/ContentPane with replacing data)\r\n\t\t//\t\tThere is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData\r\n\t\t//\t\tprior to destruction.\r\n\t\tvar livePids = query(\"[\" + dataattr + \"]\").map(dopid);\r\n\t\tfor(var i in dataCache){\r\n\t\t\tif(array.indexOf(livePids, i) < 0){ delete dataCache[i]; }\r\n\t\t}\r\n\t};\r\n\r\n\t// make nodeData and removeNodeData public on dojo/NodeList:\r\n\tlang.extend(NodeList, {\r\n\t\tdata: NodeList._adaptWithCondition(dodata, function(a){\r\n\t\t\treturn a.length === 0 || a.length == 1 && (typeof a[0] == \"string\");\r\n\t\t}),\r\n\t\tremoveData: NodeList._adaptAsForEach(removeData)\r\n\t});\r\n\r\n\t/*=====\r\n\t lang.extend(NodeList, {\r\n\t\t data: function(key, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tstash or get some arbitrary data on/from these nodes.\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tStash or get some arbitrary data on/from these nodes. This private _data function is\r\n\t\t\t//\t\texposed publicly on `dojo/NodeList`, eg: as the result of a `dojo/query` call.\r\n\t\t\t//\t\tDIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS\r\n\t\t\t//\t\treturned. EVEN WHEN THE LIST IS length == 1.\r\n\t\t\t//\r\n\t\t\t//\t\tA single-node version of this function is provided as `dojo._nodeData`, which follows\r\n\t\t\t//\t\tthe same signature, though expects a String ID or DomNode reference in the first\r\n\t\t\t//\t\tposition, before key/value arguments.\r\n\t\t\t//\r\n\t\t\t// node: String|DomNode\r\n\t\t\t//\t\tThe node to associate data with\r\n\t\t\t//\r\n\t\t\t// key: Object|String?\r\n\t\t\t//\t\tIf an object, act as a setter and iterate over said object setting data items as defined.\r\n\t\t\t//\t\tIf a string, and `value` present, set the data for defined `key` to `value`\r\n\t\t\t//\t\tIf a string, and `value` absent, act as a getter, returning the data associated with said `key`\r\n\t\t\t//\r\n\t\t\t// value: Anything?\r\n\t\t\t//\t\tThe value to set for said `key`, provided `key` is a string (and not an object)\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tSet a key `bar` to some data, then retrieve it.\r\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\r\n\t\t\t//\t|\t\tquery(\".foo\").data(\"bar\", \"touched\");\r\n\t\t\t//\t|\t\tvar touched = query(\".foo\").data(\"bar\");\r\n\t\t\t//\t|\t\tif(touched[0] == \"touched\"){ alert('win'); }\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tGet all the data items for a given node.\r\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\r\n\t\t\t//\t|\t\tvar list = query(\".foo\").data();\r\n\t\t\t//\t|\t\tvar first = list[0];\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tSet the data to a complex hash. Overwrites existing keys with new value\r\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\r\n\t\t\t//\t|\t\tquery(\".foo\").data({ bar:\"baz\", foo:\"bar\" });\r\n\t\t\t//\t\tThen get some random key:\r\n\t\t\t//\t|\t\tquery(\".foo\").data(\"foo\"); // returns [`bar`]\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// returns: Object|Anything|Nothing\r\n\t\t\t//\t\tWhen used as a setter via `dojo/NodeList`, a NodeList instance is returned\r\n\t\t\t//\t\tfor further chaining. When used as a getter via `dojo/NodeList` an ARRAY\r\n\t\t\t//\t\tof items is returned. The items in the array correspond to the elements\r\n\t\t\t//\t\tin the original list. This is true even when the list length is 1, eg:\r\n\t\t\t//\t\twhen looking up a node by ID (#foo)\r\n\t\t },\r\n\r\n\t\t removeData: function(key){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRemove the data associated with these nodes.\r\n\t\t\t// key: String?\r\n\t\t\t//\t\tIf omitted, clean all data for this node.\r\n\t\t\t//\t\tIf passed, remove the data item found at `key`\r\n\t\t }\r\n\t });\r\n\t =====*/\r\n\r\n// TODO: this is the basic implementation of adaptWithConditionAndWhenMappedConsiderLength, for lack of a better API name\r\n// it conflicts with the the `dojo/NodeList` way: always always return an arrayLike thinger. Consider for 2.0:\r\n//\r\n//\tNodeList.prototype.data = function(key, value){\r\n//\t\tvar a = arguments, r;\r\n//\t\tif(a.length === 0 || a.length == 1 && (typeof a[0] == \"string\")){\r\n//\t\t\tr = this.map(function(node){\r\n//\t\t\t\treturn d._data(node, key);\r\n//\t\t\t});\r\n//\t\t\tif(r.length == 1){ r = r[0]; } // the offending line, and the diff on adaptWithCondition\r\n//\t\t}else{\r\n//\t\t\tr = this.forEach(function(node){\r\n//\t\t\t\td._data(node, key, value);\r\n//\t\t\t});\r\n//\t\t}\r\n//\t\treturn r; // NodeList|Array|SingleItem\r\n//\t};\r\n\r\n\treturn NodeList;\r\n\r\n});\r\n"]}