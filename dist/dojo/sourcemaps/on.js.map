{"version":3,"sources":["on.js"],"names":["define","aspect","dojo","has","major","window","ScriptEngineMajorVersion","add","ScriptEngineMinorVersion","Event","prototype","stopImmediatePropagation","global","doc","element","EventDelegate","document","createEvent","eventDelegate","target","e","on","type","listener","dontFix","nodeType","parse","addListener","this","pausable","paused","signal","apply","arguments","pause","resume","once","remove","matchesTarget","call","Array","events","indexOf","split","eventName","handles","i","push","length","touchEvents","selector","match","test","fixTouchListener","addStopImmediate","addEventListener","capture","captures","adjustedType","removeEventListener","fixAttach","attachEvent","Error","syntheticPreventDefault","cancelable","defaultPrevented","syntheticStopPropagation","bubbles","matches","node","context","children","query","parentNode","eventType","bubble","select","eventTarget","event","slice","syntheticDispatch","emit","args","method","newEvent","preventDefault","stopPropagation","focusin","focusout","immediatelyStopped","modified","dispatchEvent","nativeEvent","ownerDocument","initEvent","_fixEvent","evt","sender","parentWindow","lastEvent","srcElement","currentTarget","relatedTarget","fromElement","toElement","c","charCode","keyCode","_setKeyChar","IESignal","handle","_dojoIEListeners_","result","setTimeout","fixListener","top","emitter","listeners","oldListener","Function","after","keyChar","String","fromCharCode","charOrCode","cancelBubble","_preventDefault","bubbledKeyCode","ctrlKey","returnValue","windowOrientation","orientation","originalEvent","corrected","name","rotation","scale","firstChangeTouch","changedTouches"],"mappings":"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","file":"../on.js","sourcesContent":["define([\"./has!dom-addeventlistener?:./aspect\", \"./_base/kernel\", \"./sniff\"], function(aspect, dojo, has){\r\n\r\n\t\"use strict\";\r\n\tif(has(\"dom\")){ // check to make sure we are in a browser, this module should work anywhere\r\n\t\tvar major = window.ScriptEngineMajorVersion;\r\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() / 10));\r\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); // TODO: how do we detect this?\r\n\t\thas.add(\"event-stopimmediatepropagation\", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);\r\n\t\thas.add(\"event-focusin\", function(global, doc, element){\r\n\t\t\treturn 'onfocusin' in element;\r\n\t\t});\r\n\t\t\r\n\t\tif(has(\"touch\")){\r\n\t\t\thas.add(\"touch-can-modify-event-delegate\", function(){\r\n\t\t\t\t// This feature test checks whether deleting a property of an event delegate works\r\n\t\t\t\t// for a touch-enabled device. If it works, event delegation can be used as fallback\r\n\t\t\t\t// for browsers such as Safari in older iOS where deleting properties of the original\r\n\t\t\t\t// event does not work.\r\n\t\t\t\tvar EventDelegate = function(){};\r\n\t\t\t\tEventDelegate.prototype =\r\n\t\t\t\t\tdocument.createEvent(\"MouseEvents\"); // original event\r\n\t\t\t\t// Attempt to modify a property of an event delegate and check if\r\n\t\t\t\t// it succeeds. Depending on browsers and on whether dojo/on's\r\n\t\t\t\t// strict mode is stripped in a Dojo build, there are 3 known behaviors:\r\n\t\t\t\t// it may either succeed, or raise an error, or fail to set the property\r\n\t\t\t\t// without raising an error.\r\n\t\t\t\ttry{\r\n\t\t\t\t\tvar eventDelegate = new EventDelegate;\r\n\t\t\t\t\teventDelegate.target = null;\r\n\t\t\t\t\treturn eventDelegate.target === null;\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\treturn false; // cannot use event delegation\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tvar on = function(target, type, listener, dontFix){\r\n\t\t// summary:\r\n\t\t//\t\tA function that provides core event listening functionality. With this function\r\n\t\t//\t\tyou can provide a target, event type, and listener to be notified of\r\n\t\t//\t\tfuture matching events that are fired.\r\n\t\t// target: Element|Object\r\n\t\t//\t\tThis is the target object or DOM element that to receive events from\r\n\t\t// type: String|Function\r\n\t\t//\t\tThis is the name of the event to listen for or an extension event type.\r\n\t\t// listener: Function\r\n\t\t//\t\tThis is the function that should be called when the event fires.\r\n\t\t// returns: Object\r\n\t\t//\t\tAn object with a remove() method that can be used to stop listening for this\r\n\t\t//\t\tevent.\r\n\t\t// description:\r\n\t\t//\t\tTo listen for \"click\" events on a button node, we can do:\r\n\t\t//\t\t|\tdefine([\"dojo/on\"], function(on){\r\n\t\t//\t\t|\t\ton(button, \"click\", clickHandler);\r\n\t\t//\t\t|\t\t...\r\n\t\t//\t\tEvented JavaScript objects can also have their own events.\r\n\t\t//\t\t|\tvar obj = new Evented;\r\n\t\t//\t\t|\ton(obj, \"foo\", fooHandler);\r\n\t\t//\t\tAnd then we could publish a \"foo\" event:\r\n\t\t//\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\r\n\t\t//\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\r\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojo/gesture/tap\", function(on, tap){\r\n\t\t//\t\t|\t\ton(button, tap, tapHandler);\r\n\t\t//\t\t|\t\t...\r\n\t\t//\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\r\n\t\t//\t\t|\tobj.onfoo({key:\"value\"});\r\n\t\t//\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\r\n\r\n\t\tif(typeof target.on == \"function\" && typeof type != \"function\" && !target.nodeType){\r\n\t\t\t// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it \r\n\t\t\t// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the\r\n\t\t\t// Element prototype \r\n\t\t\treturn target.on(type, listener);\r\n\t\t}\r\n\t\t// delegate to main listener code\r\n\t\treturn on.parse(target, type, listener, addListener, dontFix, this);\r\n\t};\r\n\ton.pausable =  function(target, type, listener, dontFix){\r\n\t\t// summary:\r\n\t\t//\t\tThis function acts the same as on(), but with pausable functionality. The\r\n\t\t//\t\treturned signal object has pause() and resume() functions. Calling the\r\n\t\t//\t\tpause() method will cause the listener to not be called for future events. Calling the\r\n\t\t//\t\tresume() method will cause the listener to again be called for future events.\r\n\t\tvar paused;\r\n\t\tvar signal = on(target, type, function(){\r\n\t\t\tif(!paused){\r\n\t\t\t\treturn listener.apply(this, arguments);\r\n\t\t\t}\r\n\t\t}, dontFix);\r\n\t\tsignal.pause = function(){\r\n\t\t\tpaused = true;\r\n\t\t};\r\n\t\tsignal.resume = function(){\r\n\t\t\tpaused = false;\r\n\t\t};\r\n\t\treturn signal;\r\n\t};\r\n\ton.once = function(target, type, listener, dontFix){\r\n\t\t// summary:\r\n\t\t//\t\tThis function acts the same as on(), but will only call the listener once. The \r\n\t\t//\t\tlistener will be called for the first\r\n\t\t//\t\tevent that takes place and then listener will automatically be removed.\r\n\t\tvar signal = on(target, type, function(){\r\n\t\t\t// remove this listener\r\n\t\t\tsignal.remove();\r\n\t\t\t// proceed to call the listener\r\n\t\t\treturn listener.apply(this, arguments);\r\n\t\t});\r\n\t\treturn signal;\r\n\t};\r\n\ton.parse = function(target, type, listener, addListener, dontFix, matchesTarget){\r\n\t\tif(type.call){\r\n\t\t\t// event handler function\r\n\t\t\t// on(node, touch.press, touchListener);\r\n\t\t\treturn type.call(matchesTarget, target, listener);\r\n\t\t}\r\n\r\n\t\tif(type instanceof Array){\r\n\t\t\t// allow an array of event names (or event handler functions)\r\n\t\t\tevents = type;\r\n\t\t}else if(type.indexOf(\",\") > -1){\r\n\t\t\t// we allow comma delimited event names, so you can register for multiple events at once\r\n\t\t\tvar events = type.split(/\\s*,\\s*/);\r\n\t\t} \r\n\t\tif(events){\r\n\t\t\tvar handles = [];\r\n\t\t\tvar i = 0;\r\n\t\t\tvar eventName;\r\n\t\t\twhile(eventName = events[i++]){\r\n\t\t\t\thandles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));\r\n\t\t\t}\r\n\t\t\thandles.remove = function(){\r\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\r\n\t\t\t\t\thandles[i].remove();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn handles;\r\n\t\t}\r\n\t\treturn addListener(target, type, listener, dontFix, matchesTarget);\r\n\t};\r\n\tvar touchEvents = /^touch/;\r\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\r\n\t\t// event delegation:\r\n\t\tvar selector = type.match(/(.*):(.*)/);\r\n\t\t// if we have a selector:event, the last one is interpreted as an event, and we use event delegation\r\n\t\tif(selector){\r\n\t\t\ttype = selector[2];\r\n\t\t\tselector = selector[1];\r\n\t\t\t// create the extension event for selectors and directly call it\r\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\r\n\t\t}\r\n\t\t// test to see if it a touch event right now, so we don't have to do it every time it fires\r\n\t\tif(has(\"touch\")){\r\n\t\t\tif(touchEvents.test(type)){\r\n\t\t\t\t// touch event, fix it\r\n\t\t\t\tlistener = fixTouchListener(listener);\r\n\t\t\t}\r\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\r\n\t\t\t\t//\"orientationchange\" not supported <= Android 2.1, \r\n\t\t\t\t//but works through \"resize\" on window\r\n\t\t\t\ttype = \"resize\"; \r\n\t\t\t\ttarget = window;\r\n\t\t\t\tlistener = fixTouchListener(listener);\r\n\t\t\t} \r\n\t\t}\r\n\t\tif(addStopImmediate){\r\n\t\t\t// add stopImmediatePropagation if it doesn't exist\r\n\t\t\tlistener = addStopImmediate(listener);\r\n\t\t}\r\n\t\t// normal path, the target is |this|\r\n\t\tif(target.addEventListener){\r\n\t\t\t// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\r\n\t\t\t// check for capture conversions\r\n\t\t\tvar capture = type in captures,\r\n\t\t\t\tadjustedType = capture ? captures[type] : type;\r\n\t\t\ttarget.addEventListener(adjustedType, listener, capture);\r\n\t\t\t// create and return the signal\r\n\t\t\treturn {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\ttarget.removeEventListener(adjustedType, listener, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\ttype = \"on\" + type;\r\n\t\tif(fixAttach && target.attachEvent){\r\n\t\t\treturn fixAttach(target, type, listener);\r\n\t\t}\r\n\t\tthrow new Error(\"Target must be an event emitter\");\r\n\t}\r\n\ton.matches = function(node, selector, context, children, matchesTarget) {\r\n\t\t// summary:\r\n\t\t//\t\tCheck if a node match the current selector within the constraint of a context\r\n\t\t// node: DOMNode\r\n\t\t//\t\tThe node that originate the event\r\n\t\t// selector: String\r\n\t\t//\t\tThe selector to check against\r\n\t\t// context: DOMNode\r\n\t\t//\t\tThe context to search in.\r\n\t\t// children: Boolean\r\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to\r\n\t\t//\t\ttrue\r\n\t\t// matchesTarget: Object|dojo/query?\r\n\t\t//\t\tAn object with a property \"matches\" as a function. Default is dojo/query.\r\n\t\t//\t\tMatching DOMNodes will be done against this function\r\n\t\t//\t\tThe function must return a Boolean.\r\n\t\t//\t\tIt will have 3 arguments: \"node\", \"selector\" and \"context\"\r\n\t\t//\t\tTrue is expected if \"node\" is matching the current \"selector\" in the passed \"context\"\r\n\t\t// returns: DOMNode?\r\n\t\t//\t\tThe matching node, if any. Else you get false\r\n\r\n\t\t// see if we have a valid matchesTarget or default to dojo/query\r\n\t\tmatchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;\r\n\t\tchildren = children !== false;\r\n\t\t// there is a selector, so make sure it matches\r\n\t\tif(node.nodeType != 1){\r\n\t\t\t// text node will fail in native match selector\r\n\t\t\tnode = node.parentNode;\r\n\t\t}\r\n\t\twhile(!matchesTarget.matches(node, selector, context)){\r\n\t\t\tif(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\ton.selector = function(selector, eventType, children){\r\n\t\t// summary:\r\n\t\t//\t\tCreates a new extension event with event delegation. This is based on\r\n\t\t//\t\tthe provided event type (can be extension event) that\r\n\t\t//\t\tonly calls the listener when the CSS selector matches the target of the event.\r\n\t\t//\r\n\t\t//\t\tThe application must require() an appropriate level of dojo/query to handle the selector.\r\n\t\t// selector:\r\n\t\t//\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\r\n\t\t// eventType:\r\n\t\t//\t\tThe event to listen for\r\n\t\t// children:\r\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to \r\n\t\t//\t\ttrue\r\n\t\t// example:\r\n\t\t// |\trequire([\"dojo/on\", \"dojo/mouse\", \"dojo/query!css2\"], function(on, mouse){\r\n\t\t// |\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\r\n\t\treturn function(target, listener){\r\n\t\t\t// if the selector is function, use it to select the node, otherwise use the matches method\r\n\t\t\tvar matchesTarget = typeof selector == \"function\" ? {matches: selector} : this,\r\n\t\t\t\tbubble = eventType.bubble;\r\n\t\t\tfunction select(eventTarget){\r\n\t\t\t\treturn on.matches(eventTarget, selector, target, children, matchesTarget);\r\n\t\t\t}\r\n\t\t\tif(bubble){\r\n\t\t\t\t// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself\r\n\t\t\t\treturn on(target, bubble(select), listener);\r\n\t\t\t}\r\n\t\t\t// standard event delegation\r\n\t\t\treturn on(target, eventType, function(event){\r\n\t\t\t\t// call select to see if we match\r\n\t\t\t\tvar eventTarget = select(event.target);\r\n\t\t\t\t// if it matches we call the listener\r\n\t\t\t\tif (eventTarget) {\r\n\t\t\t\t\treturn listener.call(eventTarget, event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t};\r\n\r\n\tfunction syntheticPreventDefault(){\r\n\t\tthis.cancelable = false;\r\n\t\tthis.defaultPrevented = true;\r\n\t}\r\n\tfunction syntheticStopPropagation(){\r\n\t\tthis.bubbles = false;\r\n\t}\r\n\tvar slice = [].slice,\r\n\t\tsyntheticDispatch = on.emit = function(target, type, event){\r\n\t\t// summary:\r\n\t\t//\t\tFires an event on the target object.\r\n\t\t// target:\r\n\t\t//\t\tThe target object to fire the event on. This can be a DOM element or a plain \r\n\t\t//\t\tJS object. If the target is a DOM element, native event emitting mechanisms\r\n\t\t//\t\tare used when possible.\r\n\t\t// type:\r\n\t\t//\t\tThe event type name. You can emulate standard native events like \"click\" and \r\n\t\t//\t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\r\n\t\t// event:\r\n\t\t//\t\tAn object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent \r\n\t\t//\t\tfor some of the properties. These properties are copied to the event object.\r\n\t\t//\t\tOf particular importance are the cancelable and bubbles properties. The\r\n\t\t//\t\tcancelable property indicates whether or not the event has a default action\r\n\t\t//\t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\r\n\t\t//\t\tthe event object. The bubbles property indicates whether or not the\r\n\t\t//\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\r\n\t\t//\t\ton the target and then each parent successively until the top of the tree\r\n\t\t//\t\tis reached or stopPropagation() is called. Both bubbles and cancelable \r\n\t\t//\t\tdefault to false.\r\n\t\t// returns:\r\n\t\t//\t\tIf the event is cancelable and the event is not cancelled,\r\n\t\t//\t\temit will return true. If the event is cancelable and the event is cancelled,\r\n\t\t//\t\temit will return false.\r\n\t\t// details:\r\n\t\t//\t\tNote that this is designed to emit events for listeners registered through\r\n\t\t//\t\tdojo/on. It should actually work with any event listener except those\r\n\t\t//\t\tadded through IE's attachEvent (IE8 and below's non-W3C event emitting\r\n\t\t//\t\tdoesn't support custom event types). It should work with all events registered\r\n\t\t//\t\tthrough dojo/on. Also note that the emit method does do any default\r\n\t\t//\t\taction, it only returns a value to indicate if the default action should take\r\n\t\t//\t\tplace. For example, emitting a keypress event would not cause a character\r\n\t\t//\t\tto appear in a textbox.\r\n\t\t// example:\r\n\t\t//\t\tTo fire our own click event\r\n\t\t//\t|\trequire([\"dojo/on\", \"dojo/dom\"\r\n\t\t//\t|\t], function(on, dom){\r\n\t\t//\t|\t\ton.emit(dom.byId(\"button\"), \"click\", {\r\n\t\t//\t|\t\t\tcancelable: true,\r\n\t\t//\t|\t\t\tbubbles: true,\r\n\t\t//\t|\t\t\tscreenX: 33,\r\n\t\t//\t|\t\t\tscreenY: 44\r\n\t\t//\t|\t\t});\r\n\t\t//\t\tWe can also fire our own custom events:\r\n\t\t//\t|\t\ton.emit(dom.byId(\"slider\"), \"slide\", {\r\n\t\t//\t|\t\t\tcancelable: true,\r\n\t\t//\t|\t\t\tbubbles: true,\r\n\t\t//\t|\t\t\tdirection: \"left-to-right\"\r\n\t\t//\t|\t\t});\r\n\t\t//\t|\t});\r\n\t\tvar args = slice.call(arguments, 2);\r\n\t\tvar method = \"on\" + type;\r\n\t\tif(\"parentNode\" in target){\r\n\t\t\t// node (or node-like), create event controller methods\r\n\t\t\tvar newEvent = args[0] = {};\r\n\t\t\tfor(var i in event){\r\n\t\t\t\tnewEvent[i] = event[i];\r\n\t\t\t}\r\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\r\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\r\n\t\t\tnewEvent.target = target;\r\n\t\t\tnewEvent.type = type;\r\n\t\t\tevent = newEvent;\r\n\t\t}\r\n\t\tdo{\r\n\t\t\t// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)\r\n\t\t\ttarget[method] && target[method].apply(target, args);\r\n\t\t\t// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\r\n\t\t}while(event && event.bubbles && (target = target.parentNode));\r\n\t\treturn event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\r\n\t};\r\n\tvar captures = has(\"event-focusin\") ? {} : {focusin: \"focus\", focusout: \"blur\"};\r\n\tif(!has(\"event-stopimmediatepropagation\")){\r\n\t\tvar stopImmediatePropagation =function(){\r\n\t\t\tthis.immediatelyStopped = true;\r\n\t\t\tthis.modified = true; // mark it as modified so the event will be cached in IE\r\n\t\t};\r\n\t\tvar addStopImmediate = function(listener){\r\n\t\t\treturn function(event){\r\n\t\t\t\tif(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately\r\n\t\t\t\t\tevent.stopImmediatePropagation = stopImmediatePropagation;\r\n\t\t\t\t\treturn listener.apply(this, arguments);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t} \r\n\tif(has(\"dom-addeventlistener\")){\r\n\t\t// emitter that works with native event handling\r\n\t\ton.emit = function(target, type, event){\r\n\t\t\tif(target.dispatchEvent && document.createEvent){\r\n\t\t\t\t// use the native event emitting mechanism if it is available on the target object\r\n\t\t\t\t// create a generic event\t\t\t\t\r\n\t\t\t\t// we could create branch into the different types of event constructors, but \r\n\t\t\t\t// that would be a lot of extra code, with little benefit that I can see, seems \r\n\t\t\t\t// best to use the generic constructor and copy properties over, making it \r\n\t\t\t\t// easy to have events look like the ones created with specific initializers\r\n\t\t\t\tvar ownerDocument = target.ownerDocument || document;\r\n\t\t\t\tvar nativeEvent = ownerDocument.createEvent(\"HTMLEvents\");\r\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\r\n\t\t\t\t// and copy all our properties over\r\n\t\t\t\tfor(var i in event){\r\n\t\t\t\t\tif(!(i in nativeEvent)){\r\n\t\t\t\t\t\tnativeEvent[i] = event[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\r\n\t\t\t}\r\n\t\t\treturn syntheticDispatch.apply(on, arguments); // emit for a non-node\r\n\t\t};\r\n\t}else{\r\n\t\t// no addEventListener, basically old IE event normalization\r\n\t\ton._fixEvent = function(evt, sender){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tnormalizes properties on the event object including event\r\n\t\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\r\n\t\t\t// evt:\r\n\t\t\t//\t\tnative event object\r\n\t\t\t// sender:\r\n\t\t\t//\t\tnode to treat as \"currentTarget\"\r\n\t\t\tif(!evt){\r\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\r\n\t\t\t\tevt = w.event;\r\n\t\t\t}\r\n\t\t\tif(!evt){return evt;}\r\n\t\t\ttry{\r\n\t\t\t\tif(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){\r\n\t\t\t\t\t// should be same event, reuse event object (so it can be augmented);\r\n\t\t\t\t\t// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below\r\n\t\t\t\t\tevt = lastEvent;\r\n\t\t\t\t}\r\n\t\t\t}catch(e){\r\n\t\t\t\t// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already\r\n\t\t\t\t// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet\r\n\t\t\t}\r\n\t\t\tif(!evt.target){ // check to see if it has been fixed yet\r\n\t\t\t\tevt.target = evt.srcElement;\r\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\r\n\t\t\t\tif(evt.type == \"mouseover\"){\r\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\r\n\t\t\t\t}\r\n\t\t\t\tif(evt.type == \"mouseout\"){\r\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\r\n\t\t\t\t}\r\n\t\t\t\tif(!evt.stopPropagation){\r\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\r\n\t\t\t\t\tevt.preventDefault = preventDefault;\r\n\t\t\t\t}\r\n\t\t\t\tswitch(evt.type){\r\n\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\r\n\t\t\t\t\t\tif (c==10){\r\n\t\t\t\t\t\t\t// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\r\n\t\t\t\t\t\t\tc=0;\r\n\t\t\t\t\t\t\tevt.keyCode = 13;\r\n\t\t\t\t\t\t}else if(c==13||c==27){\r\n\t\t\t\t\t\t\tc=0; // Mozilla considers ENTER and ESC non-printable\r\n\t\t\t\t\t\t}else if(c==3){\r\n\t\t\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Mozilla sets keyCode to 0 when there is a charCode\r\n\t\t\t\t\t\t// but that stops the event on IE.\r\n\t\t\t\t\t\tevt.charCode = c;\r\n\t\t\t\t\t\t_setKeyChar(evt);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn evt;\r\n\t\t};\r\n\t\tvar lastEvent, IESignal = function(handle){\r\n\t\t\tthis.handle = handle;\r\n\t\t};\r\n\t\tIESignal.prototype.remove = function(){\r\n\t\t\tdelete _dojoIEListeners_[this.handle];\r\n\t\t};\r\n\t\tvar fixListener = function(listener){\r\n\t\t\t// this is a minimal function for closing on the previous listener with as few as variables as possible\r\n\t\t\treturn function(evt){\r\n\t\t\t\tevt = on._fixEvent(evt, this);\r\n\t\t\t\tvar result = listener.call(this, evt);\r\n\t\t\t\tif(evt.modified){\r\n\t\t\t\t\t// cache the last event and reuse it if we can\r\n\t\t\t\t\tif(!lastEvent){\r\n\t\t\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\t\t\tlastEvent = null;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastEvent = evt;\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t};\r\n\t\t};\r\n\t\tvar fixAttach = function(target, type, listener){\r\n\t\t\tlistener = fixListener(listener);\r\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || \r\n\t\t\t\t\t\thas(\"jscript\") < 5.8) && \r\n\t\t\t\t\t!has(\"config-_allow_leaks\")){\r\n\t\t\t\t// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\r\n\t\t\t\t// Here we use global redirection to solve the memory leaks\r\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\r\n\t\t\t\t\t_dojoIEListeners_ = [];\r\n\t\t\t\t}\r\n\t\t\t\tvar emitter = target[type];\r\n\t\t\t\tif(!emitter || !emitter.listeners){\r\n\t\t\t\t\tvar oldListener = emitter;\r\n\t\t\t\t\temitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\r\n\t\t\t\t\temitter.listeners = [];\r\n\t\t\t\t\ttarget[type] = emitter;\r\n\t\t\t\t\temitter.global = this;\r\n\t\t\t\t\tif(oldListener){\r\n\t\t\t\t\t\temitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar handle;\r\n\t\t\t\temitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));\r\n\t\t\t\treturn new IESignal(handle);\r\n\t\t\t}\r\n\t\t\treturn aspect.after(target, type, listener, true);\r\n\t\t};\r\n\r\n\t\tvar _setKeyChar = function(evt){\r\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\r\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\t// TODO: remove for 2.0\r\n\t\t};\r\n\t\t// Called in Event scope\r\n\t\tvar stopPropagation = function(){\r\n\t\t\tthis.cancelBubble = true;\r\n\t\t};\r\n\t\tvar preventDefault = on._preventDefault = function(){\r\n\t\t\t// Setting keyCode to 0 is the only way to prevent certain keypresses (namely\r\n\t\t\t// ctrl-combinations that correspond to menu accelerator keys).\r\n\t\t\t// Otoh, it prevents upstream listeners from getting this information\r\n\t\t\t// Try to split the difference here by clobbering keyCode only for ctrl\r\n\t\t\t// combinations. If you still need to access the key upstream, bubbledKeyCode is\r\n\t\t\t// provided as a workaround.\r\n\t\t\tthis.bubbledKeyCode = this.keyCode;\r\n\t\t\tif(this.ctrlKey){\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// squelch errors when keyCode is read-only\r\n\t\t\t\t\t// (e.g. if keyCode is ctrl or shift)\r\n\t\t\t\t\tthis.keyCode = 0;\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.defaultPrevented = true;\r\n\t\t\tthis.returnValue = false;\r\n\t\t\tthis.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE\r\n\t\t};\r\n\t}\r\n\tif(has(\"touch\")){ \r\n\t\tvar EventDelegate = function(){};\r\n\t\tvar windowOrientation = window.orientation; \r\n\t\tvar fixTouchListener = function(listener){ \r\n\t\t\treturn function(originalEvent){ \r\n\t\t\t\t//Event normalization(for ontouchxxx and resize): \r\n\t\t\t\t//1.incorrect e.pageX|pageY in iOS \r\n\t\t\t\t//2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Android\r\n\t\t\t\t//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\r\n\r\n\t\t\t\t// see if it has already been corrected\r\n\t\t\t\tvar event = originalEvent.corrected;\r\n\t\t\t\tif(!event){\r\n\t\t\t\t\tvar type = originalEvent.type;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdelete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable\r\n\t\t\t\t\t}catch(e){} \r\n\t\t\t\t\tif(originalEvent.type){\r\n\t\t\t\t\t\t// Deleting the property of the original event did not work (this is the case of\r\n\t\t\t\t\t\t// browsers such as older Safari iOS), hence fallback:\r\n\t\t\t\t\t\tif(has(\"touch-can-modify-event-delegate\")){\r\n\t\t\t\t\t\t\t// If deleting properties of delegated event works, use event delegation:\r\n\t\t\t\t\t\t\tEventDelegate.prototype = originalEvent;\r\n\t\t\t\t\t\t\tevent = new EventDelegate;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// Otherwise last fallback: other browsers, such as mobile Firefox, do not like\r\n\t\t\t\t\t\t\t// delegated properties, so we have to copy\r\n\t\t\t\t\t\t\tevent = {};\r\n\t\t\t\t\t\t\tfor(var name in originalEvent){\r\n\t\t\t\t\t\t\t\tevent[name] = originalEvent[name];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// have to delegate methods to make them work\r\n\t\t\t\t\t\tevent.preventDefault = function(){\r\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tevent.stopPropagation = function(){\r\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// deletion worked, use property as is\r\n\t\t\t\t\t\tevent = originalEvent;\r\n\t\t\t\t\t\tevent.type = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toriginalEvent.corrected = event;\r\n\t\t\t\t\tif(type == 'resize'){\r\n\t\t\t\t\t\tif(windowOrientation == window.orientation){ \r\n\t\t\t\t\t\t\treturn null;//double tap causes an unexpected 'resize' in Android\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\twindowOrientation = window.orientation;\r\n\t\t\t\t\t\tevent.type = \"orientationchange\"; \r\n\t\t\t\t\t\treturn listener.call(this, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// We use the original event and augment, rather than doing an expensive mixin operation\r\n\t\t\t\t\tif(!(\"rotation\" in event)){ // test to see if it has rotation\r\n\t\t\t\t\t\tevent.rotation = 0; \r\n\t\t\t\t\t\tevent.scale = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\r\n\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\r\n\t\t\t\t\tfor(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here\r\n\t\t\t\t\t\tdelete event[i]; // delete it first to make it mutable\r\n\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn listener.call(this, event); \r\n\t\t\t}; \r\n\t\t}; \r\n\t}\r\n\treturn on;\r\n});\r\n"]}