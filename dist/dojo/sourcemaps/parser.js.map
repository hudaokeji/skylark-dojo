{"version":3,"sources":["parser.js"],"names":["define","require","dojo","dlang","darray","config","dom","dwindow","_Url","aspect","all","dates","Deferred","has","query","don","ready","myEval","text","eval","Date","extendCnt","getNameMap","ctor","map","_nameCaseMap","proto","prototype","_extendCnt","name","charAt","toLowerCase","after","_ctorMap","getCtor","types","contextRequire","ts","join","mixins","i","l","length","t","getObject","indexOf","shift","createSubclass","extend","apply","parser","_clearCache","_functionFromScript","script","attrData","preamble","suffix","argsStr","getAttribute","withStr","fnArgs","split","forEach","part","Function","innerHTML","instantiate","nodes","mixin","options","dojoType","scope","_scopeName","dataDojoType","dataDojoMixins","list","node","type","mixinsValue","concat","push","this","_instantiate","returnPromise","thelist","obj","Error","construct","scripts","inherited","onConstruct","_started","noStart","instance","startup","then","attributes","params","defaults","filter","a","specified","attrs","test","nodeName","cloneNode","outerHTML","replace","lcName","value","getAttributeNode","hash","item","jsname","extra","funcAttrs","dojoAttachPoint","dojoAttachEvent","className","style","cssText","Number","NaN","search","pVal","fromISOString","baseUrl","j","lcfname","removeAttribute","call","propsThis","e","toString","_noScript","aspects","calls","watches","ons","removeChild","event","prop","method","advice","scriptType","nf","func","markupFactory","onInstantiate","setObject","hitch","watch","scan","root","mids","midsHash","dataDojoTextDir","firstChild","findAncestorAttr","attr","parentNode","key","dir","lang","textDir","scriptsOnly","parent","getEffective","grandparent","nodeType","nextSibling","current","childScripts","stopParser","d","console","warn","resolve","widget","instantiateChildren","promise","_require","vars","arguments","_scanAmd","deferred","self","parse","rootNode","isObject","byId","body","template","instances","p","parsedNodes","_instances","otherwise","error","parseOnLoad"],"mappings":"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","file":"../parser.js","sourcesContent":["define([\r\n\t\"require\", \"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/config\", \"./dom\", \"./_base/window\",\r\n\t\t\"./_base/url\", \"./aspect\", \"./promise/all\", \"./date/stamp\", \"./Deferred\", \"./has\", \"./query\", \"./on\", \"./ready\"\r\n], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){\r\n\r\n\t// module:\r\n\t//\t\tdojo/parser\r\n\r\n\tnew Date(\"X\"); // workaround for #11279, new Date(\"\") == NaN\r\n\r\n\t// data-dojo-props etc. is not restricted to JSON, it can be any javascript\r\n\tfunction myEval(text){\r\n\t\treturn eval(\"(\" + text + \")\");\r\n\t}\r\n\r\n\t// Widgets like BorderContainer add properties to _Widget via dojo.extend().\r\n\t// If BorderContainer is loaded after _Widget's parameter list has been cached,\r\n\t// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).\r\n\tvar extendCnt = 0;\r\n\taspect.after(dlang, \"extend\", function(){\r\n\t\textendCnt++;\r\n\t}, true);\r\n\r\n\tfunction getNameMap(ctor){\r\n\t\t// summary:\r\n\t\t//\t\tReturns map from lowercase name to attribute name in class, ex: {onclick: \"onClick\"}\r\n\t\tvar map = ctor._nameCaseMap, proto = ctor.prototype;\r\n\r\n\t\t// Create the map if it's undefined.\r\n\t\t// Refresh the map if a superclass was possibly extended with new methods since the map was created.\r\n\t\tif(!map || map._extendCnt < extendCnt){\r\n\t\t\tmap = ctor._nameCaseMap = {};\r\n\t\t\tfor(var name in proto){\r\n\t\t\t\tif(name.charAt(0) === \"_\"){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\t// skip internal properties\r\n\t\t\t\tmap[name.toLowerCase()] = name;\r\n\t\t\t}\r\n\t\t\tmap._extendCnt = extendCnt;\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\t// Map from widget name or list of widget names(ex: \"dijit/form/Button,acme/MyMixin\") to a constructor.\r\n\tvar _ctorMap = {};\r\n\r\n\tfunction getCtor(/*String[]*/ types, /*Function?*/ contextRequire){\r\n\t\t// summary:\r\n\t\t//\t\tRetrieves a constructor.  If the types array contains more than one class/MID then the\r\n\t\t//\t\tsubsequent classes will be mixed into the first class and a unique constructor will be\r\n\t\t//\t\treturned for that array.\r\n\r\n\t\tvar ts = types.join();\r\n\t\tif(!_ctorMap[ts]){\r\n\t\t\tvar mixins = [];\r\n\t\t\tfor(var i = 0, l = types.length; i < l; i++){\r\n\t\t\t\tvar t = types[i];\r\n\t\t\t\t// TODO: Consider swapping getObject and require in the future\r\n\t\t\t\tmixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&\r\n\t\t\t\t\t(contextRequire ? contextRequire(t) : require(t)))));\r\n\t\t\t}\r\n\t\t\tvar ctor = mixins.shift();\r\n\t\t\t_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;\r\n\t\t}\r\n\r\n\t\treturn _ctorMap[ts];\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\t// summary:\r\n\t\t//\t\tThe Dom/Widget parsing package\r\n\r\n\t\t_clearCache: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClear cached data.   Used mainly for benchmarking.\r\n\t\t\textendCnt++;\r\n\t\t\t_ctorMap = {};\r\n\t\t},\r\n\r\n\t\t_functionFromScript: function(script, attrData){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvert a `<script type=\"dojo/method\" args=\"a, b, c\"> ... </script>`\r\n\t\t\t//\t\tinto a function\r\n\t\t\t// script: DOMNode\r\n\t\t\t//\t\tThe `<script>` DOMNode\r\n\t\t\t// attrData: String\r\n\t\t\t//\t\tFor HTML5 compliance, searches for attrData + \"args\" (typically\r\n\t\t\t//\t\t\"data-dojo-args\") instead of \"args\"\r\n\t\t\tvar preamble = \"\",\r\n\t\t\t\tsuffix = \"\",\r\n\t\t\t\targsStr = (script.getAttribute(attrData + \"args\") || script.getAttribute(\"args\")),\r\n\t\t\t\twithStr = script.getAttribute(\"with\");\r\n\r\n\t\t\t// Convert any arguments supplied in script tag into an array to be passed to the\r\n\t\t\tvar fnArgs = (argsStr || \"\").split(/\\s*,\\s*/);\r\n\r\n\t\t\tif(withStr && withStr.length){\r\n\t\t\t\tdarray.forEach(withStr.split(/\\s*,\\s*/), function(part){\r\n\t\t\t\t\tpreamble += \"with(\" + part + \"){\";\r\n\t\t\t\t\tsuffix += \"}\";\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn new Function(fnArgs, preamble + script.innerHTML + suffix);\r\n\t\t},\r\n\r\n\t\tinstantiate: function(nodes, mixin, options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTakes array of nodes, and turns them into class instances and\r\n\t\t\t//\t\tpotentially calls a startup method to allow them to connect with\r\n\t\t\t//\t\tany children.\r\n\t\t\t// nodes: Array\r\n\t\t\t//\t\tArray of DOM nodes\r\n\t\t\t// mixin: Object?\r\n\t\t\t//\t\tAn object that will be mixed in with each node in the array.\r\n\t\t\t//\t\tValues in the mixin will override values in the node, if they\r\n\t\t\t//\t\texist.\r\n\t\t\t// options: Object?\r\n\t\t\t//\t\tAn object used to hold kwArgs for instantiation.\r\n\t\t\t//\t\tSee parse.options argument for details.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tArray of instances.\r\n\r\n\t\t\tmixin = mixin || {};\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tvar dojoType = (options.scope || dojo._scopeName) + \"Type\", // typically \"dojoType\"\r\n\t\t\t\tattrData = \"data-\" + (options.scope || dojo._scopeName) + \"-\", // typically \"data-dojo-\"\r\n\t\t\t\tdataDojoType = attrData + \"type\", // typically \"data-dojo-type\"\r\n\t\t\t\tdataDojoMixins = attrData + \"mixins\";\t\t\t\t\t// typically \"data-dojo-mixins\"\r\n\r\n\t\t\tvar list = [];\r\n\t\t\tdarray.forEach(nodes, function(node){\r\n\t\t\t\tvar type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);\r\n\t\t\t\tif(type){\r\n\t\t\t\t\tvar mixinsValue = node.getAttribute(dataDojoMixins),\r\n\t\t\t\t\t\ttypes = mixinsValue ? [type].concat(mixinsValue.split(/\\s*,\\s*/)) : [type];\r\n\r\n\t\t\t\t\tlist.push({\r\n\t\t\t\t\t\tnode: node,\r\n\t\t\t\t\t\ttypes: types\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Instantiate the nodes and return the list of instances.\r\n\t\t\treturn this._instantiate(list, mixin, options);\r\n\t\t},\r\n\r\n\t\t_instantiate: function(nodes, mixin, options, returnPromise){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTakes array of objects representing nodes, and turns them into class instances and\r\n\t\t\t//\t\tpotentially calls a startup method to allow them to connect with\r\n\t\t\t//\t\tany children.\r\n\t\t\t// nodes: Array\r\n\t\t\t//\t\tArray of objects like\r\n\t\t\t//\t|\t\t{\r\n\t\t\t//\t|\t\t\tctor: Function (may be null)\r\n\t\t\t//\t|\t\t\ttypes: [\"dijit/form/Button\", \"acme/MyMixin\"] (used if ctor not specified)\r\n\t\t\t//\t|\t\t\tnode: DOMNode,\r\n\t\t\t//\t|\t\t\tscripts: [ ... ],\t// array of <script type=\"dojo/...\"> children of node\r\n\t\t\t//\t|\t\t\tinherited: { ... }\t// settings inherited from ancestors like dir, theme, etc.\r\n\t\t\t//\t|\t\t}\r\n\t\t\t// mixin: Object\r\n\t\t\t//\t\tAn object that will be mixed in with each node in the array.\r\n\t\t\t//\t\tValues in the mixin will override values in the node, if they\r\n\t\t\t//\t\texist.\r\n\t\t\t// options: Object\r\n\t\t\t//\t\tAn options object used to hold kwArgs for instantiation.\r\n\t\t\t//\t\tSee parse.options argument for details.\r\n\t\t\t// returnPromise: Boolean\r\n\t\t\t//\t\tReturn a Promise rather than the instance; supports asynchronous widget creation.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tArray of instances, or if returnPromise is true, a promise for array of instances\r\n\t\t\t//\t\tthat resolves when instances have finished initializing.\r\n\r\n\t\t\t// Call widget constructors.   Some may be asynchronous and return promises.\r\n\t\t\tvar thelist = darray.map(nodes, function(obj){\r\n\t\t\t\tvar ctor = obj.ctor || getCtor(obj.types, options.contextRequire);\r\n\t\t\t\t// If we still haven't resolved a ctor, it is fatal now\r\n\t\t\t\tif(!ctor){\r\n\t\t\t\t\tthrow new Error(\"Unable to resolve constructor for: '\" + obj.types.join() + \"'\");\r\n\t\t\t\t}\r\n\t\t\t\treturn this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);\r\n\t\t\t}, this);\r\n\r\n\t\t\t// After all widget construction finishes, call startup on each top level instance if it makes sense (as for\r\n\t\t\t// widgets).  Parent widgets will recursively call startup on their (non-top level) children\r\n\t\t\tfunction onConstruct(thelist){\r\n\t\t\t\tif(!mixin._started && !options.noStart){\r\n\t\t\t\t\tdarray.forEach(thelist, function(instance){\r\n\t\t\t\t\t\tif(typeof instance.startup === \"function\" && !instance._started){\r\n\t\t\t\t\t\t\tinstance.startup();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn thelist;\r\n\t\t\t}\r\n\r\n\t\t\tif(returnPromise){\r\n\t\t\t\treturn all(thelist).then(onConstruct);\r\n\t\t\t}else{\r\n\t\t\t\t// Back-compat path, remove for 2.0\r\n\t\t\t\treturn onConstruct(thelist);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tconstruct: function(ctor, node, mixin, options, scripts, inherited){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls new ctor(params, node), where params is the hash of parameters specified on the node,\r\n\t\t\t//\t\texcluding data-dojo-type and data-dojo-mixins.   Does not call startup().\r\n\t\t\t// ctor: Function\r\n\t\t\t//\t\tWidget constructor.\r\n\t\t\t// node: DOMNode\r\n\t\t\t//\t\tThis node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.\r\n\t\t\t// mixin: Object?\r\n\t\t\t//\t\tAttributes in this object will be passed as parameters to ctor,\r\n\t\t\t//\t\toverriding attributes specified on the node.\r\n\t\t\t// options: Object?\r\n\t\t\t//\t\tAn options object used to hold kwArgs for instantiation.   See parse.options argument for details.\r\n\t\t\t// scripts: DomNode[]?\r\n\t\t\t//\t\tArray of `<script type=\"dojo/*\">` DOMNodes.  If not specified, will search for `<script>` tags inside node.\r\n\t\t\t// inherited: Object?\r\n\t\t\t//\t\tSettings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tInstance or Promise for the instance, if markupFactory() itself returned a promise\r\n\r\n\t\t\tvar proto = ctor && ctor.prototype;\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\t// Setup hash to hold parameter settings for this widget.\tStart with the parameter\r\n\t\t\t// settings inherited from ancestors (\"dir\" and \"lang\").\r\n\t\t\t// Inherited setting may later be overridden by explicit settings on node itself.\r\n\t\t\tvar params = {};\r\n\r\n\t\t\tif(options.defaults){\r\n\t\t\t\t// settings for the document itself (or whatever subtree is being parsed)\r\n\t\t\t\tdlang.mixin(params, options.defaults);\r\n\t\t\t}\r\n\t\t\tif(inherited){\r\n\t\t\t\t// settings from dir=rtl or lang=... on a node above this node\r\n\t\t\t\tdlang.mixin(params, inherited);\r\n\t\t\t}\r\n\r\n\t\t\t// Get list of attributes explicitly listed in the markup\r\n\t\t\tvar attributes;\r\n\t\t\tif(has(\"dom-attributes-explicit\")){\r\n\t\t\t\t// Standard path to get list of user specified attributes\r\n\t\t\t\tattributes = node.attributes;\r\n\t\t\t}else if(has(\"dom-attributes-specified-flag\")){\r\n\t\t\t\t// Special processing needed for IE8, to skip a few faux values in attributes[]\r\n\t\t\t\tattributes = darray.filter(node.attributes, function(a){\r\n\t\t\t\t\treturn a.specified;\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\t// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes\r\n\t\t\t\tvar clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),\r\n\t\t\t\t\tattrs = clone.outerHTML.replace(/=[^\\s\"']+|=\"[^\"]*\"|='[^']*'/g, \"\").replace(/^\\s*<[a-zA-Z0-9]*\\s*/, \"\").replace(/\\s*>.*$/, \"\");\r\n\r\n\t\t\t\tattributes = darray.map(attrs.split(/\\s+/), function(name){\r\n\t\t\t\t\tvar lcName = name.toLowerCase();\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\t// getAttribute() doesn't work for button.value, returns innerHTML of button.\r\n\t\t\t\t\t\t// but getAttributeNode().value doesn't work for the form.encType or li.value\r\n\t\t\t\t\t\tvalue: (node.nodeName == \"LI\" && name == \"value\") || lcName == \"enctype\" ?\r\n\t\t\t\t\t\t\tnode.getAttribute(lcName) : node.getAttributeNode(lcName).value\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)\r\n\t\t\t// TODO: remove scope for 2.0\r\n\t\t\tvar scope = options.scope || dojo._scopeName,\r\n\t\t\t\tattrData = \"data-\" + scope + \"-\", // typically \"data-dojo-\"\r\n\t\t\t\thash = {};\r\n\t\t\tif(scope !== \"dojo\"){\r\n\t\t\t\thash[attrData + \"props\"] = \"data-dojo-props\";\r\n\t\t\t\thash[attrData + \"type\"] = \"data-dojo-type\";\r\n\t\t\t\thash[attrData + \"mixins\"] = \"data-dojo-mixins\";\r\n\t\t\t\thash[scope + \"type\"] = \"dojoType\";\r\n\t\t\t\thash[attrData + \"id\"] = \"data-dojo-id\";\r\n\t\t\t}\r\n\r\n\t\t\t// Read in attributes and process them, including data-dojo-props, data-dojo-type,\r\n\t\t\t// dojoAttachPoint, etc., as well as normal foo=bar attributes.\r\n\t\t\tvar i = 0, item, funcAttrs = [], jsname, extra;\r\n\t\t\twhile(item = attributes[i++]){\r\n\t\t\t\tvar name = item.name,\r\n\t\t\t\t\tlcName = name.toLowerCase(),\r\n\t\t\t\t\tvalue = item.value;\r\n\r\n\t\t\t\tswitch(hash[lcName] || lcName){\r\n\t\t\t\t// Already processed, just ignore\r\n\t\t\t\tcase \"data-dojo-type\":\r\n\t\t\t\tcase \"dojotype\":\r\n\t\t\t\tcase \"data-dojo-mixins\":\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings\r\n\t\t\t\tcase \"data-dojo-props\":\r\n\t\t\t\t\textra = value;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// data-dojo-id or jsId. TODO: drop jsId in 2.0\r\n\t\t\t\tcase \"data-dojo-id\":\r\n\t\t\t\tcase \"jsid\":\r\n\t\t\t\t\tjsname = value;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// For the benefit of _Templated\r\n\t\t\t\tcase \"data-dojo-attach-point\":\r\n\t\t\t\tcase \"dojoattachpoint\":\r\n\t\t\t\t\tparams.dojoAttachPoint = value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"data-dojo-attach-event\":\r\n\t\t\t\tcase \"dojoattachevent\":\r\n\t\t\t\t\tparams.dojoAttachEvent = value;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Special parameter handling needed for IE\r\n\t\t\t\tcase \"class\":\r\n\t\t\t\t\tparams[\"class\"] = node.className;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"style\":\r\n\t\t\t\t\tparams[\"style\"] = node.style && node.style.cssText;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// Normal attribute, ex: value=\"123\"\r\n\r\n\t\t\t\t\t// Find attribute in widget corresponding to specified name.\r\n\t\t\t\t\t// May involve case conversion, ex: onclick --> onClick\r\n\t\t\t\t\tif(!(name in proto)){\r\n\t\t\t\t\t\tvar map = getNameMap(ctor);\r\n\t\t\t\t\t\tname = map[lcName] || name;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Set params[name] to value, doing type conversion\r\n\t\t\t\t\tif(name in proto){\r\n\t\t\t\t\t\tswitch(typeof proto[name]){\r\n\t\t\t\t\t\tcase \"string\":\r\n\t\t\t\t\t\t\tparams[name] = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"number\":\r\n\t\t\t\t\t\t\tparams[name] = value.length ? Number(value) : NaN;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\t\t\t// for checked/disabled value might be \"\" or \"checked\".\t interpret as true.\r\n\t\t\t\t\t\t\tparams[name] = value.toLowerCase() != \"false\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"function\":\r\n\t\t\t\t\t\t\tif(value === \"\" || value.search(/[^\\w\\.]+/i) != -1){\r\n\t\t\t\t\t\t\t\t// The user has specified some text for a function like \"return x+5\"\r\n\t\t\t\t\t\t\t\tparams[name] = new Function(value);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t// The user has specified the name of a global function like \"myOnClick\"\r\n\t\t\t\t\t\t\t\t// or a single word function \"return\"\r\n\t\t\t\t\t\t\t\tparams[name] = dlang.getObject(value, false) || new Function(value);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfuncAttrs.push(name);\t// prevent \"double connect\", see #15026\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tvar pVal = proto[name];\r\n\t\t\t\t\t\t\tparams[name] =\r\n\t\t\t\t\t\t\t\t(pVal && \"length\" in pVal) ? (value ? value.split(/\\s*,\\s*/) : []) :\t// array\r\n\t\t\t\t\t\t\t\t\t(pVal instanceof Date) ?\r\n\t\t\t\t\t\t\t\t\t\t(value == \"\" ? new Date(\"\") :\t// the NaN of dates\r\n\t\t\t\t\t\t\t\t\t\tvalue == \"now\" ? new Date() :\t// current date\r\n\t\t\t\t\t\t\t\t\t\tdates.fromISOString(value)) :\r\n\t\t\t\t\t\t\t\t(pVal instanceof _Url) ? (dojo.baseUrl + value) :\r\n\t\t\t\t\t\t\t\tmyEval(value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tparams[name] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove function attributes from DOMNode to prevent \"double connect\" problem, see #15026.\r\n\t\t\t// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).\r\n\t\t\tfor(var j = 0; j < funcAttrs.length; j++){\r\n\t\t\t\tvar lcfname = funcAttrs[j].toLowerCase();\r\n\t\t\t\tnode.removeAttribute(lcfname);\r\n\t\t\t\tnode[lcfname] = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Mix things found in data-dojo-props into the params, overriding any direct settings\r\n\t\t\tif(extra){\r\n\t\t\t\ttry{\r\n\t\t\t\t\textra = myEval.call(options.propsThis, \"{\" + extra + \"}\");\r\n\t\t\t\t\tdlang.mixin(params, extra);\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\t// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?\r\n\t\t\t\t\tthrow new Error(e.toString() + \" in data-dojo-props='\" + extra + \"'\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Any parameters specified in \"mixin\" override everything else.\r\n\t\t\tdlang.mixin(params, mixin);\r\n\r\n\t\t\t// Get <script> nodes associated with this widget, if they weren't specified explicitly\r\n\t\t\tif(!scripts){\r\n\t\t\t\tscripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query(\"> script[type^='dojo/']\", node));\r\n\t\t\t}\r\n\r\n\t\t\t// Process <script type=\"dojo/*\"> script tags\r\n\t\t\t// <script type=\"dojo/method\" data-dojo-event=\"foo\"> tags are added to params, and passed to\r\n\t\t\t// the widget on instantiation.\r\n\t\t\t// <script type=\"dojo/method\"> tags (with no event) are executed after instantiation\r\n\t\t\t// <script type=\"dojo/connect\" data-dojo-event=\"foo\"> tags are dojo.connected after instantiation,\r\n\t\t\t// and likewise with <script type=\"dojo/aspect\" data-dojo-method=\"foo\">\r\n\t\t\t// <script type=\"dojo/watch\" data-dojo-prop=\"foo\"> tags are dojo.watch after instantiation\r\n\t\t\t// <script type=\"dojo/on\" data-dojo-event=\"foo\"> tags are dojo.on after instantiation\r\n\t\t\t// note: dojo/* script tags cannot exist in self closing widgets, like <input />\r\n\t\t\tvar aspects = [],\t// aspects to connect after instantiation\r\n\t\t\t\tcalls = [],\t\t// functions to call after instantiation\r\n\t\t\t\twatches = [],  // functions to watch after instantiation\r\n\t\t\t\tons = []; // functions to on after instantiation\r\n\r\n\t\t\tif(scripts){\r\n\t\t\t\tfor(i = 0; i < scripts.length; i++){\r\n\t\t\t\t\tvar script = scripts[i];\r\n\t\t\t\t\tnode.removeChild(script);\r\n\t\t\t\t\t// FIXME: drop event=\"\" support in 2.0. use data-dojo-event=\"\" instead\r\n\t\t\t\t\tvar event = (script.getAttribute(attrData + \"event\") || script.getAttribute(\"event\")),\r\n\t\t\t\t\t\tprop = script.getAttribute(attrData + \"prop\"),\r\n\t\t\t\t\t\tmethod = script.getAttribute(attrData + \"method\"),\r\n\t\t\t\t\t\tadvice = script.getAttribute(attrData + \"advice\"),\r\n\t\t\t\t\t\tscriptType = script.getAttribute(\"type\"),\r\n\t\t\t\t\t\tnf = this._functionFromScript(script, attrData);\r\n\t\t\t\t\tif(event){\r\n\t\t\t\t\t\tif(scriptType == \"dojo/connect\"){\r\n\t\t\t\t\t\t\taspects.push({ method: event, func: nf });\r\n\t\t\t\t\t\t}else if(scriptType == \"dojo/on\"){\r\n\t\t\t\t\t\t\tons.push({ event: event, func: nf });\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// <script type=\"dojo/method\" data-dojo-event=\"foo\">\r\n\t\t\t\t\t\t\t// TODO for 2.0: use data-dojo-method=\"foo\" instead (also affects dijit/Declaration)\r\n\t\t\t\t\t\t\tparams[event] = nf;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(scriptType == \"dojo/aspect\"){\r\n\t\t\t\t\t\taspects.push({ method: method, advice: advice, func: nf });\r\n\t\t\t\t\t}else if(scriptType == \"dojo/watch\"){\r\n\t\t\t\t\t\twatches.push({ prop: prop, func: nf });\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcalls.push(nf);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// create the instance\r\n\t\t\tvar markupFactory = ctor.markupFactory || proto.markupFactory;\r\n\t\t\tvar instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);\r\n\r\n\t\t\tfunction onInstantiate(instance){\r\n\t\t\t\t// map it to the JS namespace if that makes sense\r\n\t\t\t\tif(jsname){\r\n\t\t\t\t\tdlang.setObject(jsname, instance);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// process connections and startup functions\r\n\t\t\t\tfor(i = 0; i < aspects.length; i++){\r\n\t\t\t\t\taspect[aspects[i].advice || \"after\"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);\r\n\t\t\t\t}\r\n\t\t\t\tfor(i = 0; i < calls.length; i++){\r\n\t\t\t\t\tcalls[i].call(instance);\r\n\t\t\t\t}\r\n\t\t\t\tfor(i = 0; i < watches.length; i++){\r\n\t\t\t\t\tinstance.watch(watches[i].prop, watches[i].func);\r\n\t\t\t\t}\r\n\t\t\t\tfor(i = 0; i < ons.length; i++){\r\n\t\t\t\t\tdon(instance, ons[i].event, ons[i].func);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn instance;\r\n\t\t\t}\r\n\r\n\t\t\tif(instance.then){\r\n\t\t\t\treturn instance.then(onInstantiate);\r\n\t\t\t}else{\r\n\t\t\t\treturn onInstantiate(instance);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tscan: function(root, options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tScan a DOM tree and return an array of objects representing the DOMNodes\r\n\t\t\t//\t\tthat need to be turned into widgets.\r\n\t\t\t// description:\r\n\t\t\t//\t\tSearch specified node (or document root node) recursively for class instances\r\n\t\t\t//\t\tand return an array of objects that represent potential widgets to be\r\n\t\t\t//\t\tinstantiated. Searches for either data-dojo-type=\"MID\" or dojoType=\"MID\" where\r\n\t\t\t//\t\t\"MID\" is a module ID like \"dijit/form/Button\" or a fully qualified Class name\r\n\t\t\t//\t\tlike \"dijit/form/Button\".  If the MID is not currently available, scan will\r\n\t\t\t//\t\tattempt to require() in the module.\r\n\t\t\t//\r\n\t\t\t//\t\tSee parser.parse() for details of markup.\r\n\t\t\t// root: DomNode?\r\n\t\t\t//\t\tA default starting root node from which to start the parsing. Can be\r\n\t\t\t//\t\tomitted, defaulting to the entire document. If omitted, the `options`\r\n\t\t\t//\t\tobject can be passed in this place. If the `options` object has a\r\n\t\t\t//\t\t`rootNode` member, that is used.\r\n\t\t\t// options: Object\r\n\t\t\t//\t\ta kwArgs options object, see parse() for details\r\n\t\t\t//\r\n\t\t\t// returns: Promise\r\n\t\t\t//\t\tA promise that is resolved with the nodes that have been parsed.\r\n\r\n\t\t\tvar list = [], // Output List\r\n\t\t\t\tmids = [], // An array of modules that are not yet loaded\r\n\t\t\t\tmidsHash = {}; // Used to keep the mids array unique\r\n\r\n\t\t\tvar dojoType = (options.scope || dojo._scopeName) + \"Type\", // typically \"dojoType\"\r\n\t\t\t\tattrData = \"data-\" + (options.scope || dojo._scopeName) + \"-\", // typically \"data-dojo-\"\r\n\t\t\t\tdataDojoType = attrData + \"type\", // typically \"data-dojo-type\"\r\n\t\t\t\tdataDojoTextDir = attrData + \"textdir\", // typically \"data-dojo-textdir\"\r\n\t\t\t\tdataDojoMixins = attrData + \"mixins\";\t\t\t\t\t// typically \"data-dojo-mixins\"\r\n\r\n\t\t\t// Info on DOMNode currently being processed\r\n\t\t\tvar node = root.firstChild;\r\n\r\n\t\t\t// Info on parent of DOMNode currently being processed\r\n\t\t\t//\t- inherited: dir, lang, and textDir setting of parent, or inherited by parent\r\n\t\t\t//\t- parent: pointer to identical structure for my parent (or null if no parent)\r\n\t\t\t//\t- scripts: if specified, collects <script type=\"dojo/...\"> type nodes from children\r\n\t\t\tvar inherited = options.inherited;\r\n\t\t\tif(!inherited){\r\n\t\t\t\tfunction findAncestorAttr(node, attr){\r\n\t\t\t\t\treturn (node.getAttribute && node.getAttribute(attr)) ||\r\n\t\t\t\t\t\t(node.parentNode && findAncestorAttr(node.parentNode, attr));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinherited = {\r\n\t\t\t\t\tdir: findAncestorAttr(root, \"dir\"),\r\n\t\t\t\t\tlang: findAncestorAttr(root, \"lang\"),\r\n\t\t\t\t\ttextDir: findAncestorAttr(root, dataDojoTextDir)\r\n\t\t\t\t};\r\n\t\t\t\tfor(var key in inherited){\r\n\t\t\t\t\tif(!inherited[key]){\r\n\t\t\t\t\t\tdelete inherited[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Metadata about parent node\r\n\t\t\tvar parent = {\r\n\t\t\t\tinherited: inherited\r\n\t\t\t};\r\n\r\n\t\t\t// For collecting <script type=\"dojo/...\"> type nodes (when null, we don't need to collect)\r\n\t\t\tvar scripts;\r\n\r\n\t\t\t// when true, only look for <script type=\"dojo/...\"> tags, and don't recurse to children\r\n\t\t\tvar scriptsOnly;\r\n\r\n\t\t\tfunction getEffective(parent){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tGet effective dir, lang, textDir settings for specified obj\r\n\t\t\t\t//\t\t(matching \"parent\" object structure above), and do caching.\r\n\t\t\t\t//\t\tTake care not to return null entries.\r\n\t\t\t\tif(!parent.inherited){\r\n\t\t\t\t\tparent.inherited = {};\r\n\t\t\t\t\tvar node = parent.node,\r\n\t\t\t\t\t\tgrandparent = getEffective(parent.parent);\r\n\t\t\t\t\tvar inherited = {\r\n\t\t\t\t\t\tdir: node.getAttribute(\"dir\") || grandparent.dir,\r\n\t\t\t\t\t\tlang: node.getAttribute(\"lang\") || grandparent.lang,\r\n\t\t\t\t\t\ttextDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfor(var key in inherited){\r\n\t\t\t\t\t\tif(inherited[key]){\r\n\t\t\t\t\t\t\tparent.inherited[key] = inherited[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn parent.inherited;\r\n\t\t\t}\r\n\r\n\t\t\t// DFS on DOM tree, collecting nodes with data-dojo-type specified.\r\n\t\t\twhile(true){\r\n\t\t\t\tif(!node){\r\n\t\t\t\t\t// Finished this level, continue to parent's next sibling\r\n\t\t\t\t\tif(!parent || !parent.node){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = parent.node.nextSibling;\r\n\t\t\t\t\tscriptsOnly = false;\r\n\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t\tscripts = parent.scripts;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(node.nodeType != 1){\r\n\t\t\t\t\t// Text or comment node, skip to next sibling\r\n\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(scripts && node.nodeName.toLowerCase() == \"script\"){\r\n\t\t\t\t\t// Save <script type=\"dojo/...\"> for parent, then continue to next sibling\r\n\t\t\t\t\ttype = node.getAttribute(\"type\");\r\n\t\t\t\t\tif(type && /^dojo\\/\\w/i.test(type)){\r\n\t\t\t\t\t\tscripts.push(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(scriptsOnly){\r\n\t\t\t\t\t// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't\r\n\t\t\t\t\t// continue further analysis of the node and will continue to the next sibling\r\n\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check for data-dojo-type attribute, fallback to backward compatible dojoType\r\n\t\t\t\t// TODO: Remove dojoType in 2.0\r\n\t\t\t\tvar type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);\r\n\r\n\t\t\t\t// Short circuit for leaf nodes containing nothing [but text]\r\n\t\t\t\tvar firstChild = node.firstChild;\r\n\t\t\t\tif(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){\r\n\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Meta data about current node\r\n\t\t\t\tvar current;\r\n\r\n\t\t\t\tvar ctor = null;\r\n\t\t\t\tif(type){\r\n\t\t\t\t\t// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.\r\n\t\t\t\t\tvar mixinsValue = node.getAttribute(dataDojoMixins),\r\n\t\t\t\t\t\ttypes = mixinsValue ? [type].concat(mixinsValue.split(/\\s*,\\s*/)) : [type];\r\n\r\n\t\t\t\t\t// Note: won't find classes declared via dojo/Declaration or any modules that haven't been\r\n\t\t\t\t\t// loaded yet so use try/catch to avoid throw from require()\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tctor = getCtor(types, options.contextRequire);\r\n\t\t\t\t\t}catch(e){}\r\n\r\n\t\t\t\t\t// If the constructor was not found, check to see if it has modules that can be loaded\r\n\t\t\t\t\tif(!ctor){\r\n\t\t\t\t\t\tdarray.forEach(types, function(t){\r\n\t\t\t\t\t\t\tif(~t.indexOf('/') && !midsHash[t]){\r\n\t\t\t\t\t\t\t\t// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.\r\n\t\t\t\t\t\t\t\tmidsHash[t] = true;\r\n\t\t\t\t\t\t\t\tmids[mids.length] = t;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children\r\n\r\n\t\t\t\t\t// Setup meta data about this widget node, and save it to list of nodes to instantiate\r\n\t\t\t\t\tcurrent = {\r\n\t\t\t\t\t\ttypes: types,\r\n\t\t\t\t\t\tctor: ctor,\r\n\t\t\t\t\t\tparent: parent,\r\n\t\t\t\t\t\tnode: node,\r\n\t\t\t\t\t\tscripts: childScripts\r\n\t\t\t\t\t};\r\n\t\t\t\t\tcurrent.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited\r\n\t\t\t\t\tlist.push(current);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// Meta data about this non-widget node\r\n\t\t\t\t\tcurrent = {\r\n\t\t\t\t\t\tnode: node,\r\n\t\t\t\t\t\tscripts: scripts,\r\n\t\t\t\t\t\tparent: parent\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse, collecting <script type=\"dojo/...\"> children, and also looking for\r\n\t\t\t\t// descendant nodes with dojoType specified (unless the widget has the stopParser flag).\r\n\t\t\t\t// When finished with children, go to my next sibling.\r\n\t\t\t\tscripts = childScripts;\r\n\t\t\t\tscriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));\r\n\t\t\t\tparent = current;\r\n\t\t\t\tnode = firstChild;\r\n\t\t\t}\r\n\r\n\t\t\tvar d = new Deferred();\r\n\r\n\t\t\t// If there are modules to load then require them in\r\n\t\t\tif(mids.length){\r\n\t\t\t\t// Warn that there are modules being auto-required\r\n\t\t\t\tif(has(\"dojo-debug-messages\")){\r\n\t\t\t\t\tconsole.warn(\"WARNING: Modules being Auto-Required: \" + mids.join(\", \"));\r\n\t\t\t\t}\r\n\t\t\t\tvar r = options.contextRequire || require;\r\n\t\t\t\tr(mids, function(){\r\n\t\t\t\t\t// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't\r\n\t\t\t\t\t// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to\r\n\t\t\t\t\t// auto-require of a module like ContentPane.   Assumes list is in DFS order.\r\n\t\t\t\t\td.resolve(darray.filter(list, function(widget){\r\n\t\t\t\t\t\tif(!widget.ctor){\r\n\t\t\t\t\t\t\t// Attempt to find the constructor again.   Still won't find classes defined via\r\n\t\t\t\t\t\t\t// dijit/Declaration so need to try/catch.\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\twidget.ctor = getCtor(widget.types, options.contextRequire);\r\n\t\t\t\t\t\t\t}catch(e){}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Get the parent widget\r\n\t\t\t\t\t\tvar parent = widget.parent;\r\n\t\t\t\t\t\twhile(parent && !parent.types){\r\n\t\t\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Return false if this node should be skipped due to stopParser on an ancestor.\r\n\t\t\t\t\t\t// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before\r\n\t\t\t\t\t\t// trying to compute widget.instantiate.\r\n\t\t\t\t\t\tvar proto = widget.ctor && widget.ctor.prototype;\r\n\t\t\t\t\t\twidget.instantiateChildren = !(proto && proto.stopParser && !(options.template));\r\n\t\t\t\t\t\twidget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);\r\n\t\t\t\t\t\treturn widget.instantiate;\r\n\t\t\t\t\t}));\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\t// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for\r\n\t\t\t\t// efficiency, to avoid running the require() and the callback code above.\r\n\t\t\t\td.resolve(list);\r\n\t\t\t}\r\n\r\n\t\t\t// Return the promise\r\n\t\t\treturn d.promise;\r\n\t\t},\r\n\r\n\t\t_require: function(/*DOMNode*/ script, /*Object?*/ options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper for _scanAMD().  Takes a `<script type=dojo/require>bar: \"acme/bar\", ...</script>` node,\r\n\t\t\t//\t\tcalls require() to load the specified modules and (asynchronously) assign them to the specified global\r\n\t\t\t//\t\tvariables, and returns a Promise for when that operation completes.\r\n\t\t\t//\r\n\t\t\t//\t\tIn the example above, it is effectively doing a require([\"acme/bar\", ...], function(a){ bar = a; }).\r\n\r\n\t\t\tvar hash = myEval(\"{\" + script.innerHTML + \"}\"), // can't use dojo/json::parse() because maybe no quotes\r\n\t\t\t\tvars = [],\r\n\t\t\t\tmids = [],\r\n\t\t\t\td = new Deferred();\r\n\r\n\t\t\tvar contextRequire = (options && options.contextRequire) || require;\r\n\r\n\t\t\tfor(var name in hash){\r\n\t\t\t\tvars.push(name);\r\n\t\t\t\tmids.push(hash[name]);\r\n\t\t\t}\r\n\r\n\t\t\tcontextRequire(mids, function(){\r\n\t\t\t\tfor(var i = 0; i < vars.length; i++){\r\n\t\t\t\t\tdlang.setObject(vars[i], arguments[i]);\r\n\t\t\t\t}\r\n\t\t\t\td.resolve(arguments);\r\n\t\t\t});\r\n\r\n\t\t\treturn d.promise;\r\n\t\t},\r\n\r\n\t\t_scanAmd: function(root, options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tScans the DOM for any declarative requires and returns their values.\r\n\t\t\t// description:\r\n\t\t\t//\t\tLooks for `<script type=dojo/require>bar: \"acme/bar\", ...</script>` node, calls require() to load the\r\n\t\t\t//\t\tspecified modules and (asynchronously) assign them to the specified global variables,\r\n\t\t\t//\t\tand returns a Promise for when those operations complete.\r\n\t\t\t// root: DomNode\r\n\t\t\t//\t\tThe node to base the scan from.\r\n\t\t\t// options: Object?\r\n\t\t\t//\t\ta kwArgs options object, see parse() for details\r\n\r\n\t\t\t// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.\r\n\t\t\tvar deferred = new Deferred(),\r\n\t\t\t\tpromise = deferred.promise;\r\n\t\t\tdeferred.resolve(true);\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tquery(\"script[type='dojo/require']\", root).forEach(function(node){\r\n\t\t\t\t// Fire off require() call for specified modules.  Chain this require to fire after\r\n\t\t\t\t// any previous requires complete, so that layers can be loaded before individual module require()'s fire.\r\n\t\t\t\tpromise = promise.then(function(){\r\n\t\t\t\t\treturn self._require(node, options);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Remove from DOM so it isn't seen again\r\n\t\t\t\tnode.parentNode.removeChild(node);\r\n\t\t\t});\r\n\r\n\t\t\treturn promise;\r\n\t\t},\r\n\r\n\t\tparse: function(rootNode, options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tScan the DOM for class instances, and instantiate them.\r\n\t\t\t// description:\r\n\t\t\t//\t\tSearch specified node (or root node) recursively for class instances,\r\n\t\t\t//\t\tand instantiate them. Searches for either data-dojo-type=\"Class\" or\r\n\t\t\t//\t\tdojoType=\"Class\" where \"Class\" is a a fully qualified class name,\r\n\t\t\t//\t\tlike `dijit/form/Button`\r\n\t\t\t//\r\n\t\t\t//\t\tUsing `data-dojo-type`:\r\n\t\t\t//\t\tAttributes using can be mixed into the parameters used to instantiate the\r\n\t\t\t//\t\tClass by using a `data-dojo-props` attribute on the node being converted.\r\n\t\t\t//\t\t`data-dojo-props` should be a string attribute to be converted from JSON.\r\n\t\t\t//\r\n\t\t\t//\t\tUsing `dojoType`:\r\n\t\t\t//\t\tAttributes are read from the original domNode and converted to appropriate\r\n\t\t\t//\t\ttypes by looking up the Class prototype values. This is the default behavior\r\n\t\t\t//\t\tfrom Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will\r\n\t\t\t//\t\tgo away in Dojo 2.0.\r\n\t\t\t// rootNode: DomNode?\r\n\t\t\t//\t\tA default starting root node from which to start the parsing. Can be\r\n\t\t\t//\t\tomitted, defaulting to the entire document. If omitted, the `options`\r\n\t\t\t//\t\tobject can be passed in this place. If the `options` object has a\r\n\t\t\t//\t\t`rootNode` member, that is used.\r\n\t\t\t// options: Object?\r\n\t\t\t//\t\tA hash of options.\r\n\t\t\t//\r\n\t\t\t//\t\t- noStart: Boolean?:\r\n\t\t\t//\t\t\twhen set will prevent the parser from calling .startup()\r\n\t\t\t//\t\t\twhen locating the nodes.\r\n\t\t\t//\t\t- rootNode: DomNode?:\r\n\t\t\t//\t\t\tidentical to the function's `rootNode` argument, though\r\n\t\t\t//\t\t\tallowed to be passed in via this `options object.\r\n\t\t\t//\t\t- template: Boolean:\r\n\t\t\t//\t\t\tIf true, ignores ContentPane's stopParser flag and parses contents inside of\r\n\t\t\t//\t\t\ta ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes\r\n\t\t\t//\t\t\tnested inside the ContentPane to work.\r\n\t\t\t//\t\t- inherited: Object:\r\n\t\t\t//\t\t\tHash possibly containing dir and lang settings to be applied to\r\n\t\t\t//\t\t\tparsed widgets, unless there's another setting on a sub-node that overrides\r\n\t\t\t//\t\t- scope: String:\r\n\t\t\t//\t\t\tRoot for attribute names to search for.   If scopeName is dojo,\r\n\t\t\t//\t\t\twill search for data-dojo-type (or dojoType).   For backwards compatibility\r\n\t\t\t//\t\t\treasons defaults to dojo._scopeName (which is \"dojo\" except when\r\n\t\t\t//\t\t\tmulti-version support is used, when it will be something like dojo16, dojo20, etc.)\r\n\t\t\t//\t\t- propsThis: Object:\r\n\t\t\t//\t\t\tIf specified, \"this\" referenced from data-dojo-props will refer to propsThis.\r\n\t\t\t//\t\t\tIntended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`\r\n\t\t\t//\t\t- contextRequire: Function:\r\n\t\t\t//\t\t\tIf specified, this require is utilised for looking resolving modules instead of the\r\n\t\t\t//\t\t\t`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of\r\n\t\t\t//\t\t\t`dijit._WidgetsInTemplateMixin`.\r\n\t\t\t// returns: Mixed\r\n\t\t\t//\t\tReturns a blended object that is an array of the instantiated objects, but also can include\r\n\t\t\t//\t\ta promise that is resolved with the instantiated objects.  This is done for backwards\r\n\t\t\t//\t\tcompatibility.  If the parser auto-requires modules, it will always behave in a promise\r\n\t\t\t//\t\tfashion and `parser.parse().then(function(instances){...})` should be used.\r\n\t\t\t// example:\r\n\t\t\t//\t\tParse all widgets on a page:\r\n\t\t\t//\t|\t\tparser.parse();\r\n\t\t\t// example:\r\n\t\t\t//\t\tParse all classes within the node with id=\"foo\"\r\n\t\t\t//\t|\t\tparser.parse(dojo.byId('foo'));\r\n\t\t\t// example:\r\n\t\t\t//\t\tParse all classes in a page, but do not call .startup() on any\r\n\t\t\t//\t\tchild\r\n\t\t\t//\t|\t\tparser.parse({ noStart: true })\r\n\t\t\t// example:\r\n\t\t\t//\t\tParse all classes in a node, but do not call .startup()\r\n\t\t\t//\t|\t\tparser.parse(someNode, { noStart:true });\r\n\t\t\t//\t|\t\t// or\r\n\t\t\t//\t|\t\tparser.parse({ noStart:true, rootNode: someNode });\r\n\r\n\t\t\t// determine the root node and options based on the passed arguments.\r\n\t\t\tvar root;\r\n\t\t\tif(!options && rootNode && rootNode.rootNode){\r\n\t\t\t\toptions = rootNode;\r\n\t\t\t\troot = options.rootNode;\r\n\t\t\t}else if(rootNode && dlang.isObject(rootNode) && !(\"nodeType\" in rootNode)){\r\n\t\t\t\toptions = rootNode;\r\n\t\t\t}else{\r\n\t\t\t\troot = rootNode;\r\n\t\t\t}\r\n\t\t\troot = root ? dom.byId(root) : dwindow.body();\r\n\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tvar mixin = options.template ? { template: true } : {},\r\n\t\t\t\tinstances = [],\r\n\t\t\t\tself = this;\r\n\r\n\t\t\t// First scan for any <script type=dojo/require> nodes, and execute.\r\n\t\t\t// Then scan for all nodes with data-dojo-type, and load any unloaded modules.\r\n\t\t\t// Then build the object instances.  Add instances to already existing (but empty) instances[] array,\r\n\t\t\t// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors\r\n\t\t\t// that occur during the parse().\r\n\t\t\tvar p =\r\n\t\t\t\tthis._scanAmd(root, options).then(function(){\r\n\t\t\t\t\treturn self.scan(root, options);\r\n\t\t\t\t}).then(function(parsedNodes){\r\n\t\t\t\t\treturn self._instantiate(parsedNodes, mixin, options, true);\r\n\t\t\t\t}).then(function(_instances){\r\n\t\t\t\t\t// Copy the instances into the instances[] array we declared above, and are accessing as\r\n\t\t\t\t\t// our return value.\r\n\t\t\t\t\treturn instances = instances.concat(_instances);\r\n\t\t\t\t}).otherwise(function(e){\r\n\t\t\t\t\t// TODO Modify to follow better pattern for promise error management when available\r\n\t\t\t\t\tconsole.error(\"dojo/parser::parse() error\", e);\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t});\r\n\r\n\t\t\t// Blend the array with the promise\r\n\t\t\tdlang.mixin(instances, p);\r\n\t\t\treturn instances;\r\n\t\t}\r\n\t};\r\n\r\n\tif(has(\"extend-dojo\")){\r\n\t\tdojo.parser = parser;\r\n\t}\r\n\r\n\t// Register the parser callback. It should be the first callback\r\n\t// after the a11y test.\r\n\tif(config.parseOnLoad){\r\n\t\tready(100, parser, \"parse\");\r\n\t}\r\n\r\n\treturn parser;\r\n});\r\n"]}