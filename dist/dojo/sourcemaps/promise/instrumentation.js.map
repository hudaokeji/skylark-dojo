{"version":3,"sources":["promise/instrumentation.js"],"names":["define","tracer","has","lang","arrayUtil","logError","error","rejection","deferred","stack","split","slice","join","replace","console","reportRejections","handled","add","errors","activeTimeout","unhandledWait","trackUnhandledRejections","some","obj","push","timestamp","Date","getTime","setTimeout","logRejected","now","reportBefore","filter","length","Deferred","usage","on","hitch","args","shift","instrumentRejected","Error","parseInt"],"mappings":";;;;;;;AAAAA,QACC,WACA,SACA,gBACA,kBACE,SAASC,EAAQC,EAAKC,EAAMC,GAG9B,SAASC,EAASC,EAAOC,EAAWC,GACnC,IAAIC,EAAQ,GACTH,GAASA,EAAMG,QACjBA,GAASH,EAAMG,OAEbF,GAAaA,EAAUE,QACzBA,GAAS,+DAAiEF,EAAUE,MAAMC,MAAM,MAAMC,MAAM,GAAGC,KAAK,MAAMC,QAAQ,OAAQ,MAExIL,GAAYA,EAASC,QACvBA,GAAS,mDAAqDD,EAASC,OAExEK,QAAQR,MAAMA,EAAOG,GAGtB,SAASM,EAAiBT,EAAOU,EAAST,EAAWC,GAChDQ,GACHX,EAASC,EAAOC,EAAWC,GAlB7BN,EAAIe,IAAI,oCAAqC,+BAsB7C,IAAIC,KACAC,GAAgB,EAChBC,EAAgB,IACpB,SAASC,EAAyBf,EAAOU,EAAST,EAAWC,GAExDJ,EAAUkB,KAAKJ,EAAQ,SAASK,GACnC,GAAGA,EAAIjB,QAAUA,EAMhB,OAJGU,IAEFO,EAAIP,SAAU,IAER,KAIRE,EAAOM,MACNlB,MAAOA,EACPC,UAAWA,EACXS,QAASA,EACTR,SAAUA,EACViB,WAAW,IAAIC,MAAOC,YAIpBR,IACHA,EAAgBS,WAAWC,EAAaT,IAI1C,SAASS,IACR,IAAIC,GAAM,IAAIJ,MAAOC,UACjBI,EAAeD,EAAMV,EACzBF,EAASd,EAAU4B,OAAOd,EAAQ,SAASK,GAG1C,QAAGA,EAAIE,UAAYM,KACdR,EAAIP,SACPX,EAASkB,EAAIjB,MAAOiB,EAAIhB,UAAWgB,EAAIf,WAEjC,KAMRW,IADED,EAAOe,QACOL,WAAWC,EAAaX,EAAO,GAAGO,UAAYL,EAAgBU,GAMhF,OAAO,SAASI,GAcf,IAAIC,EAAQjC,EAAI,qCAChB,GAAGiC,EAAM,CACRlC,EAAOmC,GAAG,WAAYjC,EAAKkC,MAAMvB,QAAS,MAAO,aACjDb,EAAOmC,GAAG,WAAYjC,EAAKkC,MAAMvB,QAAS,MAAO,aACjDb,EAAOmC,GAAG,WAAYjC,EAAKkC,MAAMvB,QAAS,MAAO,aAEjD,IAAIwB,KAKJ,GAJoB,iBAAVH,IAETA,GADAG,EAAOH,EAAMzB,MAAM,MACN6B,SAED,sBAAVJ,EACFD,EAASM,mBAAqBzB,MACzB,CAAA,GAAa,gCAAVoB,IAAqD,IAAVA,GAA4B,IAAVA,EAIrE,MAAM,IAAIM,MAAM,sCAAwCN,EAAQ,KAHhED,EAASM,mBAAqBnB,EAC9BD,EAAgBsB,SAASJ,EAAK,GAAI,KAAOlB","file":"../../promise/instrumentation.js","sourcesContent":["define([\r\n\t\"./tracer\",\r\n\t\"../has\",\r\n\t\"../_base/lang\",\r\n\t\"../_base/array\"\r\n], function(tracer, has, lang, arrayUtil){\r\n\thas.add(\"config-useDeferredInstrumentation\", \"report-unhandled-rejections\");\r\n\r\n\tfunction logError(error, rejection, deferred){\r\n\t\tvar stack = \"\";\r\n\t\tif(error && error.stack){\r\n\t\t\tstack += error.stack;\r\n\t\t}\r\n\t\tif(rejection && rejection.stack){\r\n\t\t\tstack += \"\\n    ----------------------------------------\\n    rejected\" + rejection.stack.split(\"\\n\").slice(1).join(\"\\n\").replace(/^\\s+/, \" \");\r\n\t\t}\r\n\t\tif(deferred && deferred.stack){\r\n\t\t\tstack += \"\\n    ----------------------------------------\\n\" + deferred.stack;\r\n\t\t}\r\n\t\tconsole.error(error, stack);\r\n\t}\r\n\r\n\tfunction reportRejections(error, handled, rejection, deferred){\r\n\t\tif(!handled){\r\n\t\t\tlogError(error, rejection, deferred);\r\n\t\t}\r\n\t}\r\n\r\n\tvar errors = [];\r\n\tvar activeTimeout = false;\r\n\tvar unhandledWait = 1000;\r\n\tfunction trackUnhandledRejections(error, handled, rejection, deferred){\r\n\t\t// try to find the existing tracking object\r\n\t\tif(!arrayUtil.some(errors, function(obj){\r\n\t\t\tif(obj.error === error){\r\n\t\t\t\t// found the tracking object for this error\r\n\t\t\t\tif(handled){\r\n\t\t\t\t\t// if handled, update the state\r\n\t\t\t\t\tobj.handled = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t})){\r\n\t\t\t// no tracking object has been setup, create one\r\n\t\t\terrors.push({\r\n\t\t\t\terror: error,\r\n\t\t\t\trejection: rejection,\r\n\t\t\t\thandled: handled,\r\n\t\t\t\tdeferred: deferred,\r\n\t\t\t\ttimestamp: new Date().getTime()\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(!activeTimeout){\r\n\t\t\tactiveTimeout = setTimeout(logRejected, unhandledWait);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction logRejected(){\r\n\t\tvar now = new Date().getTime();\r\n\t\tvar reportBefore = now - unhandledWait;\r\n\t\terrors = arrayUtil.filter(errors, function(obj){\r\n\t\t\t// only report the error if we have waited long enough and\r\n\t\t\t// it hasn't been handled\r\n\t\t\tif(obj.timestamp < reportBefore){\r\n\t\t\t\tif(!obj.handled){\r\n\t\t\t\t\tlogError(obj.error, obj.rejection, obj.deferred);\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\t\tif(errors.length){\r\n\t\t\tactiveTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);\r\n\t\t}else{\r\n\t\t\tactiveTimeout = false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn function(Deferred){\r\n\t\t// summary:\r\n\t\t//\t\tInitialize instrumentation for the Deferred class.\r\n\t\t// description:\r\n\t\t//\t\tInitialize instrumentation for the Deferred class.\r\n\t\t//\t\tDone automatically by `dojo/Deferred` if the\r\n\t\t//\t\t`deferredInstrumentation` and `useDeferredInstrumentation`\r\n\t\t//\t\tconfig options are set.\r\n\t\t//\r\n\t\t//\t\tSets up `dojo/promise/tracer` to log to the console.\r\n\t\t//\r\n\t\t//\t\tSets up instrumentation of rejected deferreds so unhandled\r\n\t\t//\t\terrors are logged to the console.\r\n\r\n\t\tvar usage = has(\"config-useDeferredInstrumentation\");\r\n\t\tif(usage){\r\n\t\t\ttracer.on(\"resolved\", lang.hitch(console, \"log\", \"resolved\"));\r\n\t\t\ttracer.on(\"rejected\", lang.hitch(console, \"log\", \"rejected\"));\r\n\t\t\ttracer.on(\"progress\", lang.hitch(console, \"log\", \"progress\"));\r\n\r\n\t\t\tvar args = [];\r\n\t\t\tif(typeof usage === \"string\"){\r\n\t\t\t\targs = usage.split(\",\");\r\n\t\t\t\tusage = args.shift();\r\n\t\t\t}\r\n\t\t\tif(usage === \"report-rejections\"){\r\n\t\t\t\tDeferred.instrumentRejected = reportRejections;\r\n\t\t\t}else if(usage === \"report-unhandled-rejections\" || usage === true || usage === 1){\r\n\t\t\t\tDeferred.instrumentRejected = trackUnhandledRejections;\r\n\t\t\t\tunhandledWait = parseInt(args[0], 10) || unhandledWait;\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error(\"Unsupported instrumentation usage <\" + usage + \">\");\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n"]}