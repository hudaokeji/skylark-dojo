{"version":3,"sources":["number.js"],"names":["define","lang","i18n","nlsNumber","dstring","dregexp","number","setObject","format","value","options","mixin","locale","normalizeLocale","bundle","getLocalization","customs","pattern","type","isNaN","Math","abs","Infinity","_applyPattern","_numberPatternRE","group","decimal","patternList","split","positivePattern","indexOf","currencyGroup","currencyDecimal","replace","match","prop","length","currency","Error","numberPatternRE","numberPattern","fractional","places","_formatAbsolute","round","increment","factor","toFixed","v","p","m","d","pow","a","patternParts","comma","maxPlaces","substring","valueParts","String","pad","undefined","lastIndexOf","substr","pop","patternDigits","groupSize","groupSize2","index","remainder","pieces","whole","off","push","slice","reverse","join","regexp","_parseInfo","isCurrency","re","buildGroupRE","escapeString","flags","signed","separator","strict","exponent","parts","groups","_realNumberRegexp","before","target","after","symbol","parse","expression","info","results","RegExp","exec","NaN","absoluteMatch","test","eSigned","integerRE","_integerRegexp","decimalRE","q","exponentRE","realRE","sep","grp","grp2","grp2RE"],"mappings":"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","file":"../number.js","sourcesContent":["define([/*===== \"./_base/declare\", =====*/ \"./_base/lang\", \"../i18n\", \"../i18n!./cldr/nls/number\", \"./string\", \"./regexp\"],\r\n\tfunction(/*===== declare, =====*/ lang, i18n, nlsNumber, dstring, dregexp){\r\n\r\n// module:\r\n//\t\tdojo/number\r\n\r\nvar number = {\r\n\t// summary:\r\n\t//\t\tlocalized formatting and parsing routines for Number\r\n};\r\nlang.setObject(\"dojo.number\", number);\r\n\r\n/*=====\r\nnumber.__FormatOptions = declare(null, {\r\n\t// pattern: String?\r\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\r\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\r\n\t//\t\tlocalization.  Literal characters in patterns are not supported.\r\n\t// type: String?\r\n\t//\t\tchoose a format type based on the locale from the following:\r\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\r\n\t// places: Number?\r\n\t//\t\tfixed number of decimal places to show.  This overrides any\r\n\t//\t\tinformation in the provided pattern.\r\n\t// round: Number?\r\n\t//\t\t5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\r\n\t//\t\tmeans do not round.\r\n\t// locale: String?\r\n\t//\t\toverride the locale used to determine formatting rules\r\n\t// fractional: Boolean?\r\n\t//\t\tIf false, show no decimal places, overriding places and pattern settings.\r\n});\r\n=====*/\r\n\r\nnumber.format = function(/*Number*/ value, /*number.__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tFormat a Number as a String, using locale-specific settings\r\n\t// description:\r\n\t//\t\tCreate a string from a Number using a known localized pattern.\r\n\t//\t\tFormatting patterns appropriate to the locale are chosen from the\r\n\t//\t\t[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and\r\n\t//\t\tdelimiters.\r\n\t//\t\tIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.\r\n\t// value:\r\n\t//\t\tthe number to be formatted\r\n\r\n\toptions = lang.mixin({}, options || {});\r\n\tvar locale = i18n.normalizeLocale(options.locale),\r\n\t\tbundle = i18n.getLocalization(\"dojo.cldr\", \"number\", locale);\r\n\toptions.customs = bundle;\r\n\tvar pattern = options.pattern || bundle[(options.type || \"decimal\") + \"Format\"];\r\n\tif(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null\r\n\treturn number._applyPattern(value, pattern, options); // String\r\n};\r\n\r\n//number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\\.0*#*)?/; // not precise, but good enough\r\nnumber._numberPatternRE = /[#0,]*[#0](?:\\.0*#*)?/; // not precise, but good enough\r\n\r\nnumber._applyPattern = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tApply pattern to format value as a string using options. Gives no\r\n\t//\t\tconsideration to local customs.\r\n\t// value:\r\n\t//\t\tthe number to be formatted.\r\n\t// pattern:\r\n\t//\t\ta pattern string as described by\r\n\t//\t\t[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\r\n\t// options: number.__FormatOptions?\r\n\t//\t\t_applyPattern is usually called via `dojo/number.format()` which\r\n\t//\t\tpopulates an extra property in the options parameter, \"customs\".\r\n\t//\t\tThe customs object specifies group and decimal parameters if set.\r\n\r\n\t//TODO: support escapes\r\n\toptions = options || {};\r\n\tvar group = options.customs.group,\r\n\t\tdecimal = options.customs.decimal,\r\n\t\tpatternList = pattern.split(';'),\r\n\t\tpositivePattern = patternList[0];\r\n\tpattern = patternList[(value < 0) ? 1 : 0] || (\"-\" + positivePattern);\r\n\r\n\t//TODO: only test against unescaped\r\n\tif(pattern.indexOf('%') != -1){\r\n\t\tvalue *= 100;\r\n\t}else if(pattern.indexOf('\\u2030') != -1){\r\n\t\tvalue *= 1000; // per mille\r\n\t}else if(pattern.indexOf('\\u00a4') != -1){\r\n\t\tgroup = options.customs.currencyGroup || group;//mixins instead?\r\n\t\tdecimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?\r\n\t\tpattern = pattern.replace(/\\u00a4{1,3}/, function(match){\r\n\t\t\tvar prop = [\"symbol\", \"currency\", \"displayName\"][match.length-1];\r\n\t\t\treturn options[prop] || options.currency || \"\";\r\n\t\t});\r\n\t}else if(pattern.indexOf('E') != -1){\r\n\t\tthrow new Error(\"exponential notation not supported\");\r\n\t}\r\n\r\n\t//TODO: support @ sig figs?\r\n\tvar numberPatternRE = number._numberPatternRE;\r\n\tvar numberPattern = positivePattern.match(numberPatternRE);\r\n\tif(!numberPattern){\r\n\t\tthrow new Error(\"unable to find a number expression in pattern: \"+pattern);\r\n\t}\r\n\tif(options.fractional === false){ options.places = 0; }\r\n\treturn pattern.replace(numberPatternRE,\r\n\t\tnumber._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));\r\n};\r\n\r\nnumber.round = function(/*Number*/ value, /*Number?*/ places, /*Number?*/ increment){\r\n\t// summary:\r\n\t//\t\tRounds to the nearest value with the given number of decimal places, away from zero\r\n\t// description:\r\n\t//\t\tRounds to the nearest value with the given number of decimal places, away from zero if equal.\r\n\t//\t\tSimilar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by\r\n\t//\t\tfractional increments also, such as the nearest quarter.\r\n\t//\t\tNOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.\r\n\t// value:\r\n\t//\t\tThe number to round\r\n\t// places:\r\n\t//\t\tThe number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.\r\n\t//\t\tMust be non-negative.\r\n\t// increment:\r\n\t//\t\tRounds next place to nearest value of increment/10.  10 by default.\r\n\t// example:\r\n\t// |\t>>> number.round(-0.5)\r\n\t// |\t-1\r\n\t// |\t>>> number.round(162.295, 2)\r\n\t// |\t162.29  // note floating point error.  Should be 162.3\r\n\t// |\t>>> number.round(10.71, 0, 2.5)\r\n\t// |\t10.75\r\n\tvar factor = 10 / (increment || 10);\r\n\treturn (factor * +value).toFixed(places) / factor; // Number\r\n};\r\n\r\nif((0.9).toFixed() == 0){\r\n\t// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit\r\n\t// is just after the rounding place and is >=5\r\n\tvar round = number.round;\r\n\tnumber.round = function(v, p, m){\r\n\t\tvar d = Math.pow(10, -p || 0), a = Math.abs(v);\r\n\t\tif(!v || a >= d){\r\n\t\t\td = 0;\r\n\t\t}else{\r\n\t\t\ta /= d;\r\n\t\t\tif(a < 0.5 || a >= 0.95){\r\n\t\t\t\td = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn round(v, p, m) + (v > 0 ? d : -d);\r\n\t};\r\n\r\n\t// Use \"doc hint\" so the doc parser ignores this new definition of round(), and uses the one above.\r\n\t/*===== number.round = round; =====*/\r\n}\r\n\r\n/*=====\r\nnumber.__FormatAbsoluteOptions = declare(null, {\r\n\t// decimal: String?\r\n\t//\t\tthe decimal separator\r\n\t// group: String?\r\n\t//\t\tthe group separator\r\n\t// places: Number|String?\r\n\t//\t\tnumber of decimal places.  the range \"n,m\" will format to m places.\r\n\t// round: Number?\r\n\t//\t\t5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\r\n\t//\t\tmeans don't round.\r\n});\r\n=====*/\r\n\r\nnumber._formatAbsolute = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatAbsoluteOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tApply numeric pattern to absolute value using options. Gives no\r\n\t//\t\tconsideration to local customs.\r\n\t// value:\r\n\t//\t\tthe number to be formatted, ignores sign\r\n\t// pattern:\r\n\t//\t\tthe number portion of a pattern (e.g. `#,##0.00`)\r\n\toptions = options || {};\r\n\tif(options.places === true){options.places=0;}\r\n\tif(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit\r\n\r\n\tvar patternParts = pattern.split(\".\"),\r\n\t\tcomma = typeof options.places == \"string\" && options.places.indexOf(\",\"),\r\n\t\tmaxPlaces = options.places;\r\n\tif(comma){\r\n\t\tmaxPlaces = options.places.substring(comma + 1);\r\n\t}else if(!(maxPlaces >= 0)){\r\n\t\tmaxPlaces = (patternParts[1] || []).length;\r\n\t}\r\n\tif(!(options.round < 0)){\r\n\t\tvalue = number.round(value, maxPlaces, options.round);\r\n\t}\r\n\r\n\tvar valueParts = String(Math.abs(value)).split(\".\"),\r\n\t\tfractional = valueParts[1] || \"\";\r\n\tif(patternParts[1] || options.places){\r\n\t\tif(comma){\r\n\t\t\toptions.places = options.places.substring(0, comma);\r\n\t\t}\r\n\t\t// Pad fractional with trailing zeros\r\n\t\tvar pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf(\"0\") + 1);\r\n\t\tif(pad > fractional.length){\r\n\t\t\tvalueParts[1] = dstring.pad(fractional, pad, '0', true);\r\n\t\t}\r\n\r\n\t\t// Truncate fractional\r\n\t\tif(maxPlaces < fractional.length){\r\n\t\t\tvalueParts[1] = fractional.substr(0, maxPlaces);\r\n\t\t}\r\n\t}else{\r\n\t\tif(valueParts[1]){ valueParts.pop(); }\r\n\t}\r\n\r\n\t// Pad whole with leading zeros\r\n\tvar patternDigits = patternParts[0].replace(',', '');\r\n\tpad = patternDigits.indexOf(\"0\");\r\n\tif(pad != -1){\r\n\t\tpad = patternDigits.length - pad;\r\n\t\tif(pad > valueParts[0].length){\r\n\t\t\tvalueParts[0] = dstring.pad(valueParts[0], pad);\r\n\t\t}\r\n\r\n\t\t// Truncate whole\r\n\t\tif(patternDigits.indexOf(\"#\") == -1){\r\n\t\t\tvalueParts[0] = valueParts[0].substr(valueParts[0].length - pad);\r\n\t\t}\r\n\t}\r\n\r\n\t// Add group separators\r\n\tvar index = patternParts[0].lastIndexOf(','),\r\n\t\tgroupSize, groupSize2;\r\n\tif(index != -1){\r\n\t\tgroupSize = patternParts[0].length - index - 1;\r\n\t\tvar remainder = patternParts[0].substr(0, index);\r\n\t\tindex = remainder.lastIndexOf(',');\r\n\t\tif(index != -1){\r\n\t\t\tgroupSize2 = remainder.length - index - 1;\r\n\t\t}\r\n\t}\r\n\tvar pieces = [];\r\n\tfor(var whole = valueParts[0]; whole;){\r\n\t\tvar off = whole.length - groupSize;\r\n\t\tpieces.push((off > 0) ? whole.substr(off) : whole);\r\n\t\twhole = (off > 0) ? whole.slice(0, off) : \"\";\r\n\t\tif(groupSize2){\r\n\t\t\tgroupSize = groupSize2;\r\n\t\t\tdelete groupSize2;\r\n\t\t}\r\n\t}\r\n\tvalueParts[0] = pieces.reverse().join(options.group || \",\");\r\n\r\n\treturn valueParts.join(options.decimal || \".\");\r\n};\r\n\r\n/*=====\r\nnumber.__RegexpOptions = declare(null, {\r\n\t// pattern: String?\r\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\r\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\r\n\t//\t\tlocalization.\r\n\t// type: String?\r\n\t//\t\tchoose a format type based on the locale from the following:\r\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\r\n\t// locale: String?\r\n\t//\t\toverride the locale used to determine formatting rules\r\n\t// strict: Boolean?\r\n\t//\t\tstrict parsing, false by default.  Strict parsing requires input as produced by the format() method.\r\n\t//\t\tNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators\r\n\t// places: Number|String?\r\n\t//\t\tnumber of decimal places to accept: Infinity, a positive number, or\r\n\t//\t\ta range \"n,m\".  Defined by pattern or Infinity if pattern not provided.\r\n});\r\n=====*/\r\nnumber.regexp = function(/*number.__RegexpOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tBuilds the regular needed to parse a number\r\n\t// description:\r\n\t//\t\tReturns regular expression with positive and negative match, group\r\n\t//\t\tand decimal separators\r\n\treturn number._parseInfo(options).regexp; // String\r\n};\r\n\r\nnumber._parseInfo = function(/*Object?*/ options){\r\n\toptions = options || {};\r\n\tvar locale = i18n.normalizeLocale(options.locale),\r\n\t\tbundle = i18n.getLocalization(\"dojo.cldr\", \"number\", locale),\r\n\t\tpattern = options.pattern || bundle[(options.type || \"decimal\") + \"Format\"],\r\n//TODO: memoize?\r\n\t\tgroup = bundle.group,\r\n\t\tdecimal = bundle.decimal,\r\n\t\tfactor = 1;\r\n\r\n\tif(pattern.indexOf('%') != -1){\r\n\t\tfactor /= 100;\r\n\t}else if(pattern.indexOf('\\u2030') != -1){\r\n\t\tfactor /= 1000; // per mille\r\n\t}else{\r\n\t\tvar isCurrency = pattern.indexOf('\\u00a4') != -1;\r\n\t\tif(isCurrency){\r\n\t\t\tgroup = bundle.currencyGroup || group;\r\n\t\t\tdecimal = bundle.currencyDecimal || decimal;\r\n\t\t}\r\n\t}\r\n\r\n\t//TODO: handle quoted escapes\r\n\tvar patternList = pattern.split(';');\r\n\tif(patternList.length == 1){\r\n\t\tpatternList.push(\"-\" + patternList[0]);\r\n\t}\r\n\r\n\tvar re = dregexp.buildGroupRE(patternList, function(pattern){\r\n\t\tpattern = \"(?:\"+dregexp.escapeString(pattern, '.')+\")\";\r\n\t\treturn pattern.replace(number._numberPatternRE, function(format){\r\n\t\t\tvar flags = {\r\n\t\t\t\tsigned: false,\r\n\t\t\t\tseparator: options.strict ? group : [group,\"\"],\r\n\t\t\t\tfractional: options.fractional,\r\n\t\t\t\tdecimal: decimal,\r\n\t\t\t\texponent: false\r\n\t\t\t\t},\r\n\r\n\t\t\t\tparts = format.split('.'),\r\n\t\t\t\tplaces = options.places;\r\n\r\n\t\t\t// special condition for percent (factor != 1)\r\n\t\t\t// allow decimal places even if not specified in pattern\r\n\t\t\tif(parts.length == 1 && factor != 1){\r\n\t\t\t    parts[1] = \"###\";\r\n\t\t\t}\r\n\t\t\tif(parts.length == 1 || places === 0){\r\n\t\t\t\tflags.fractional = false;\r\n\t\t\t}else{\r\n\t\t\t\tif(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }\r\n\t\t\t\tif(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified\r\n\t\t\t\tif(!options.places && (places < parts[1].length)){ places += \",\" + parts[1].length; }\r\n\t\t\t\tflags.places = places;\r\n\t\t\t}\r\n\t\t\tvar groups = parts[0].split(',');\r\n\t\t\tif(groups.length > 1){\r\n\t\t\t\tflags.groupSize = groups.pop().length;\r\n\t\t\t\tif(groups.length > 1){\r\n\t\t\t\t\tflags.groupSize2 = groups.pop().length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"(\"+number._realNumberRegexp(flags)+\")\";\r\n\t\t});\r\n\t}, true);\r\n\r\n\tif(isCurrency){\r\n\t\t// substitute the currency symbol for the placeholder in the pattern\r\n\t\tre = re.replace(/([\\s\\xa0]*)(\\u00a4{1,3})([\\s\\xa0]*)/g, function(match, before, target, after){\r\n\t\t\tvar prop = [\"symbol\", \"currency\", \"displayName\"][target.length-1],\r\n\t\t\t\tsymbol = dregexp.escapeString(options[prop] || options.currency || \"\");\r\n\t\t\tbefore = before ? \"[\\\\s\\\\xa0]\" : \"\";\r\n\t\t\tafter = after ? \"[\\\\s\\\\xa0]\" : \"\";\r\n\t\t\tif(!options.strict){\r\n\t\t\t\tif(before){before += \"*\";}\r\n\t\t\t\tif(after){after += \"*\";}\r\n\t\t\t\treturn \"(?:\"+before+symbol+after+\")?\";\r\n\t\t\t}\r\n\t\t\treturn before+symbol+after;\r\n\t\t});\r\n\t}\r\n\r\n//TODO: substitute localized sign/percent/permille/etc.?\r\n\r\n\t// normalize whitespace and return\r\n\treturn {regexp: re.replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"), group: group, decimal: decimal, factor: factor}; // Object\r\n};\r\n\r\n/*=====\r\nnumber.__ParseOptions = declare(null, {\r\n\t// pattern: String?\r\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\r\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\r\n\t//\t\tlocalization.  Literal characters in patterns are not supported.\r\n\t// type: String?\r\n\t//\t\tchoose a format type based on the locale from the following:\r\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\r\n\t// locale: String?\r\n\t//\t\toverride the locale used to determine formatting rules\r\n\t// strict: Boolean?\r\n\t//\t\tstrict parsing, false by default.  Strict parsing requires input as produced by the format() method.\r\n\t//\t\tNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators\r\n\t// fractional: Boolean|Array?\r\n\t//\t\tWhether to include the fractional portion, where the number of decimal places are implied by pattern\r\n\t//\t\tor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.\r\n});\r\n=====*/\r\nnumber.parse = function(/*String*/ expression, /*number.__ParseOptions?*/ options){\r\n\t// summary:\r\n\t//\t\tConvert a properly formatted string to a primitive Number, using\r\n\t//\t\tlocale-specific settings.\r\n\t// description:\r\n\t//\t\tCreate a Number from a string using a known localized pattern.\r\n\t//\t\tFormatting patterns are chosen appropriate to the locale\r\n\t//\t\tand follow the syntax described by\r\n\t//\t\t[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\r\n    \t//\t\tNote that literal characters in patterns are not supported.\r\n\t// expression:\r\n\t//\t\tA string representation of a Number\r\n\tvar info = number._parseInfo(options),\r\n\t\tresults = (new RegExp(\"^\"+info.regexp+\"$\")).exec(expression);\r\n\tif(!results){\r\n\t\treturn NaN; //NaN\r\n\t}\r\n\tvar absoluteMatch = results[1]; // match for the positive expression\r\n\tif(!results[1]){\r\n\t\tif(!results[2]){\r\n\t\t\treturn NaN; //NaN\r\n\t\t}\r\n\t\t// matched the negative pattern\r\n\t\tabsoluteMatch =results[2];\r\n\t\tinfo.factor *= -1;\r\n\t}\r\n\r\n\t// Transform it to something Javascript can parse as a number.  Normalize\r\n\t// decimal point and strip out group separators or alternate forms of whitespace\r\n\tabsoluteMatch = absoluteMatch.\r\n\t\treplace(new RegExp(\"[\"+info.group + \"\\\\s\\\\xa0\"+\"]\", \"g\"), \"\").\r\n\t\treplace(info.decimal, \".\");\r\n\t// Adjust for negative sign, percent, etc. as necessary\r\n\treturn absoluteMatch * info.factor; //Number\r\n};\r\n\r\n/*=====\r\nnumber.__RealNumberRegexpFlags = declare(null, {\r\n\t// places: Number?\r\n\t//\t\tThe integer number of decimal places or a range given as \"n,m\".  If\r\n\t//\t\tnot given, the decimal part is optional and the number of places is\r\n\t//\t\tunlimited.\r\n\t// decimal: String?\r\n\t//\t\tA string for the character used as the decimal point.  Default\r\n\t//\t\tis \".\".\r\n\t// fractional: Boolean|Array?\r\n\t//\t\tWhether decimal places are used.  Can be true, false, or [true,\r\n\t//\t\tfalse].  Default is [true, false] which means optional.\r\n\t// exponent: Boolean|Array?\r\n\t//\t\tExpress in exponential notation.  Can be true, false, or [true,\r\n\t//\t\tfalse]. Default is [true, false], (i.e. will match if the\r\n\t//\t\texponential part is present are not).\r\n\t// eSigned: Boolean|Array?\r\n\t//\t\tThe leading plus-or-minus sign on the exponent.  Can be true,\r\n\t//\t\tfalse, or [true, false].  Default is [true, false], (i.e. will\r\n\t//\t\tmatch if it is signed or unsigned).  flags in regexp.integer can be\r\n\t//\t\tapplied.\r\n});\r\n=====*/\r\n\r\nnumber._realNumberRegexp = function(/*__RealNumberRegexpFlags?*/ flags){\r\n\t// summary:\r\n\t//\t\tBuilds a regular expression to match a real number in exponential\r\n\t//\t\tnotation\r\n\r\n\t// assign default values to missing parameters\r\n\tflags = flags || {};\r\n\t//TODO: use mixin instead?\r\n\tif(!(\"places\" in flags)){ flags.places = Infinity; }\r\n\tif(typeof flags.decimal != \"string\"){ flags.decimal = \".\"; }\r\n\tif(!(\"fractional\" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }\r\n\tif(!(\"exponent\" in flags)){ flags.exponent = [true, false]; }\r\n\tif(!(\"eSigned\" in flags)){ flags.eSigned = [true, false]; }\r\n\r\n\tvar integerRE = number._integerRegexp(flags),\r\n\t\tdecimalRE = dregexp.buildGroupRE(flags.fractional,\r\n\t\tfunction(q){\r\n\t\t\tvar re = \"\";\r\n\t\t\tif(q && (flags.places!==0)){\r\n\t\t\t\tre = \"\\\\\" + flags.decimal;\r\n\t\t\t\tif(flags.places == Infinity){\r\n\t\t\t\t\tre = \"(?:\" + re + \"\\\\d+)?\";\r\n\t\t\t\t}else{\r\n\t\t\t\t\tre += \"\\\\d{\" + flags.places + \"}\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn re;\r\n\t\t},\r\n\t\ttrue\r\n\t);\r\n\r\n\tvar exponentRE = dregexp.buildGroupRE(flags.exponent,\r\n\t\tfunction(q){\r\n\t\t\tif(q){ return \"([eE]\" + number._integerRegexp({ signed: flags.eSigned}) + \")\"; }\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t);\r\n\r\n\tvar realRE = integerRE + decimalRE;\r\n\t// allow for decimals without integers, e.g. .25\r\n\tif(decimalRE){realRE = \"(?:(?:\"+ realRE + \")|(?:\" + decimalRE + \"))\";}\r\n\treturn realRE + exponentRE; // String\r\n};\r\n\r\n/*=====\r\nnumber.__IntegerRegexpFlags = declare(null, {\r\n\t// signed: Boolean?\r\n\t//\t\tThe leading plus-or-minus sign. Can be true, false, or `[true,false]`.\r\n\t//\t\tDefault is `[true, false]`, (i.e. will match if it is signed\r\n\t//\t\tor unsigned).\r\n\t// separator: String?\r\n\t//\t\tThe character used as the thousands separator. Default is no\r\n\t//\t\tseparator. For more than one symbol use an array, e.g. `[\",\", \"\"]`,\r\n\t//\t\tmakes ',' optional.\r\n\t// groupSize: Number?\r\n\t//\t\tgroup size between separators\r\n\t// groupSize2: Number?\r\n\t//\t\tsecond grouping, where separators 2..n have a different interval than the first separator (for India)\r\n});\r\n=====*/\r\n\r\nnumber._integerRegexp = function(/*number.__IntegerRegexpFlags?*/ flags){\r\n\t// summary:\r\n\t//\t\tBuilds a regular expression that matches an integer\r\n\r\n\t// assign default values to missing parameters\r\n\tflags = flags || {};\r\n\tif(!(\"signed\" in flags)){ flags.signed = [true, false]; }\r\n\tif(!(\"separator\" in flags)){\r\n\t\tflags.separator = \"\";\r\n\t}else if(!(\"groupSize\" in flags)){\r\n\t\tflags.groupSize = 3;\r\n\t}\r\n\r\n\tvar signRE = dregexp.buildGroupRE(flags.signed,\r\n\t\tfunction(q){ return q ? \"[-+]\" : \"\"; },\r\n\t\ttrue\r\n\t);\r\n\r\n\tvar numberRE = dregexp.buildGroupRE(flags.separator,\r\n\t\tfunction(sep){\r\n\t\t\tif(!sep){\r\n\t\t\t\treturn \"(?:\\\\d+)\";\r\n\t\t\t}\r\n\r\n\t\t\tsep = dregexp.escapeString(sep);\r\n\t\t\tif(sep == \" \"){ sep = \"\\\\s\"; }\r\n\t\t\telse if(sep == \"\\xa0\"){ sep = \"\\\\s\\\\xa0\"; }\r\n\r\n\t\t\tvar grp = flags.groupSize, grp2 = flags.groupSize2;\r\n\t\t\t//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933\r\n\t\t\tif(grp2){\r\n\t\t\t\tvar grp2RE = \"(?:0|[1-9]\\\\d{0,\" + (grp2-1) + \"}(?:[\" + sep + \"]\\\\d{\" + grp2 + \"})*[\" + sep + \"]\\\\d{\" + grp + \"})\";\r\n\t\t\t\treturn ((grp-grp2) > 0) ? \"(?:\" + grp2RE + \"|(?:0|[1-9]\\\\d{0,\" + (grp-1) + \"}))\" : grp2RE;\r\n\t\t\t}\r\n\t\t\treturn \"(?:0|[1-9]\\\\d{0,\" + (grp-1) + \"}(?:[\" + sep + \"]\\\\d{\" + grp + \"})*)\";\r\n\t\t},\r\n\t\ttrue\r\n\t);\r\n\r\n\treturn signRE + numberRE; // String\r\n};\r\n\r\nreturn number;\r\n});\r\n"]}