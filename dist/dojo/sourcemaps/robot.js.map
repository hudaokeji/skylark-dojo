{"version":3,"sources":["robot.js"],"names":["define","array","dom","geom","kernel","lang","win","doh","robot","winUtils","experimental","mixin","_resolveNode","n","byId","_scrollIntoView","p","forEach","_getWindowChain","w","p2","position","b","getPadBorderExtents","oldp","x","l","y","t","h","scrollIntoView","frameElement","_position","max","Math","min","view","getBox","contentWindow","document","r","cW","get","ownerDocument","arr","f","global","concat","node","delay","sequence","mouseMoveAt","duration","offsetX","offsetY","_assertRobot","point","this","pos","undefined","mouseMoveTo"],"mappings":"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","file":"../robot.js","sourcesContent":["define([\r\n\t\"./_base/array\",\r\n\t\"./dom\",\r\n\t\"./dom-geometry\",\r\n\t\"./_base/kernel\",\r\n\t\"./_base/lang\",\r\n\t\"./_base/window\",\r\n\t\"doh/_browserRunner\",\r\n\t\"doh/robot\",\r\n\t\"./window\"\r\n], function(array, dom, geom, kernel, lang, win, doh, robot, winUtils){\r\n\r\nkernel.experimental(\"dojo.robot\");\r\n\r\n// users who use doh+dojo get the added convenience of robot.mouseMoveAt(),\r\n// instead of computing the absolute coordinates of their elements themselves\r\nlang.mixin(robot, {\r\n\r\n\t_resolveNode: function(/*String||DOMNode||Function*/ n){\r\n\t\tif(typeof n == \"function\"){\r\n\t\t\t// if the user passed a function returning a node, evaluate it\r\n\t\t\tn = n();\r\n\t\t}\r\n\t\treturn n ? dom.byId(n) : null;\r\n\t},\r\n\r\n\t_scrollIntoView: function(/*Node*/ n){\r\n\t\t// scrolls the passed node into view, scrolling all ancestor frames/windows as well.\r\n\t\t// Assumes parent iframes can be made fully visible given the current browser window size\r\n\t\tvar p = null;\r\n\t\tarray.forEach(robot._getWindowChain(n), function(w){\r\n\t\t\t// get the position of the node wrt its parent window\r\n\t\t\t// if it is a parent frame, its padding and border extents will get added in\r\n\t\t\tvar p2 = geom.position(n, false),\r\n\t\t\t\tb = geom.getPadBorderExtents(n),\r\n\t\t\t\toldp = null;\r\n\t\t\t// if p2 is the position of the original passed node, store the position away as p\r\n\t\t\t// otherwise, node is actually an iframe. in this case, add the iframe's position wrt its parent window and also the iframe's padding and border extents\r\n\t\t\tif(!p){\r\n\t\t\t\tp = p2;\r\n\t\t\t}else{\r\n\t\t\t\toldp = p;\r\n\t\t\t\tp = {x: p.x+p2.x+b.l,\r\n\t\t\t\t\ty: p.y+p2.y+b.t,\r\n\t\t\t\t\tw: p.w,\r\n\t\t\t\t\th: p.h};\r\n\r\n\t\t\t}\r\n\t\t\t// scroll the parent window so that the node translated into the parent window's coordinate space is in view\r\n\t\t\twinUtils.scrollIntoView(n,p);\r\n\t\t\t// adjust position for the new scroll offsets\r\n\t\t\tp2 = geom.position(n, false);\r\n\t\t\tif(!oldp){\r\n\t\t\t\tp = p2;\r\n\t\t\t}else{\r\n\t\t\t\tp = {x: oldp.x+p2.x+b.l,\r\n\t\t\t\t\ty: oldp.y+p2.y+b.t,\r\n\t\t\t\t\tw: p.w,\r\n\t\t\t\t\th: p.h};\r\n\t\t\t}\r\n\t\t\t// get the parent iframe so it can be scrolled too\r\n\t\t\tn = w.frameElement;\r\n\t\t});\r\n\t},\r\n\r\n\t_position: function(/*Node*/ n){\r\n\t\t// Returns the geom.position of the passed node wrt the passed window's viewport,\r\n\t\t// following any parent iframes containing the node and clipping the node to each iframe.\r\n\t\t// precondition: _scrollIntoView already called\r\n\t\tvar p = null, max = Math.max, min = Math.min;\r\n\t\t// p: the returned position of the node\r\n\t\tarray.forEach(robot._getWindowChain(n), function(w){\r\n\t\t\t// get the position of the node wrt its parent window\r\n\t\t\t// if it is a parent frame, its padding and border extents will get added in\r\n\t\t\tvar p2 = geom.position(n, false), b = geom.getPadBorderExtents(n);\r\n\t\t\t// if p2 is the position of the original passed node, store the position away as p\r\n\t\t\t// otherwise, node is actually an iframe. in this case, add the iframe's position wrt its parent window and also the iframe's padding and border extents\r\n\t\t\tif(!p){\r\n\t\t\t\tp = p2;\r\n\t\t\t}else{\r\n\t\t\t\tvar view = winUtils.getBox(n.contentWindow.document);\r\n\t\t\t\tp2.r = p2.x+view.w;\r\n\t\t\t\tp2.b = p2.y+view.h;\r\n\t\t\t\tp = {x: max(p.x+p2.x,p2.x)+b.l, // clip left edge of node wrt the iframe\r\n\t\t\t\t\ty: max(p.y+p2.y,p2.y)+b.t,\t// top edge\r\n\t\t\t\t\tr: min(p.x+p2.x+p.w,p2.r)+b.l,\t// right edge (to compute width)\r\n\t\t\t\t\tb: min(p.y+p2.y+p.h,p2.b)+b.t}; // bottom edge (to compute height)\r\n\t\t\t\t// save a few bytes by computing width and height from r and b\r\n\t\t\t\tp.w = p.r-p.x;\r\n\t\t\t\tp.h = p.b-p.y;\r\n\t\t\t}\r\n\t\t\t// the new node is now the old node's parent iframe\r\n\t\t\tn=w.frameElement;\r\n\t\t});\r\n\t\treturn p;\r\n\t},\r\n\r\n\t_getWindowChain : function(/*Node*/ n){\r\n\t\t// Returns an array of windows starting from the passed node's parent window and ending at dojo's window\r\n\t\tvar cW = winUtils.get(n.ownerDocument);\r\n\t\tvar arr = [cW];\r\n\t\tvar f = cW.frameElement;\r\n\t\treturn (cW == win.global || !f) ? arr : arr.concat(robot._getWindowChain(f));\r\n\t},\r\n\r\n\tscrollIntoView : function(/*String||DOMNode||Function*/ node, /*Number, optional*/ delay){\r\n\t\t// summary:\r\n\t\t//\t\tScroll the passed node into view, if it is not.\r\n\t\t// node:\r\n\t\t//\t\tThe id of the node, or the node itself, to move the mouse to.\r\n\t\t//\t\tIf you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.\r\n\t\t//\t\tThis is useful if you need to move the mouse to an node that is not yet present.\r\n\t\t// delay:\r\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\r\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\r\n\r\n\t\trobot.sequence(function(){\r\n\t\t\trobot._scrollIntoView(robot._resolveNode(node));\r\n\t\t}, delay);\r\n\t},\r\n\r\n\tmouseMoveAt : function(/*String||DOMNode||Function*/ node, /*Integer, optional*/ delay, /*Integer, optional*/ duration, /*Number, optional*/ offsetX, /*Number, optional*/ offsetY){\r\n\t\t// summary:\r\n\t\t//\t\tMoves the mouse over the specified node at the specified relative x,y offset.\r\n\t\t// description:\r\n\t\t//\t\tMoves the mouse over the specified node at the specified relative x,y offset.\r\n\t\t//\t\tIf you do not specify an offset, mouseMove will default to move to the middle of the node.\r\n\t\t//\t\tExample: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);\r\n\t\t// node:\r\n\t\t//\t\tThe id of the node, or the node itself, to move the mouse to.\r\n\t\t//\t\tIf you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.\r\n\t\t//\t\tThis is useful if you need to move the mouse to an node that is not yet present.\r\n\t\t// delay:\r\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\r\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\r\n\t\t//\t\tFor example, the following code ends after 600ms:\r\n\t\t// |\trobot.mouseClick({left:true}, 100) // first call; wait 100ms\r\n\t\t// |\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\r\n\t\t// duration:\r\n\t\t//\t\tApproximate time Robot will spend moving the mouse\r\n\t\t//\t\tThe default is 100ms.\r\n\t\t// offsetX:\r\n\t\t//\t\tx offset relative to the node, in pixels, to move the mouse. The default is half the node's width.\r\n\t\t// offsetY:\r\n\t\t//\t\ty offset relative to the node, in pixels, to move the mouse. The default is half the node's height.\r\n\r\n\t\trobot._assertRobot();\r\n\r\n\t\t// Schedule an action to scroll the node into view, then calculate it's center point\r\n\t\tvar point = {};\r\n\t\tthis.sequence(function(){\r\n\t\t\tnode = robot._resolveNode(node);\r\n\t\t\trobot._scrollIntoView(node);\r\n\t\t\tvar pos = robot._position(node);\r\n\t\t\tif(offsetY === undefined){\r\n\t\t\t\toffsetX = pos.w/2;\r\n\t\t\t\toffsetY = pos.h/2;\r\n\t\t\t}\r\n\t\t\tpoint.x = pos.x+offsetX;\r\n\t\t\tpoint.y = pos.y+offsetY;\r\n\t\t}, delay);\r\n\r\n\t\t// Schedule a bunch of actions to move the mouse from the current position to point.\r\n\t\t// These actions won't run until after the above callback.\r\n\t\tthis.mouseMoveTo(point, 0, duration, false);\r\n\t}\r\n});\r\n\r\nreturn robot;\r\n});\r\n"]}