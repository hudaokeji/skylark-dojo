{"version":3,"sources":["query.js"],"names":["define","dojo","has","dom","on","array","lang","loader","defaultEngine","add","delegate","length","ap","Array","prototype","aps","slice","apc","concat","forEach","loopBody","f","a","o","call","global","node","apply","NodeList","isNew","this","nl","nodeArray","arguments","sort","target","l","i","_mixin","nlp","_NodeListCtor","queryForEngine","engine","query","root","byId","results","end","matches","match","selector","filter","nodes","indexOf","search","document","_wrap","parent","NodeListCtor","nodeList","_stash","_adaptAsMap","map","_adaptAsForEach","_adaptAsFilter","_adaptWithCondition","g","body","name","extend","constructor","toString","join","_parent","eventName","listener","handles","remove","item","t","m","func","obj","callback","thisObj","items","start","_filterResult","instantiate","declaredClass","properties","c","isFunction","getObject","at","push","require","isBrowser","load","req","onLoad","config","id","parentRequire","loaded","_filterQueryResult"],"mappings":"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","file":"../query.js","sourcesContent":["define([\"./_base/kernel\", \"./has\", \"./dom\", \"./on\", \"./_base/array\", \"./_base/lang\", \"./selector/_loader\", \"./selector/_loader!default\"],\r\n\tfunction(dojo, has, dom, on, array, lang, loader, defaultEngine){\r\n\r\n\t\"use strict\";\r\n\r\n\thas.add(\"array-extensible\", function(){\r\n\t\t// test to see if we can extend an array (not supported in old IE)\r\n\t\treturn lang.delegate([], {length: 1}).length == 1 && !has(\"bug-for-in-skips-shadowed\");\r\n\t});\r\n\t\r\n\tvar ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;\r\n\r\n\tvar tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){\r\n\t\t// summary:\r\n\t\t//\t\tdecorate an array to make it look like a `dojo/NodeList`.\r\n\t\t// a:\r\n\t\t//\t\tArray of nodes to decorate.\r\n\t\t// parent:\r\n\t\t//\t\tAn optional parent NodeList that generated the current\r\n\t\t//\t\tlist of nodes. Used to call _stash() so the parent NodeList\r\n\t\t//\t\tcan be accessed via end() later.\r\n\t\t// NodeListCtor:\r\n\t\t//\t\tAn optional constructor function to use for any\r\n\t\t//\t\tnew NodeList calls. This allows a certain chain of\r\n\t\t//\t\tNodeList calls to use a different object than dojo/NodeList.\r\n\t\tvar nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);\r\n\t\treturn parent ? nodeList._stash(parent) : nodeList;\r\n\t};\r\n\r\n\tvar loopBody = function(f, a, o){\r\n\t\ta = [0].concat(aps.call(a, 0));\r\n\t\to = o || dojo.global;\r\n\t\treturn function(node){\r\n\t\t\ta[0] = node;\r\n\t\t\treturn f.apply(o, a);\r\n\t\t};\r\n\t};\r\n\r\n\t// adapters\r\n\r\n\tvar adaptAsForEach = function(f, o){\r\n\t\t// summary:\r\n\t\t//\t\tadapts a single node function to be used in the forEach-type\r\n\t\t//\t\tactions. The initial object is returned from the specialized\r\n\t\t//\t\tfunction.\r\n\t\t// f: Function\r\n\t\t//\t\ta function to adapt\r\n\t\t// o: Object?\r\n\t\t//\t\tan optional context for f\r\n\t\treturn function(){\r\n\t\t\tthis.forEach(loopBody(f, arguments, o));\r\n\t\t\treturn this;\t// Object\r\n\t\t};\r\n\t};\r\n\r\n\tvar adaptAsMap = function(f, o){\r\n\t\t// summary:\r\n\t\t//\t\tadapts a single node function to be used in the map-type\r\n\t\t//\t\tactions. The return is a new array of values, as via `dojo/_base/array.map`\r\n\t\t// f: Function\r\n\t\t//\t\ta function to adapt\r\n\t\t// o: Object?\r\n\t\t//\t\tan optional context for f\r\n\t\treturn function(){\r\n\t\t\treturn this.map(loopBody(f, arguments, o));\r\n\t\t};\r\n\t};\r\n\r\n\tvar adaptAsFilter = function(f, o){\r\n\t\t// summary:\r\n\t\t//\t\tadapts a single node function to be used in the filter-type actions\r\n\t\t// f: Function\r\n\t\t//\t\ta function to adapt\r\n\t\t// o: Object?\r\n\t\t//\t\tan optional context for f\r\n\t\treturn function(){\r\n\t\t\treturn this.filter(loopBody(f, arguments, o));\r\n\t\t};\r\n\t};\r\n\r\n\tvar adaptWithCondition = function(f, g, o){\r\n\t\t// summary:\r\n\t\t//\t\tadapts a single node function to be used in the map-type\r\n\t\t//\t\tactions, behaves like forEach() or map() depending on arguments\r\n\t\t// f: Function\r\n\t\t//\t\ta function to adapt\r\n\t\t// g: Function\r\n\t\t//\t\ta condition function, if true runs as map(), otherwise runs as forEach()\r\n\t\t// o: Object?\r\n\t\t//\t\tan optional context for f and g\r\n\t\treturn function(){\r\n\t\t\tvar a = arguments, body = loopBody(f, a, o);\r\n\t\t\tif(g.call(o || dojo.global, a)){\r\n\t\t\t\treturn this.map(body);\t// self\r\n\t\t\t}\r\n\t\t\tthis.forEach(body);\r\n\t\t\treturn this;\t// self\r\n\t\t};\r\n\t};\r\n\r\n\tvar NodeList = function(array){\r\n\t\t// summary:\r\n\t\t//\t\tArray-like object which adds syntactic\r\n\t\t//\t\tsugar for chaining, common iteration operations, animation, and\r\n\t\t//\t\tnode manipulation. NodeLists are most often returned as the\r\n\t\t//\t\tresult of dojo/query() calls.\r\n\t\t// description:\r\n\t\t//\t\tNodeList instances provide many utilities that reflect\r\n\t\t//\t\tcore Dojo APIs for Array iteration and manipulation, DOM\r\n\t\t//\t\tmanipulation, and event handling. Instead of needing to dig up\r\n\t\t//\t\tfunctions in the dojo package, NodeLists generally make the\r\n\t\t//\t\tfull power of Dojo available for DOM manipulation tasks in a\r\n\t\t//\t\tsimple, chainable way.\r\n\t\t// example:\r\n\t\t//\t\tcreate a node list from a node\r\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/dom\"\r\n\t\t//\t\t|\t], function(query, dom){\r\n\t\t//\t\t|\t\tquery.NodeList(dom.byId(\"foo\"));\r\n\t\t//\t\t|\t});\r\n\t\t// example:\r\n\t\t//\t\tget a NodeList from a CSS query and iterate on it\r\n\t\t//\t\t|\trequire([\"dojo/on\", \"dojo/dom\"\r\n\t\t//\t\t|\t], function(on, dom){\r\n\t\t//\t\t|\t\tvar l = query(\".thinger\");\r\n\t\t//\t\t|\t\tl.forEach(function(node, index, nodeList){\r\n\t\t//\t\t|\t\t\tconsole.log(index, node.innerHTML);\r\n\t\t//\t\t|\t\t});\r\n\t\t//\t\t|\t});\r\n\t\t// example:\r\n\t\t//\t\tuse native and Dojo-provided array methods to manipulate a\r\n\t\t//\t\tNodeList without needing to use dojo.* functions explicitly:\r\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/dom-construct\", \"dojo/dom\"\r\n\t\t//\t\t|\t], function(query, domConstruct, dom){\r\n\t\t//\t\t|\t\tvar l = query(\".thinger\");\r\n\t\t//\t\t|\t\t// since NodeLists are real arrays, they have a length\r\n\t\t//\t\t|\t\t// property that is both readable and writable and\r\n\t\t//\t\t|\t\t// push/pop/shift/unshift methods\r\n\t\t//\t\t|\t\tconsole.log(l.length);\r\n\t\t//\t\t|\t\tl.push(domConstruct.create(\"span\"));\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t// dojo's normalized array methods work too:\r\n\t\t//\t\t|\t\tconsole.log( l.indexOf(dom.byId(\"foo\")) );\r\n\t\t//\t\t|\t\t// ...including the special \"function as string\" shorthand\r\n\t\t//\t\t|\t\tconsole.log( l.every(\"item.nodeType == 1\") );\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t// NodeLists can be [..] indexed, or you can use the at()\r\n\t\t//\t\t|\t\t// function to get specific items wrapped in a new NodeList:\r\n\t\t//\t\t|\t\tvar node = l[3]; // the 4th element\r\n\t\t//\t\t|\t\tvar newList = l.at(1, 3); // the 2nd and 4th elements\r\n\t\t//\t\t|\t});\r\n\t\t// example:\r\n\t\t//\t\tchainability is a key advantage of NodeLists:\r\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\r\n\t\t//\t\t|\t], function(query){\r\n\t\t//\t\t|\t\tquery(\".thinger\")\r\n\t\t//\t\t|\t\t\t.onclick(function(e){ /* ... */ })\r\n\t\t//\t\t|\t\t\t.at(1, 3, 8) // get a subset\r\n\t\t//\t\t|\t\t\t\t.style(\"padding\", \"5px\")\r\n\t\t//\t\t|\t\t\t\t.forEach(console.log);\r\n\t\t//\t\t|\t});\r\n\r\n\t\tvar isNew = this instanceof nl && has(\"array-extensible\");\r\n\t\tif(typeof array == \"number\"){\r\n\t\t\tarray = Array(array);\r\n\t\t}\r\n\t\tvar nodeArray = (array && \"length\" in array) ? array : arguments;\r\n\t\tif(isNew || !nodeArray.sort){\r\n\t\t\t// make sure it's a real array before we pass it on to be wrapped \r\n\t\t\tvar target = isNew ? this : [],\r\n\t\t\t\tl = target.length = nodeArray.length;\r\n\t\t\tfor(var i = 0; i < l; i++){\r\n\t\t\t\ttarget[i] = nodeArray[i];\r\n\t\t\t}\r\n\t\t\tif(isNew){\r\n\t\t\t\t// called with new operator, this means we are going to use this instance and push\r\n\t\t\t\t// the nodes on to it. This is usually much faster since the NodeList properties\r\n\t\t\t\t//\tdon't need to be copied (unless the list of nodes is extremely large).\r\n\t\t\t\treturn target;\r\n\t\t\t}\r\n\t\t\tnodeArray = target;\r\n\t\t}\r\n\t\t// called without new operator, use a real array and copy prototype properties,\r\n\t\t// this is slower and exists for back-compat. Should be removed in 2.0.\r\n\t\tlang._mixin(nodeArray, nlp);\r\n\t\tnodeArray._NodeListCtor = function(array){\r\n\t\t\t// call without new operator to preserve back-compat behavior\r\n\t\t\treturn nl(array);\r\n\t\t};\r\n\t\treturn nodeArray;\r\n\t};\r\n\t\r\n\tvar nl = NodeList, nlp = nl.prototype = \r\n\t\thas(\"array-extensible\") ? [] : {};// extend an array if it is extensible\r\n\r\n\t// expose adapters and the wrapper as private functions\r\n\r\n\tnl._wrap = nlp._wrap = tnl;\r\n\tnl._adaptAsMap = adaptAsMap;\r\n\tnl._adaptAsForEach = adaptAsForEach;\r\n\tnl._adaptAsFilter  = adaptAsFilter;\r\n\tnl._adaptWithCondition = adaptWithCondition;\r\n\r\n\t// mass assignment\r\n\r\n\t// add array redirectors\r\n\tforEach([\"slice\", \"splice\"], function(name){\r\n\t\tvar f = ap[name];\r\n\t\t//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.\r\n\t\t// CANNOT apply ._stash()/end() to splice since it currently modifies\r\n\t\t// the existing this array -- it would break backward compatibility if we copy the array before\r\n\t\t// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.\r\n\t\tnlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == \"slice\" ? this : null); };\r\n\t});\r\n\t// concat should be here but some browsers with native NodeList have problems with it\r\n\r\n\t// add array.js redirectors\r\n\tforEach([\"indexOf\", \"lastIndexOf\", \"every\", \"some\"], function(name){\r\n\t\tvar f = array[name];\r\n\t\tnlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };\r\n\t});\r\n\r\n\tlang.extend(NodeList, {\r\n\t\t// copy the constructors\r\n\t\tconstructor: nl,\r\n\t\t_NodeListCtor: nl,\r\n\t\ttoString: function(){\r\n\t\t\t// Array.prototype.toString can't be applied to objects, so we use join\r\n\t\t\treturn this.join(\",\");\r\n\t\t},\r\n\t\t_stash: function(parent){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tprivate function to hold to a parent NodeList. end() to return the parent NodeList.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tHow to make a `dojo/NodeList` method that only returns the third node in\r\n\t\t\t//\t\tthe dojo/NodeList but allows access to the original NodeList by using this._stash:\r\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/_base/lang\", \"dojo/NodeList\", \"dojo/NodeList-dom\"\r\n\t\t\t//\t|\t], function(query, lang){\r\n\t\t\t//\t|\t\tlang.extend(NodeList, {\r\n\t\t\t//\t|\t\t\tthird: function(){\r\n\t\t\t//\t|\t\t\t\tvar newNodeList = NodeList(this[2]);\r\n\t\t\t//\t|\t\t\t\treturn newNodeList._stash(this);\r\n\t\t\t//\t|\t\t\t}\r\n\t\t\t//\t|\t\t});\r\n\t\t\t//\t|\t\t// then see how _stash applies a sub-list, to be .end()'ed out of\r\n\t\t\t//\t|\t\tquery(\".foo\")\r\n\t\t\t//\t|\t\t\t.third()\r\n\t\t\t//\t|\t\t\t\t.addClass(\"thirdFoo\")\r\n\t\t\t//\t|\t\t\t.end()\r\n\t\t\t//\t|\t\t\t// access to the orig .foo list\r\n\t\t\t//\t|\t\t\t.removeClass(\"foo\")\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\tthis._parent = parent;\r\n\t\t\treturn this; // dojo/NodeList\r\n\t\t},\r\n\r\n\t\ton: function(eventName, listener){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tListen for events on the nodes in the NodeList. Basic usage is:\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\t|\trequire([\"dojo/query\"\r\n\t\t\t//\t\t|\t], function(query){\r\n\t\t\t//\t\t|\t\tquery(\".my-class\").on(\"click\", listener);\r\n\t\t\t//\t\t\tThis supports event delegation by using selectors as the first argument with the event names as\r\n\t\t\t//\t\t\tpseudo selectors. For example:\r\n\t\t\t//\t\t| \t\tquery(\"#my-list\").on(\"li:click\", listener);\r\n\t\t\t//\t\t\tThis will listen for click events within `<li>` elements that are inside the `#my-list` element.\r\n\t\t\t//\t\t\tBecause on supports CSS selector syntax, we can use comma-delimited events as well:\r\n\t\t\t//\t\t| \t\tquery(\"#my-list\").on(\"li button:mouseover, li:click\", listener);\r\n\t\t\t//\t\t|\t});\r\n\t\t\tvar handles = this.map(function(node){\r\n\t\t\t\treturn on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches\r\n\t\t\t});\r\n\t\t\thandles.remove = function(){\r\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\r\n\t\t\t\t\thandles[i].remove();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn handles;\r\n\t\t},\r\n\r\n\t\tend: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEnds use of the current `NodeList` by returning the previous NodeList\r\n\t\t\t//\t\tthat generated the current NodeList.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns the `NodeList` that generated the current `NodeList`. If there\r\n\t\t\t//\t\tis no parent NodeList, an empty NodeList is returned.\r\n\t\t\t// example:\r\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\r\n\t\t\t//\t|\t], function(query){\r\n\t\t\t//\t|\t\tquery(\"a\")\r\n\t\t\t//\t|\t\t\t.filter(\".disabled\")\r\n\t\t\t//\t|\t\t\t\t// operate on the anchors that only have a disabled class\r\n\t\t\t//\t|\t\t\t\t.style(\"color\", \"grey\")\r\n\t\t\t//\t|\t\t\t.end()\r\n\t\t\t//\t|\t\t\t// jump back to the list of anchors\r\n\t\t\t//\t|\t\t\t.style(...)\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\tif(this._parent){\r\n\t\t\t\treturn this._parent;\r\n\t\t\t}else{\r\n\t\t\t\t//Just return empty list.\r\n\t\t\t\treturn new this._NodeListCtor(0);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods\r\n\r\n\t\t// FIXME: handle return values for #3244\r\n\t\t//\t\thttp://trac.dojotoolkit.org/ticket/3244\r\n\r\n\t\t// FIXME:\r\n\t\t//\t\tneed to wrap or implement:\r\n\t\t//\t\t\tjoin (perhaps w/ innerHTML/outerHTML overload for toString() of items?)\r\n\t\t//\t\t\treduce\r\n\t\t//\t\t\treduceRight\r\n\r\n\t\t/*=====\r\n\t\tslice: function(begin, end){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a new NodeList, maintaining this one in place\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method behaves exactly like the Array.slice method\r\n\t\t\t//\t\twith the caveat that it returns a `dojo/NodeList` and not a\r\n\t\t\t//\t\traw Array. For more details, see Mozilla's [slice\r\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)\r\n\t\t\t// begin: Integer\r\n\t\t\t//\t\tCan be a positive or negative integer, with positive\r\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\r\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\r\n\t\t\t//\t\tof the end)\r\n\t\t\t// end: Integer?\r\n\t\t\t//\t\tOptional parameter to describe what position relative to\r\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\r\n\t\t\t//\t\tcan be positive or negative.\r\n\t\t\treturn this._wrap(a.slice.apply(this, arguments));\r\n\t\t},\r\n\r\n\t\tsplice: function(index, howmany, item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a new NodeList, manipulating this NodeList based on\r\n\t\t\t//\t\tthe arguments passed, potentially splicing in new elements\r\n\t\t\t//\t\tat an offset, optionally deleting elements\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method behaves exactly like the Array.splice method\r\n\t\t\t//\t\twith the caveat that it returns a `dojo/NodeList` and not a\r\n\t\t\t//\t\traw Array. For more details, see Mozilla's [splice\r\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)\r\n\t\t\t//\t\tFor backwards compatibility, calling .end() on the spliced NodeList\r\n\t\t\t//\t\tdoes not return the original NodeList -- splice alters the NodeList in place.\r\n\t\t\t// index: Integer\r\n\t\t\t//\t\tbegin can be a positive or negative integer, with positive\r\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\r\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\r\n\t\t\t//\t\tof the end)\r\n\t\t\t// howmany: Integer?\r\n\t\t\t//\t\tOptional parameter to describe what position relative to\r\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\r\n\t\t\t//\t\tcan be positive or negative.\r\n\t\t\t// item: Object...?\r\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\r\n\t\t\t//\t\tspliced into the NodeList\r\n\t\t\treturn this._wrap(a.splice.apply(this, arguments));\t// dojo/NodeList\r\n\t\t},\r\n\r\n\t\tindexOf: function(value, fromIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsee `dojo/_base/array.indexOf()`. The primary difference is that the acted-on\r\n\t\t\t//\t\tarray is implicitly this NodeList\r\n\t\t\t// value: Object\r\n\t\t\t//\t\tThe value to search for.\r\n\t\t\t// fromIndex: Integer?\r\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\r\n\t\t\t// description:\r\n\t\t\t//\t\tFor more details on the behavior of indexOf, see Mozilla's\r\n\t\t\t//\t\t[indexOf\r\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\r\n\t\t\treturn d.indexOf(this, value, fromIndex); // Integer\r\n\t\t},\r\n\r\n\t\tlastIndexOf: function(value, fromIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsee `dojo/_base/array.lastIndexOf()`. The primary difference is that the\r\n\t\t\t//\t\tacted-on array is implicitly this NodeList\r\n\t\t\t// description:\r\n\t\t\t//\t\tFor more details on the behavior of lastIndexOf, see\r\n\t\t\t//\t\tMozilla's [lastIndexOf\r\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)\r\n\t\t\t// value: Object\r\n\t\t\t//\t\tThe value to search for.\r\n\t\t\t// fromIndex: Integer?\r\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\r\n\t\t\treturn d.lastIndexOf(this, value, fromIndex); // Integer\r\n\t\t},\r\n\r\n\t\tevery: function(callback, thisObject){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsee `dojo/_base/array.every()` and the [Array.every\r\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).\r\n\t\t\t//\t\tTakes the same structure of arguments and returns as\r\n\t\t\t//\t\tdojo/_base/array.every() with the caveat that the passed array is\r\n\t\t\t//\t\timplicitly this NodeList\r\n\t\t\t// callback: Function\r\n\t\t\t//\t\tthe callback\r\n\t\t\t// thisObject: Object?\r\n\t\t\t//\t\tthe context\r\n\t\t\treturn d.every(this, callback, thisObject); // Boolean\r\n\t\t},\r\n\r\n\t\tsome: function(callback, thisObject){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTakes the same structure of arguments and returns as\r\n\t\t\t//\t\t`dojo/_base/array.some()` with the caveat that the passed array is\r\n\t\t\t//\t\timplicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's\r\n\t\t\t//\t\t[Array.some\r\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).\r\n\t\t\t// callback: Function\r\n\t\t\t//\t\tthe callback\r\n\t\t\t// thisObject: Object?\r\n\t\t\t//\t\tthe context\r\n\t\t\treturn d.some(this, callback, thisObject); // Boolean\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\tconcat: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\r\n\t\t\t//\t\tas well as items passed in as parameters\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method behaves exactly like the Array.concat method\r\n\t\t\t//\t\twith the caveat that it returns a `NodeList` and not a\r\n\t\t\t//\t\traw Array. For more details, see the [Array.concat\r\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)\r\n\t\t\t// item: Object?\r\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\r\n\t\t\t//\t\tspliced into the NodeList\r\n\r\n\t\t\t//return this._wrap(apc.apply(this, arguments));\r\n\t\t\t// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(\r\n\r\n\t\t\t// implementation notes:\r\n\t\t\t// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists\r\n\t\t\t// as arrays, and so does not inline them into a unioned array, but\r\n\t\t\t// appends them as single entities. Both the original NodeList and the\r\n\t\t\t// items passed in as parameters must be converted to raw Arrays\r\n\t\t\t// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.\r\n\r\n\t\t\tvar t = aps.call(this, 0),\r\n\t\t\t\tm = array.map(arguments, function(a){\r\n\t\t\t\t\treturn aps.call(a, 0);\r\n\t\t\t\t});\r\n\t\t\treturn this._wrap(apc.apply(t, m), this);\t// dojo/NodeList\r\n\t\t},\r\n\r\n\t\tmap: function(/*Function*/ func, /*Function?*/ obj){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsee `dojo/_base/array.map()`. The primary difference is that the acted-on\r\n\t\t\t//\t\tarray is implicitly this NodeList and the return is a\r\n\t\t\t//\t\tNodeList (a subclass of Array)\r\n\t\t\treturn this._wrap(array.map(this, func, obj), this); // dojo/NodeList\r\n\t\t},\r\n\r\n\t\tforEach: function(callback, thisObj){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsee `dojo/_base/array.forEach()`. The primary difference is that the acted-on\r\n\t\t\t//\t\tarray is implicitly this NodeList. If you want the option to break out\r\n\t\t\t//\t\tof the forEach loop, use every() or some() instead.\r\n\t\t\tforEach(this, callback, thisObj);\r\n\t\t\t// non-standard return to allow easier chaining\r\n\t\t\treturn this; // dojo/NodeList\r\n\t\t},\r\n\t\tfilter: function(/*String|Function*/ filter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\t\"masks\" the built-in javascript filter() method (supported\r\n\t\t\t//\t\tin Dojo via `dojo/_base/array.filter`) to support passing a simple\r\n\t\t\t//\t\tstring filter in addition to supporting filtering function\r\n\t\t\t//\t\tobjects.\r\n\t\t\t// filter:\r\n\t\t\t//\t\tIf a string, a CSS rule like \".thinger\" or \"div > span\".\r\n\t\t\t// example:\r\n\t\t\t//\t\t\"regular\" JS filter syntax as exposed in `dojo/_base/array.filter`:\r\n\t\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\r\n\t\t\t//\t\t|\t], function(query){\r\n\t\t\t//\t\t|\t\tquery(\"*\").filter(function(item){\r\n\t\t\t//\t\t|\t\t\t// highlight every paragraph\r\n\t\t\t//\t\t|\t\t\treturn (item.nodeName == \"p\");\r\n\t\t\t//\t\t|\t\t}).style(\"backgroundColor\", \"yellow\");\r\n\t\t\t//\t\t|\t});\r\n\t\t\t// example:\r\n\t\t\t//\t\tthe same filtering using a CSS selector\r\n\t\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\r\n\t\t\t//\t\t|\t], function(query){\r\n\t\t\t//\t\t|\t\tquery(\"*\").filter(\"p\").styles(\"backgroundColor\", \"yellow\");\r\n\t\t\t//\t\t|\t});\r\n\r\n\t\t\tvar a = arguments, items = this, start = 0;\r\n\t\t\tif(typeof filter == \"string\"){ // inline'd type check\r\n\t\t\t\titems = query._filterResult(this, a[0]);\r\n\t\t\t\tif(a.length == 1){\r\n\t\t\t\t\t// if we only got a string query, pass back the filtered results\r\n\t\t\t\t\treturn items._stash(this); // dojo/NodeList\r\n\t\t\t\t}\r\n\t\t\t\t// if we got a callback, run it over the filtered items\r\n\t\t\t\tstart = 1;\r\n\t\t\t}\r\n\t\t\treturn this._wrap(array.filter(items, a[start], a[start + 1]), this);\t// dojo/NodeList\r\n\t\t},\r\n\t\tinstantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate a new instance of a specified class, using the\r\n\t\t\t//\t\tspecified properties and each node in the NodeList as a\r\n\t\t\t//\t\tsrcNodeRef.\r\n\t\t\t// example:\r\n\t\t\t//\t\tGrabs all buttons in the page and converts them to dijit/form/Button's.\r\n\t\t\t//\t|\tvar buttons = query(\"button\").instantiate(Button, {showLabel: true});\r\n\t\t\tvar c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);\r\n\t\t\tproperties = properties || {};\r\n\t\t\treturn this.forEach(function(node){\r\n\t\t\t\tnew c(properties, node);\r\n\t\t\t});\t// dojo/NodeList\r\n\t\t},\r\n\t\tat: function(/*===== index =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\r\n\t\t\t//\t\tat the given index or indices.\r\n\t\t\t//\r\n\t\t\t// index: Integer...\r\n\t\t\t//\t\tOne or more 0-based indices of items in the current\r\n\t\t\t//\t\tNodeList. A negative index will start at the end of the\r\n\t\t\t//\t\tlist and go backwards.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tShorten the list to the first, second, and third elements\r\n\t\t\t//\t|\trequire([\"dojo/query\"\r\n\t\t\t//\t|\t], function(query){\r\n\t\t\t//\t|\t\tquery(\"a\").at(0, 1, 2).forEach(fn);\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tRetrieve the first and last elements of a unordered list:\r\n\t\t\t//\t|\trequire([\"dojo/query\"\r\n\t\t\t//\t|\t], function(query){\r\n\t\t\t//\t|\t\tquery(\"ul > li\").at(0, -1).forEach(cb);\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\tDo something for the first element only, but end() out back to\r\n\t\t\t//\tthe original list and continue chaining:\r\n\t\t\t//\t|\trequire([\"dojo/query\"\r\n\t\t\t//\t|\t], function(query){\r\n\t\t\t//\t|\t\tquery(\"a\").at(0).onclick(fn).end().forEach(function(n){\r\n\t\t\t//\t|\t\t\tconsole.log(n); // all anchors on the page.\r\n\t\t\t//\t|\t})\r\n\t\t\t//\t|\t});\r\n\r\n\t\t\tvar t = new this._NodeListCtor(0);\r\n\t\t\tforEach(arguments, function(i){\r\n\t\t\t\tif(i < 0){ i = this.length + i; }\r\n\t\t\t\tif(this[i]){ t.push(this[i]); }\r\n\t\t\t}, this);\r\n\t\t\treturn t._stash(this); // dojo/NodeList\r\n\t\t}\r\n\t});\r\n\r\n\tfunction queryForEngine(engine, NodeList){\r\n\t\tvar query = function(/*String*/ query, /*String|DOMNode?*/ root){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns nodes which match the given CSS selector, searching the\r\n\t\t\t//\t\tentire document by default but optionally taking a node to scope\r\n\t\t\t//\t\tthe search by. Returns an instance of NodeList.\r\n\t\t\tif(typeof root == \"string\"){\r\n\t\t\t\troot = dom.byId(root);\r\n\t\t\t\tif(!root){\r\n\t\t\t\t\treturn new NodeList([]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar results = typeof query == \"string\" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];\r\n\t\t\tif(results.end && results.on){\r\n\t\t\t\t// already wrapped\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\t\t\treturn new NodeList(results);\r\n\t\t};\r\n\t\tquery.matches = engine.match || function(node, selector, root){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTest to see if a node matches a selector\r\n\t\t\treturn query.filter([node], selector, root).length > 0;\r\n\t\t};\r\n\t\t// the engine provides a filtering function, use it to for matching\r\n\t\tquery.filter = engine.filter || function(nodes, selector, root){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFilters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.\r\n\t\t\treturn query(selector, root).filter(function(node){\r\n\t\t\t\treturn array.indexOf(nodes, node) > -1;\r\n\t\t\t});\r\n\t\t};\r\n\t\tif(typeof engine != \"function\"){\r\n\t\t\tvar search = engine.search;\r\n\t\t\tengine = function(selector, root){\r\n\t\t\t\t// Slick does it backwards (or everyone else does it backwards, probably the latter)\r\n\t\t\t\treturn search(root || document, selector);\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn query;\r\n\t}\r\n\tvar query = queryForEngine(defaultEngine, NodeList);\r\n\t/*=====\r\n\tquery = function(selector, context){\r\n\t\t// summary:\r\n\t\t//\t\tThis modules provides DOM querying functionality. The module export is a function\r\n\t\t//\t\tthat can be used to query for DOM nodes by CSS selector and returns a NodeList\r\n\t\t//\t\trepresenting the matching nodes.\r\n\t\t// selector: String\r\n\t\t//\t\tA CSS selector to search for.\r\n\t\t// context: String|DomNode?\r\n\t\t//\t\tAn optional context to limit the searching scope. Only nodes under `context` will be\r\n\t\t//\t\tscanned.\r\n\t\t// example:\r\n\t\t//\t\tadd an onclick handler to every submit button in the document\r\n\t\t//\t\twhich causes the form to be sent via Ajax instead:\r\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/request\", \"dojo/dom-form\", \"dojo/dom-construct\", \"dojo/dom-style\"\r\n\t\t//\t|\t], function(query, request, domForm, domConstruct, domStyle){\r\n\t\t//\t|\t\tquery(\"input[type='submit']\").on(\"click\", function(e){\r\n\t\t//\t|\t\t\te.preventDefault(); // prevent sending the form\r\n\t\t//\t|\t\t\tvar btn = e.target;\r\n\t\t//\t|\t\t\trequest.post(\"http://example.com/\", {\r\n\t\t//\t|\t\t\t\tdata: domForm.toObject(btn.form)\r\n\t\t//\t|\t\t\t}).then(function(response){\r\n\t\t//\t|\t\t\t\t// replace the form with the response\r\n\t\t//\t|\t\t\t\tdomConstruct.create(div, {innerHTML: response}, btn.form, \"after\");\r\n\t\t//\t|\t\t\t\tdomStyle.set(btn.form, \"display\", \"none\");\r\n\t\t//\t|\t\t\t});\r\n\t\t//\t|\t\t});\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tdojo/query is responsible for loading the appropriate query engine and wrapping\r\n\t\t//\t\tits results with a `NodeList`. You can use dojo/query with a specific selector engine\r\n\t\t//\t\tby using it as a plugin. For example, if you installed the sizzle package, you could\r\n\t\t//\t\tuse it as the selector engine with:\r\n\t\t//\t\t|\trequire([\"dojo/query!sizzle\"], function(query){\r\n\t\t//\t\t|\t\tquery(\"div\")...\r\n\t\t//\r\n\t\t//\t\tThe id after the ! can be a module id of the selector engine or one of the following values:\r\n\t\t//\r\n\t\t//\t\t- acme: This is the default engine used by Dojo base, and will ensure that the full\r\n\t\t//\t\tAcme engine is always loaded.\r\n\t\t//\r\n\t\t//\t\t- css2: If the browser has a native selector engine, this will be used, otherwise a\r\n\t\t//\t\tvery minimal lightweight selector engine will be loaded that can do simple CSS2 selectors\r\n\t\t//\t\t(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)\r\n\t\t//\t\toperators) and nothing more.\r\n\t\t//\r\n\t\t//\t\t- css2.1: If the browser has a native selector engine, this will be used, otherwise the\r\n\t\t//\t\tfull Acme engine will be loaded.\r\n\t\t//\r\n\t\t//\t\t- css3: If the browser has a native selector engine with support for CSS3 pseudo\r\n\t\t//\t\tselectors (most modern browsers except IE8), this will be used, otherwise the\r\n\t\t//\t\tfull Acme engine will be loaded.\r\n\t\t//\r\n\t\t//\t\t- Or the module id of a selector engine can be used to explicitly choose the selector engine\r\n\t\t//\r\n\t\t//\t\tFor example, if you are using CSS3 pseudo selectors in module, you can specify that\r\n\t\t//\t\tyou will need support them with:\r\n\t\t//\t\t|\trequire([\"dojo/query!css3\"], function(query){\r\n\t\t//\t\t|\t\tquery('#t > h3:nth-child(odd)')...\r\n\t\t//\r\n\t\t//\t\tYou can also choose the selector engine/load configuration by setting the query-selector:\r\n\t\t//\t\tFor example:\r\n\t\t//\t\t|\t<script data-dojo-config=\"query-selector:'css3'\" src=\"dojo.js\"></script>\r\n\t\t//\r\n\t\treturn new NodeList(); // dojo/NodeList\r\n\t };\r\n\t =====*/\r\n\r\n\t// the query that is returned from this module is slightly different than dojo.query,\r\n\t// because dojo.query has to maintain backwards compatibility with returning a\r\n\t// true array which has performance problems. The query returned from the module\r\n\t// does not use true arrays, but rather inherits from Array, making it much faster to\r\n\t// instantiate.\r\n\tdojo.query = queryForEngine(defaultEngine, function(array){\r\n\t\t// call it without the new operator to invoke the back-compat behavior that returns a true array\r\n\t\treturn NodeList(array);\t// dojo/NodeList\r\n\t});\r\n\r\n\r\n\tif (require.isBrowser===false) { // for build,will be changed with better implementation. by LWF\r\n\t\tquery.load = function (name, req, onLoad, config) {\r\n\t        onLoad();\r\n\t    };\t\t\r\n\t} else {\r\n\t\tquery.load = function(id, parentRequire, loaded){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcan be used as AMD plugin to conditionally load new query engine\r\n\t\t\t// example:\r\n\t\t\t//\t|\trequire([\"dojo/query!custom\"], function(qsa){\r\n\t\t\t//\t|\t\t// loaded selector/custom.js as engine\r\n\t\t\t//\t|\t\tqsa(\"#foobar\").forEach(...);\r\n\t\t\t//\t|\t});\r\n\t\t\tloader.load(id, parentRequire, function(engine){\r\n\t\t\t\tloaded(queryForEngine(engine, NodeList));\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tdojo._filterQueryResult = query._filterResult = function(nodes, selector, root){\r\n\t\treturn new NodeList(query.filter(nodes, selector, root));\r\n\t};\r\n\tdojo.NodeList = query.NodeList = NodeList;\r\n\treturn query;\r\n});\r\n"]}