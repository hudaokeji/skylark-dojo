{"version":3,"sources":["html.js"],"names":["define","kernel","lang","darray","declare","dom","domConstruct","parser","idCounter","html","_secureForInnerHtml","cont","replace","_emptyNode","empty","_setNodeContent","node","toDom","ownerDocument","nodeType","isArrayLike","startlen","length","i","place","_ContentSetter","content","id","cleanContent","extractContent","parseContent","parserScope","_scopeName","startup","constructor","params","mixin","this","byId","tagName","join","set","undefined","_mixin","onBegin","setContent","ret","onEnd","then","Error","declaredClass","e","errMess","onContentError","innerHTML","console","error","message","parseDeferred","isResolved","cancel","parseResults","forEach","w","destroy","isString","match","_parse","tearDown","err","onExecError","key","rootNode","inherited","name","self","parse","noStart","scope","results","_onError","type","consoleText","errText","call","warn","setObject"],"mappings":"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","file":"../html.js","sourcesContent":["define([\"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/declare\", \"./dom\", \"./dom-construct\", \"./parser\"],\r\n\tfunction(kernel, lang, darray, declare, dom, domConstruct, parser){\r\n\t// module:\r\n\t//\t\tdojo/html\r\n\r\n\t// the parser might be needed..\r\n\r\n\t// idCounter is incremented with each instantiation to allow assignment of a unique id for tracking, logging purposes\r\n\tvar idCounter = 0;\r\n\r\n\tvar html = {\r\n\t\t// summary:\r\n\t\t//\t\tTODOC\r\n\r\n\t\t_secureForInnerHtml: function(/*String*/ cont){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tremoves !DOCTYPE and title elements from the html string.\r\n\t\t\t//\r\n\t\t\t//\t\tkhtml is picky about dom faults, you can't attach a style or `<title>` node as child of body\r\n\t\t\t//\t\tmust go into head, so we need to cut out those tags\r\n\t\t\t// cont:\r\n\t\t\t//\t\tAn html string for insertion into the dom\r\n\t\t\t//\r\n\t\t\treturn cont.replace(/(?:\\s*<!DOCTYPE\\s[^>]+>|<title[^>]*>[\\s\\S]*?<\\/title>)/ig, \"\"); // String\r\n\t\t},\r\n\r\n\t\t// Deprecated, should use dojo/dom-constuct.empty() directly, remove in 2.0.\r\n\t\t_emptyNode: domConstruct.empty,\r\n\r\n\t\t_setNodeContent: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tinserts the given content into the given node\r\n\t\t\t// node:\r\n\t\t\t//\t\tthe parent element\r\n\t\t\t// content:\r\n\t\t\t//\t\tthe content to be set on the parent element.\r\n\t\t\t//\t\tThis can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes\r\n\r\n\t\t\t// always empty\r\n\t\t\tdomConstruct.empty(node);\r\n\r\n\t\t\tif(cont){\r\n\t\t\t\tif(typeof cont == \"string\"){\r\n\t\t\t\t\tcont = domConstruct.toDom(cont, node.ownerDocument);\r\n\t\t\t\t}\r\n\t\t\t\tif(!cont.nodeType && lang.isArrayLike(cont)){\r\n\t\t\t\t\t// handle as enumerable, but it may shrink as we enumerate it\r\n\t\t\t\t\tfor(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0){\r\n\t\t\t\t\t\tdomConstruct.place( cont[i], node, \"last\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// pass nodes, documentFragments and unknowns through to dojo.place\r\n\t\t\t\t\tdomConstruct.place(cont, node, \"last\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// return DomNode\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\t// we wrap up the content-setting operation in a object\r\n\t\t_ContentSetter: declare(\"dojo.html._ContentSetter\", null, {\r\n\t\t\t// node: DomNode|String\r\n\t\t\t//\t\tAn node which will be the parent element that we set content into\r\n\t\t\tnode: \"\",\r\n\r\n\t\t\t// content: String|DomNode|DomNode[]\r\n\t\t\t//\t\tThe content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes\r\n\t\t\tcontent: \"\",\r\n\r\n\t\t\t// id: String?\r\n\t\t\t//\t\tUsually only used internally, and auto-generated with each instance\r\n\t\t\tid: \"\",\r\n\r\n\t\t\t// cleanContent: Boolean\r\n\t\t\t//\t\tShould the content be treated as a full html document,\r\n\t\t\t//\t\tand the real content stripped of <html>, <body> wrapper before injection\r\n\t\t\tcleanContent: false,\r\n\r\n\t\t\t// extractContent: Boolean\r\n\t\t\t//\t\tShould the content be treated as a full html document,\r\n\t\t\t//\t\tand the real content stripped of `<html> <body>` wrapper before injection\r\n\t\t\textractContent: false,\r\n\r\n\t\t\t// parseContent: Boolean\r\n\t\t\t//\t\tShould the node by passed to the parser after the new content is set\r\n\t\t\tparseContent: false,\r\n\r\n\t\t\t// parserScope: String\r\n\t\t\t//\t\tFlag passed to parser.\tRoot for attribute names to search for.\t  If scopeName is dojo,\r\n\t\t\t//\t\twill search for data-dojo-type (or dojoType).  For backwards compatibility\r\n\t\t\t//\t\treasons defaults to dojo._scopeName (which is \"dojo\" except when\r\n\t\t\t//\t\tmulti-version support is used, when it will be something like dojo16, dojo20, etc.)\r\n\t\t\tparserScope: kernel._scopeName,\r\n\r\n\t\t\t// startup: Boolean\r\n\t\t\t//\t\tStart the child widgets after parsing them.\t  Only obeyed if parseContent is true.\r\n\t\t\tstartup: true,\r\n\r\n\t\t\t// lifecycle methods\r\n\t\t\tconstructor: function(/*Object*/ params, /*String|DomNode*/ node){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tProvides a configurable, extensible object to wrap the setting on content on a node\r\n\t\t\t\t//\t\tcall the set() method to actually set the content..\r\n\r\n\t\t\t\t// the original params are mixed directly into the instance \"this\"\r\n\t\t\t\tlang.mixin(this, params || {});\r\n\r\n\t\t\t\t// give precedence to params.node vs. the node argument\r\n\t\t\t\t// and ensure its a node, not an id string\r\n\t\t\t\tnode = this.node = dom.byId( this.node || node );\r\n\r\n\t\t\t\tif(!this.id){\r\n\t\t\t\t\tthis.id = [\r\n\t\t\t\t\t\t\"Setter\",\r\n\t\t\t\t\t\t(node) ? node.id || node.tagName : \"\",\r\n\t\t\t\t\t\tidCounter++\r\n\t\t\t\t\t].join(\"_\");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tset: function(/* String|DomNode|NodeList? */ cont, /*Object?*/ params){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tfront-end to the set-content sequence\r\n\t\t\t\t// cont:\r\n\t\t\t\t//\t\tAn html string, node or enumerable list of nodes for insertion into the dom\r\n\t\t\t\t//\t\tIf not provided, the object's content property will be used\r\n\t\t\t\tif(undefined !== cont){\r\n\t\t\t\t\tthis.content = cont;\r\n\t\t\t\t}\r\n\t\t\t\t// in the re-use scenario, set needs to be able to mixin new configuration\r\n\t\t\t\tif(params){\r\n\t\t\t\t\tthis._mixin(params);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.onBegin();\r\n\t\t\t\tthis.setContent();\r\n\r\n\t\t\t\tvar ret = this.onEnd();\r\n\r\n\t\t\t\tif(ret && ret.then){\r\n\t\t\t\t\t// Make dojox/html/_ContentSetter.set() return a Promise that resolves when load and parse complete.\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// Vanilla dojo/html._ContentSetter.set() returns a DOMNode for back compat.   For 2.0, switch it to\r\n\t\t\t\t\t// return a Deferred like above.\r\n\t\t\t\t\treturn this.node;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsetContent: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tsets the content on the node\r\n\r\n\t\t\t\tvar node = this.node;\r\n\t\t\t\tif(!node){\r\n\t\t\t\t\t// can't proceed\r\n\t\t\t\t\tthrow new Error(this.declaredClass + \": setContent given no node\");\r\n\t\t\t\t}\r\n\t\t\t\ttry{\r\n\t\t\t\t\tnode = html._setNodeContent(node, this.content);\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\t// check if a domfault occurs when we are appending this.errorMessage\r\n\t\t\t\t\t// like for instance if domNode is a UL and we try append a DIV\r\n\r\n\t\t\t\t\t// FIXME: need to allow the user to provide a content error message string\r\n\t\t\t\t\tvar errMess = this.onContentError(e);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tnode.innerHTML = errMess;\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tconsole.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// always put back the node for the next method\r\n\t\t\t\tthis.node = node; // DomNode\r\n\t\t\t},\r\n\r\n\t\t\tempty: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tcleanly empty out existing content\r\n\r\n\t\t\t\t// If there is a parse in progress, cancel it.\r\n\t\t\t\tif(this.parseDeferred){\r\n\t\t\t\t\tif(!this.parseDeferred.isResolved()){\r\n\t\t\t\t\t\tthis.parseDeferred.cancel();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete this.parseDeferred;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// destroy any widgets from a previous run\r\n\t\t\t\t// NOTE: if you don't want this you'll need to empty\r\n\t\t\t\t// the parseResults array property yourself to avoid bad things happening\r\n\t\t\t\tif(this.parseResults && this.parseResults.length){\r\n\t\t\t\t\tdarray.forEach(this.parseResults, function(w){\r\n\t\t\t\t\t\tif(w.destroy){\r\n\t\t\t\t\t\t\tw.destroy();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tdelete this.parseResults;\r\n\t\t\t\t}\r\n\t\t\t\t// this is fast, but if you know its already empty or safe, you could\r\n\t\t\t\t// override empty to skip this step\r\n\t\t\t\tdomConstruct.empty(this.node);\r\n\t\t\t},\r\n\r\n\t\t\tonBegin: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tCalled after instantiation, but before set();\r\n\t\t\t\t//\t\tIt allows modification of any of the object properties -\r\n\t\t\t\t//\t\tincluding the node and content provided - before the set operation actually takes place\r\n\t\t\t\t//\t\tThis default implementation checks for cleanContent and extractContent flags to\r\n\t\t\t\t//\t\toptionally pre-process html string content\r\n\t\t\t\tvar cont = this.content;\r\n\r\n\t\t\t\tif(lang.isString(cont)){\r\n\t\t\t\t\tif(this.cleanContent){\r\n\t\t\t\t\t\tcont = html._secureForInnerHtml(cont);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(this.extractContent){\r\n\t\t\t\t\t\tvar match = cont.match(/<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im);\r\n\t\t\t\t\t\tif(match){ cont = match[1]; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// clean out the node and any cruft associated with it - like widgets\r\n\t\t\t\tthis.empty();\r\n\r\n\t\t\t\tthis.content = cont;\r\n\t\t\t\treturn this.node; // DomNode\r\n\t\t\t},\r\n\r\n\t\t\tonEnd: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tCalled after set(), when the new content has been pushed into the node\r\n\t\t\t\t//\t\tIt provides an opportunity for post-processing before handing back the node to the caller\r\n\t\t\t\t//\t\tThis default implementation checks a parseContent flag to optionally run the dojo parser over the new content\r\n\t\t\t\tif(this.parseContent){\r\n\t\t\t\t\t// populates this.parseResults and this.parseDeferred if you need those..\r\n\t\t\t\t\tthis._parse();\r\n\t\t\t\t}\r\n\t\t\t\treturn this.node; // DomNode\r\n\t\t\t\t// TODO: for 2.0 return a Promise indicating that the parse completed.\r\n\t\t\t},\r\n\r\n\t\t\ttearDown: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tmanually reset the Setter instance if its being re-used for example for another set()\r\n\t\t\t\t// description:\r\n\t\t\t\t//\t\ttearDown() is not called automatically.\r\n\t\t\t\t//\t\tIn normal use, the Setter instance properties are simply allowed to fall out of scope\r\n\t\t\t\t//\t\tbut the tearDown method can be called to explicitly reset this instance.\r\n\t\t\t\tdelete this.parseResults;\r\n\t\t\t\tdelete this.parseDeferred;\r\n\t\t\t\tdelete this.node;\r\n\t\t\t\tdelete this.content;\r\n\t\t\t},\r\n\r\n\t\t\tonContentError: function(err){\r\n\t\t\t\treturn \"Error occurred setting content: \" + err;\r\n\t\t\t},\r\n\r\n\t\t\tonExecError: function(err){\r\n\t\t\t\treturn \"Error occurred executing scripts: \" + err;\r\n\t\t\t},\r\n\r\n\t\t\t_mixin: function(params){\r\n\t\t\t\t// mix properties/methods into the instance\r\n\t\t\t\t// TODO: the intention with tearDown is to put the Setter's state\r\n\t\t\t\t// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)\r\n\t\t\t\t// so we could do something here to move the original properties aside for later restoration\r\n\t\t\t\tvar empty = {}, key;\r\n\t\t\t\tfor(key in params){\r\n\t\t\t\t\tif(key in empty){ continue; }\r\n\t\t\t\t\t// TODO: here's our opportunity to mask the properties we don't consider configurable/overridable\r\n\t\t\t\t\t// .. but history shows we'll almost always guess wrong\r\n\t\t\t\t\tthis[key] = params[key];\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_parse: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\truns the dojo parser over the node contents, storing any results in this.parseResults\r\n\t\t\t\t//\t\tand the parse promise in this.parseDeferred\r\n\t\t\t\t//\t\tAny errors resulting from parsing are passed to _onError for handling\r\n\r\n\t\t\t\tvar rootNode = this.node;\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// store the results (widgets, whatever) for potential retrieval\r\n\t\t\t\t\tvar inherited = {};\r\n\t\t\t\t\tdarray.forEach([\"dir\", \"lang\", \"textDir\"], function(name){\r\n\t\t\t\t\t\tif(this[name]){\r\n\t\t\t\t\t\t\tinherited[name] = this[name];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t\tvar self = this;\r\n\t\t\t\t\tthis.parseDeferred = parser.parse({\r\n\t\t\t\t\t\trootNode: rootNode,\r\n\t\t\t\t\t\tnoStart: !this.startup,\r\n\t\t\t\t\t\tinherited: inherited,\r\n\t\t\t\t\t\tscope: this.parserScope\r\n\t\t\t\t\t}).then(function(results){\r\n\t\t\t\t\t\t\treturn self.parseResults = results;\r\n\t\t\t\t\t\t}, function(e){\r\n\t\t\t\t\t\t\tself._onError('Content', e, \"Error parsing in _ContentSetter#\" + this.id);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\tthis._onError('Content', e, \"Error parsing in _ContentSetter#\" + this.id);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t_onError: function(type, err, consoleText){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tshows user the string that is returned by on[type]Error\r\n\t\t\t\t//\t\toverride/implement on[type]Error and return your own string to customize\r\n\t\t\t\tvar errText = this['on' + type + 'Error'].call(this, err);\r\n\t\t\t\tif(consoleText){\r\n\t\t\t\t\tconsole.error(consoleText, err);\r\n\t\t\t\t}else if(errText){ // a empty string won't change current content\r\n\t\t\t\t\thtml._setNodeContent(this.node, errText, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}), // end declare()\r\n\r\n\t\tset: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont, /*Object?*/ params){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tinserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, \"only\")\r\n\t\t\t//\t\tmay be a better choice for simple HTML insertion.\r\n\t\t\t// description:\r\n\t\t\t//\t\tUnless you need to use the params capabilities of this method, you should use\r\n\t\t\t//\t\tdojo/dom-construct.place(cont, node, \"only\"). dojo/dom-construct..place() has more robust support for injecting\r\n\t\t\t//\t\tan HTML string into the DOM, but it only handles inserting an HTML string as DOM\r\n\t\t\t//\t\telements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions\r\n\t\t\t//\t\tdojo/dom-construct.place(cont, node, \"only\"). dojo/dom-construct.place() has more robust support for injecting\r\n\t\t\t//\t\tan HTML string into the DOM, but it only handles inserting an HTML string as DOM\r\n\t\t\t//\t\telements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions\r\n\t\t\t//\t\tor the other capabilities as defined by the params object for this method.\r\n\t\t\t// node:\r\n\t\t\t//\t\tthe parent element that will receive the content\r\n\t\t\t// cont:\r\n\t\t\t//\t\tthe content to be set on the parent element.\r\n\t\t\t//\t\tThis can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes\r\n\t\t\t// params:\r\n\t\t\t//\t\tOptional flags/properties to configure the content-setting. See dojo/html/_ContentSetter\r\n\t\t\t// example:\r\n\t\t\t//\t\tA safe string/node/nodelist content replacement/injection with hooks for extension\r\n\t\t\t//\t\tExample Usage:\r\n\t\t\t//\t|\thtml.set(node, \"some string\");\r\n\t\t\t//\t|\thtml.set(node, contentNode, {options});\r\n\t\t\t//\t|\thtml.set(node, myNode.childNodes, {options});\r\n\t\t\tif(undefined == cont){\r\n\t\t\t\tconsole.warn(\"dojo.html.set: no cont argument provided, using empty string\");\r\n\t\t\t\tcont = \"\";\r\n\t\t\t}\r\n\t\t\tif(!params){\r\n\t\t\t\t// simple and fast\r\n\t\t\t\treturn html._setNodeContent(node, cont, true);\r\n\t\t\t}else{\r\n\t\t\t\t// more options but slower\r\n\t\t\t\t// note the arguments are reversed in order, to match the convention for instantiation via the parser\r\n\t\t\t\tvar op = new html._ContentSetter(lang.mixin(\r\n\t\t\t\t\tparams,\r\n\t\t\t\t\t{ content: cont, node: node }\r\n\t\t\t\t));\r\n\t\t\t\treturn op.set();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tlang.setObject(\"dojo.html\", html);\r\n\r\n\treturn html;\r\n});\r\n"]}