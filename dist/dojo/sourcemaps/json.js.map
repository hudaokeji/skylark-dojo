{"version":3,"sources":["json.js"],"names":["define","has","hasJSON","JSON","add","stringify","a","k","v","escapeString","str","replace","parse","strict","test","SyntaxError","eval","value","replacer","spacer","undef","it","indent","key","val","objtype","isFinite","toJSON","Date","t","prop","plus","num","valueOf","nextIndent","sep","newLine","Array","itl","length","res","push","join","output","keyStr","hasOwnProperty"],"mappings":";;;;;;;AAAAA,QAAQ,SAAU,SAASC,KAC1B,aACA,IAAIC,QAAyB,oBAARC,KAmDrB,GAlDAF,IAAIG,IAAI,aAAcF,SAEtBD,IAAIG,IAAI,iBAAkBF,SAAiE,WAAtDC,KAAKE,WAAWC,EAAE,GAAI,SAASC,EAAEC,GAAG,OAAOA,GAAG,KAgDhFP,IAAI,kBACN,OAAOE,KAEP,IAAIM,aAAe,SAAmBC,GAKrC,OAAQ,IAAMA,EAAIC,QAAQ,WAAY,QAAU,KAC/CA,QAAQ,QAAS,OAAOA,QAAQ,QAAS,OAAOA,QAAQ,QAAS,OACjEA,QAAQ,QAAS,OAAOA,QAAQ,QAAS,QAE3C,OACCC,MAAOX,IAAI,cAAgBE,KAAKS,MAAQ,SAASF,IAAKG,QACrD,GAAGA,SAAW,oGAAoGC,KAAKJ,KACtH,MAAM,IAAIK,YAAY,8BAEvB,OAAOC,KAAK,IAAMN,IAAM,MAEzBL,UAAW,SAASY,EAAOC,EAAUC,GACpC,IAAIC,EAoFJ,MAnFsB,iBAAZF,IACTC,EAASD,EACTA,EAAW,MAEZ,SAASb,EAAUgB,EAAIC,EAAQC,GAC3BL,IACFG,EAAKH,EAASK,EAAKF,IAEpB,IAAIG,EAAKC,SAAiBJ,EAC1B,GAAc,UAAXI,EACF,OAAOC,SAASL,GAAMA,EAAK,GAAK,OAEjC,GAAc,WAAXI,EACF,OAAOJ,EAAK,GAEb,GAAU,OAAPA,EACF,MAAO,OAER,GAAgB,iBAANA,EACT,OAAOZ,aAAaY,GAErB,GAAc,YAAXI,GAAoC,aAAXA,EAC3B,OAAOL,EAIR,GAAuB,mBAAbC,EAAGM,OACZ,OAAOtB,EAAUgB,EAAGM,OAAOJ,GAAMD,EAAQC,GAE1C,GAAGF,aAAcO,KAChB,MAAO,4DAA4DjB,QAAQ,kBAAmB,SAASkB,EAAGC,EAAMC,GAC/G,IAAIC,EAAMX,EAAG,SAAWS,MAAWC,EAAO,EAAI,GAC9C,OAAOC,EAAM,GAAK,IAAMA,EAAMA,IAGhC,GAAGX,EAAGY,YAAcZ,EAEnB,OAAOhB,EAAUgB,EAAGY,UAAWX,EAAQC,GAExC,IAAIW,EAAYf,EAAUG,EAASH,EAAU,GAGzCgB,EAAMhB,EAAS,IAAM,GACrBiB,EAAUjB,EAAS,KAAO,GAG9B,GAAGE,aAAcgB,MAAM,CACtB,IAAIC,EAAMjB,EAAGkB,OAAQC,KACrB,IAAIjB,EAAM,EAAGA,EAAMe,EAAKf,IAGN,iBADjBC,EAAMnB,EADIgB,EAAGE,GACQW,EAAYX,MAEhCC,EAAM,QAEPgB,EAAIC,KAAKL,EAAUF,EAAaV,GAEjC,MAAO,IAAMgB,EAAIE,KAAK,KAAON,EAAUd,EAAS,IAGjD,IAAIqB,KACJ,IAAIpB,KAAOF,EAAG,CACb,IAAIuB,EACJ,GAAGvB,EAAGwB,eAAetB,GAAK,CACzB,GAAiB,iBAAPA,EACTqB,EAAS,IAAMrB,EAAM,QAChB,CAAA,GAAiB,iBAAPA,EAIf,SAHAqB,EAASnC,aAAac,GAMvB,GAAiB,iBADjBC,EAAMnB,EAAUgB,EAAGE,GAAMW,EAAYX,IAGpC,SAIDoB,EAAOF,KAAKL,EAAUF,EAAaU,EAAS,IAAMT,EAAMX,IAG1D,MAAO,IAAMmB,EAAOD,KAAK,KAAON,EAAUd,EAAS,IAE7CjB,CAAUY,EAAO,GAAI","file":"../json.js","sourcesContent":["define([\"./has\"], function(has){\r\n\t\"use strict\";\r\n\tvar hasJSON = typeof JSON != \"undefined\";\r\n\thas.add(\"json-parse\", hasJSON); // all the parsers work fine\r\n\t\t// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\r\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}');\r\n\r\n\t/*=====\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tFunctions to parse and serialize JSON\r\n\r\n\t\tparse: function(str, strict){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tParses a [JSON](http://json.org) string to return a JavaScript object.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\r\n\t\t\t//\t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\r\n\t\t\t//\t\tsupport is not available. By default this will evaluate any valid JS expression.\r\n\t\t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\r\n\t\t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\r\n\t\t\t//\t\tparameter, the content passed to this method must come\r\n\t\t\t//\t\tfrom a trusted source.\r\n\t\t\t// str:\r\n\t\t\t//\t\ta string literal of a JSON item, for instance:\r\n\t\t\t//\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\r\n\t\t\t// strict:\r\n\t\t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\r\n\t\t\t//\t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\r\n\t\t\t//\t\twithout native JSON support, setting this to true will run slower.\r\n\t\t},\r\n\t\tstringify: function(value, replacer, spacer){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\r\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\r\n\t\t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\r\n\t\t\t// value:\r\n\t\t\t//\t\tA value to be serialized.\r\n\t\t\t// replacer:\r\n\t\t\t//\t\tA replacer function that is called for each value and can return a replacement\r\n\t\t\t// spacer:\r\n\t\t\t//\t\tA spacer string to be used for pretty printing of JSON\r\n\t\t\t// example:\r\n\t\t\t//\t\tsimple serialization of a trivial object\r\n\t\t\t//\t|\tdefine([\"dojo/json\"], function(JSON){\r\n\t\t\t// \t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\r\n\t\t\t//\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\r\n\t\t}\r\n\t};\r\n\t=====*/\r\n\r\n\tif(has(\"json-stringify\")){\r\n\t\treturn JSON;\r\n\t}else{\r\n\t\tvar escapeString = function(/*String*/str){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds escape sequences for non-visual characters, double quote and\r\n\t\t\t//\t\tbackslash and surrounds with double quotes to form a valid string\r\n\t\t\t//\t\tliteral.\r\n\t\t\treturn ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').\r\n\t\t\t\treplace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").\r\n\t\t\t\treplace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\r\n\t\t};\r\n\t\treturn {\r\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\r\n\t\t\t\tif(strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])*\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)){\r\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\r\n\t\t\t\t}\r\n\t\t\t\treturn eval('(' + str + ')');\r\n\t\t\t},\r\n\t\t\tstringify: function(value, replacer, spacer){\r\n\t\t\t\tvar undef;\r\n\t\t\t\tif(typeof replacer == \"string\"){\r\n\t\t\t\t\tspacer = replacer;\r\n\t\t\t\t\treplacer = null;\r\n\t\t\t\t}\r\n\t\t\t\tfunction stringify(it, indent, key){\r\n\t\t\t\t\tif(replacer){\r\n\t\t\t\t\t\tit = replacer(key, it);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar val, objtype = typeof it;\r\n\t\t\t\t\tif(objtype == \"number\"){\r\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(objtype == \"boolean\"){\r\n\t\t\t\t\t\treturn it + \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it === null){\r\n\t\t\t\t\t\treturn \"null\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(typeof it == \"string\"){\r\n\t\t\t\t\t\treturn escapeString(it);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\r\n\t\t\t\t\t\treturn undef; // undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// short-circuit for objects that support \"json\" serialization\r\n\t\t\t\t\t// if they return \"self\" then just pass-through...\r\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\r\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it instanceof Date){\r\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function(t, prop, plus){\r\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\r\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it.valueOf() !== it){\r\n\t\t\t\t\t\t// primitive wrapper, try again unwrapped:\r\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\r\n\t\t\t\t\t/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ \r\n\t\t\t\t\r\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\r\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\r\n\t\t\t\t\r\n\t\t\t\t\t// array\r\n\t\t\t\t\tif(it instanceof Array){\r\n\t\t\t\t\t\tvar itl = it.length, res = [];\r\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\r\n\t\t\t\t\t\t\tvar obj = it[key];\r\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\r\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\t\tval = \"null\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// generic object code path\r\n\t\t\t\t\tvar output = [];\r\n\t\t\t\t\tfor(key in it){\r\n\t\t\t\t\t\tvar keyStr;\r\n\t\t\t\t\t\tif(it.hasOwnProperty(key)){\r\n\t\t\t\t\t\t\tif(typeof key == \"number\"){\r\n\t\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\r\n\t\t\t\t\t\t\t}else if(typeof key == \"string\"){\r\n\t\t\t\t\t\t\t\tkeyStr = escapeString(key);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t// skip non-string or number keys\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\r\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\t\t// skip non-serializable values\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// At this point, the most non-IE browsers don't get in this branch \r\n\t\t\t\t\t\t\t// (they have native JSON), so push is definitely the way to\r\n\t\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\r\n\t\t\t\t}\r\n\t\t\t\treturn stringify(value, \"\", \"\");\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\n"]}