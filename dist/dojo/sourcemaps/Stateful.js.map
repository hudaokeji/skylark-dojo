{"version":3,"sources":["Stateful.js"],"names":["define","declare","lang","array","when","_attrPairNames","_getAttrNames","name","apn","this","s","g","postscript","params","set","_get","names","get","value","x","hasOwnProperty","result","oldValue","setter","apply","Array","prototype","slice","call","arguments","_watchCallbacks","self","_changeAttrValue","watch","callback","callbacks","ignoreCatchall","notify","propertyCallbacks","i","l","length","push","handle","unwatch","remove","index","indexOf","splice"],"mappings":";;;;;;;AAAAA,QAAQ,kBAAmB,eAAgB,gBAAiB,UAAW,SAASC,EAASC,EAAMC,EAAOC,GAItG,OAAOH,EAAQ,gBAAiB,MAwB/BI,kBAEAC,cAAe,SAASC,GAOvB,IAAIC,EAAMC,KAAKJ,eACf,OAAGG,EAAID,GAAeC,EAAID,GAClBC,EAAID,IACXG,EAAG,IAAMH,EAAO,SAChBI,EAAG,IAAMJ,EAAO,WAIlBK,WAAY,SAAqBC,GAE5BA,GAASJ,KAAKK,IAAID,IAGvBE,KAAM,SAASR,EAAMS,GAKpB,MAAgC,mBAAlBP,KAAKO,EAAML,GAAoBF,KAAKO,EAAML,KAAOF,KAAKF,IAErEU,IAAK,SAAmBV,GAkBvB,OAAOE,KAAKM,KAAKR,EAAME,KAAKH,cAAcC,KAE3CO,IAAK,SAAmBP,EAAgBW,GA4BvC,GAAmB,iBAATX,EAAkB,CAC3B,IAAI,IAAIY,KAAKZ,EACTA,EAAKa,eAAeD,IAAU,mBAAJA,GAC5BV,KAAKK,IAAIK,EAAGZ,EAAKY,IAGnB,OAAOV,KAGR,IAGCY,EAHGL,EAAQP,KAAKH,cAAcC,GAC9Be,EAAWb,KAAKM,KAAKR,EAAMS,GAC3BO,EAASd,KAAKO,EAAMN,GASrB,GAPqB,mBAAXa,EAETF,EAASE,EAAOC,MAAMf,KAAMgB,MAAMC,UAAUC,MAAMC,KAAKC,UAAW,IAGlEpB,KAAKF,GAAQW,EAEXT,KAAKqB,gBAAgB,CACvB,IAAIC,EAAOtB,KAEXL,EAAKiB,EAAQ,WACZU,EAAKD,gBAAgBvB,EAAMe,EAAUJ,KAGvC,OAAOT,MAERuB,iBAAkB,SAASzB,EAAMW,GAehC,IAAII,EAAWb,KAAKQ,IAAIV,GAKxB,OAJAE,KAAKF,GAAQW,EACVT,KAAKqB,iBACPrB,KAAKqB,gBAAgBvB,EAAMe,EAAUJ,GAE/BT,MAERwB,MAAO,SAAoB1B,EAAkB2B,GAiB5C,IAAIC,EAAY1B,KAAKqB,gBACrB,IAAIK,EAAU,CACb,IAAIJ,EAAOtB,KACX0B,EAAY1B,KAAKqB,gBAAkB,SAASvB,EAAMe,EAAUJ,EAAOkB,GAClE,IAAIC,EAAS,SAASC,GACrB,GAAGA,EAEF,IAAI,IAAIC,EAAI,EAAGC,GADfF,EAAoBA,EAAkBX,SACDc,OAAQF,EAAIC,EAAGD,IACnDD,EAAkBC,GAAGX,KAAKG,EAAMxB,EAAMe,EAAUJ,IAInDmB,EAAOF,EAAU,IAAM5B,IACnB6B,GACHC,EAAOF,EAAU,OAIhBD,GAA4B,mBAAT3B,EAKtBA,EAAO,IAAMA,GAJb2B,EAAW3B,EACXA,EAAO,KAKR,IAAI+B,EAAoBH,EAAU5B,GACF,iBAAtB+B,IACTA,EAAoBH,EAAU5B,OAE/B+B,EAAkBI,KAAKR,GAGvB,IAAIS,KAOJ,OANAA,EAAOC,QAAUD,EAAOE,OAAS,WAChC,IAAIC,EAAQ3C,EAAM4C,QAAQT,EAAmBJ,GAC1CY,GAAS,GACXR,EAAkBU,OAAOF,EAAO,IAG3BH","file":"../Stateful.js","sourcesContent":["define([\"./_base/declare\", \"./_base/lang\", \"./_base/array\", \"./when\"], function(declare, lang, array, when){\r\n\t// module:\r\n\t//\t\tdojo/Stateful\r\n\r\nreturn declare(\"dojo.Stateful\", null, {\r\n\t// summary:\r\n\t//\t\tBase class for objects that provide named properties with optional getter/setter\r\n\t//\t\tcontrol and the ability to watch for property changes\r\n\t//\r\n\t//\t\tThe class also provides the functionality to auto-magically manage getters\r\n\t//\t\tand setters for object attributes/properties.\r\n\t//\t\t\r\n\t//\t\tGetters and Setters should follow the format of _xxxGetter or _xxxSetter where \r\n\t//\t\tthe xxx is a name of the attribute to handle.  So an attribute of \"foo\" \r\n\t//\t\twould have a custom getter of _fooGetter and a custom setter of _fooSetter.\r\n\t//\r\n\t// example:\r\n\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\r\n\t//\t|\t\tvar obj = new Stateful();\r\n\t//\t|\t\tobj.watch(\"foo\", function(){\r\n\t//\t|\t\t\tconsole.log(\"foo changed to \" + this.get(\"foo\"));\r\n\t//\t|\t\t});\r\n\t//\t|\t\tobj.set(\"foo\",\"bar\");\r\n\t//\t|\t});\r\n\r\n\t// _attrPairNames: Hash\r\n\t//\t\tUsed across all instances a hash to cache attribute names and their getter \r\n\t//\t\tand setter names.\r\n\t_attrPairNames: {},\r\n\r\n\t_getAttrNames: function(name){\r\n\t\t// summary:\r\n\t\t//\t\tHelper function for get() and set().\r\n\t\t//\t\tCaches attribute name values so we don't do the string ops every time.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\r\n\t\tvar apn = this._attrPairNames;\r\n\t\tif(apn[name]){ return apn[name]; }\r\n\t\treturn (apn[name] = {\r\n\t\t\ts: \"_\" + name + \"Setter\",\r\n\t\t\tg: \"_\" + name + \"Getter\"\r\n\t\t});\r\n\t},\r\n\r\n\tpostscript: function(/*Object?*/ params){\r\n\t\t// Automatic setting of params during construction\r\n\t\tif (params){ this.set(params); }\r\n\t},\r\n\r\n\t_get: function(name, names){\r\n\t\t// summary:\r\n\t\t//\t\tPrivate function that does a get based off a hash of names\r\n\t\t// names:\r\n\t\t//\t\tHash of names of custom attributes\r\n\t\treturn typeof this[names.g] === \"function\" ? this[names.g]() : this[name];\r\n\t},\r\n\tget: function(/*String*/name){\r\n\t\t// summary:\r\n\t\t//\t\tGet a property on a Stateful instance.\r\n\t\t// name:\r\n\t\t//\t\tThe property to get.\r\n\t\t// returns:\r\n\t\t//\t\tThe property value on this Stateful instance.\r\n\t\t// description:\r\n\t\t//\t\tGet a named property on a Stateful object. The property may\r\n\t\t//\t\tpotentially be retrieved via a getter method in subclasses. In the base class\r\n\t\t//\t\tthis just retrieves the object's property.\r\n\t\t// example:\r\n\t\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\r\n\t\t//\t|\t\tvar stateful = new Stateful({foo: 3});\r\n\t\t//\t|\t\tstateful.get(\"foo\") // returns 3\r\n\t\t//\t|\t\tstateful.foo // returns 3\r\n\t\t//\t|\t});\r\n\r\n\t\treturn this._get(name, this._getAttrNames(name)); //Any\r\n\t},\r\n\tset: function(/*String*/name, /*Object*/value){\r\n\t\t// summary:\r\n\t\t//\t\tSet a property on a Stateful instance\r\n\t\t// name:\r\n\t\t//\t\tThe property to set.\r\n\t\t// value:\r\n\t\t//\t\tThe value to set in the property.\r\n\t\t// returns:\r\n\t\t//\t\tThe function returns this dojo.Stateful instance.\r\n\t\t// description:\r\n\t\t//\t\tSets named properties on a stateful object and notifies any watchers of\r\n\t\t//\t\tthe property. A programmatic setter may be defined in subclasses.\r\n\t\t// example:\r\n\t\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\r\n\t\t//\t|\t\tvar stateful = new Stateful();\r\n\t\t//\t|\t\tstateful.watch(function(name, oldValue, value){\r\n\t\t//\t|\t\t\t// this will be called on the set below\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t\tstateful.set(foo, 5);\r\n\t\t//\tset() may also be called with a hash of name/value pairs, ex:\r\n\t\t//\t|\t\tstateful.set({\r\n\t\t//\t|\t\t\tfoo: \"Howdy\",\r\n\t\t//\t|\t\t\tbar: 3\r\n\t\t//\t|\t\t});\r\n\t\t//\t|\t});\r\n\t\t//\tThis is equivalent to calling set(foo, \"Howdy\") and set(bar, 3)\r\n\r\n\t\t// If an object is used, iterate through object\r\n\t\tif(typeof name === \"object\"){\r\n\t\t\tfor(var x in name){\r\n\t\t\t\tif(name.hasOwnProperty(x) && x !=\"_watchCallbacks\"){\r\n\t\t\t\t\tthis.set(x, name[x]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar names = this._getAttrNames(name),\r\n\t\t\toldValue = this._get(name, names),\r\n\t\t\tsetter = this[names.s],\r\n\t\t\tresult;\r\n\t\tif(typeof setter === \"function\"){\r\n\t\t\t// use the explicit setter\r\n\t\t\tresult = setter.apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t}else{\r\n\t\t\t// no setter so set attribute directly\r\n\t\t\tthis[name] = value;\r\n\t\t}\r\n\t\tif(this._watchCallbacks){\r\n\t\t\tvar self = this;\r\n\t\t\t// If setter returned a promise, wait for it to complete, otherwise call watches immediately\r\n\t\t\twhen(result, function(){\r\n\t\t\t\tself._watchCallbacks(name, oldValue, value);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this; // dojo/Stateful\r\n\t},\r\n\t_changeAttrValue: function(name, value){\r\n\t\t// summary:\r\n\t\t//\t\tInternal helper for directly changing an attribute value.\r\n\t\t//\r\n\t\t// name: String\r\n\t\t//\t\tThe property to set.\r\n\t\t// value: Mixed\r\n\t\t//\t\tThe value to set in the property.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tDirectly change the value of an attribute on an object, bypassing any \r\n\t\t//\t\taccessor setter.  Also handles the calling of watch and emitting events. \r\n\t\t//\t\tIt is designed to be used by descendant class when there are two values \r\n\t\t//\t\tof attributes that are linked, but calling .set() is not appropriate.\r\n\r\n\t\tvar oldValue = this.get(name);\r\n\t\tthis[name] = value;\r\n\t\tif(this._watchCallbacks){\r\n\t\t\tthis._watchCallbacks(name, oldValue, value);\r\n\t\t}\r\n\t\treturn this; // dojo/Stateful\r\n\t},\r\n\twatch: function(/*String?*/name, /*Function*/callback){\r\n\t\t// summary:\r\n\t\t//\t\tWatches a property for changes\r\n\t\t// name:\r\n\t\t//\t\tIndicates the property to watch. This is optional (the callback may be the\r\n\t\t//\t\tonly parameter), and if omitted, all the properties will be watched\r\n\t\t// returns:\r\n\t\t//\t\tAn object handle for the watch. The unwatch method of this object\r\n\t\t//\t\tcan be used to discontinue watching this property:\r\n\t\t//\t\t|\tvar watchHandle = obj.watch(\"foo\", callback);\r\n\t\t//\t\t|\twatchHandle.unwatch(); // callback won't be called now\r\n\t\t// callback:\r\n\t\t//\t\tThe function to execute when the property changes. This will be called after\r\n\t\t//\t\tthe property has been changed. The callback will be called with the |this|\r\n\t\t//\t\tset to the instance, the first argument as the name of the property, the\r\n\t\t//\t\tsecond argument as the old value and the third argument as the new value.\r\n\r\n\t\tvar callbacks = this._watchCallbacks;\r\n\t\tif(!callbacks){\r\n\t\t\tvar self = this;\r\n\t\t\tcallbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){\r\n\t\t\t\tvar notify = function(propertyCallbacks){\r\n\t\t\t\t\tif(propertyCallbacks){\r\n\t\t\t\t\t\tpropertyCallbacks = propertyCallbacks.slice();\r\n\t\t\t\t\t\tfor(var i = 0, l = propertyCallbacks.length; i < l; i++){\r\n\t\t\t\t\t\t\tpropertyCallbacks[i].call(self, name, oldValue, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnotify(callbacks['_' + name]);\r\n\t\t\t\tif(!ignoreCatchall){\r\n\t\t\t\t\tnotify(callbacks[\"*\"]); // the catch-all\r\n\t\t\t\t}\r\n\t\t\t}; // we use a function instead of an object so it will be ignored by JSON conversion\r\n\t\t}\r\n\t\tif(!callback && typeof name === \"function\"){\r\n\t\t\tcallback = name;\r\n\t\t\tname = \"*\";\r\n\t\t}else{\r\n\t\t\t// prepend with dash to prevent name conflicts with function (like \"name\" property)\r\n\t\t\tname = '_' + name;\r\n\t\t}\r\n\t\tvar propertyCallbacks = callbacks[name];\r\n\t\tif(typeof propertyCallbacks !== \"object\"){\r\n\t\t\tpropertyCallbacks = callbacks[name] = [];\r\n\t\t}\r\n\t\tpropertyCallbacks.push(callback);\r\n\r\n\t\t// TODO: Remove unwatch in 2.0\r\n\t\tvar handle = {};\r\n\t\thandle.unwatch = handle.remove = function(){\r\n\t\t\tvar index = array.indexOf(propertyCallbacks, callback);\r\n\t\t\tif(index > -1){\r\n\t\t\t\tpropertyCallbacks.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn handle; //Object\r\n\t}\r\n\r\n});\r\n\r\n});\r\n"]}