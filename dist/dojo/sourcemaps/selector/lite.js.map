{"version":3,"sources":["selector/lite.js"],"names":["define","has","dojo","testDiv","document","createElement","matchesSelector","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","querySelectorAll","unionSplit","add","liteEngine","selector","root","combine","indexOf","doc","ownerDocument","match","exec","found","byId","getElementById","tagName","toLowerCase","parent","parentNode","getElementsByClassName","getElementsByTagName","nodeType","nodeName","useRoot","results","i","l","length","node","jsMatchesSelector","push","context","query","method","oldContext","old","getAttribute","nid","hasParent","relativeHierarchySelector","test","replace","setAttribute","selectors","join","call","removeAttribute","caseFix","selectorTypes","",".","className","classNameSpaced","#","id","attrComparators","^=","attrValue","value","*=","$=","substring","~=","|=","=","cache","and","matcher","next","t","combinator","type","attrName","attrType","name","firstChar","charAt","slice","comparator","attr","Error","indexed","String","escape","j","sourceIndex","totalResults"],"mappings":"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","file":"../../selector/lite.js","sourcesContent":["define([\"../has\", \"../_base/kernel\"], function(has, dojo){\r\n\"use strict\";\r\n\r\nvar testDiv = document.createElement(\"div\");\r\nvar matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;\r\nvar querySelectorAll = testDiv.querySelectorAll;\r\nvar unionSplit = /([^\\s,](?:\"(?:\\\\.|[^\"])+\"|'(?:\\\\.|[^'])+'|[^,])*)/g;\r\nhas.add(\"dom-matches-selector\", !!matchesSelector);\r\nhas.add(\"dom-qsa\", !!querySelectorAll); \r\n\r\n// this is a simple query engine. It has handles basic selectors, and for simple\r\n// common selectors is extremely fast\r\nvar liteEngine = function(selector, root){\r\n\t// summary:\r\n\t//\t\tA small lightweight query selector engine that implements CSS2.1 selectors\r\n\t//\t\tminus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors\r\n\r\n\tif(combine && selector.indexOf(',') > -1){\r\n\t\treturn combine(selector, root);\r\n\t}\r\n\t// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note \r\n\t// that we don't use dojo/_base/window's doc to reduce dependencies, and \r\n\t// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).\r\n\t// presumably we will have a better way to do this in 2.0 \r\n\tvar doc = root ? root.ownerDocument || root : dojo.doc || document, \r\n\t\tmatch = (querySelectorAll ? \r\n\t\t\t/^([\\w]*)#([\\w\\-]+$)|^(\\.)([\\w\\-\\*]+$)|^(\\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods\r\n\t\t\t/^([\\w]*)#([\\w\\-]+)(?:\\s+(.*))?$|(?:^|(>|.+\\s+))([\\w\\-\\*]+)(\\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering\r\n\t\t\t.exec(selector);\r\n\troot = root || doc;\r\n\tif(match){\r\n\t\t// fast path regardless of whether or not querySelectorAll exists\r\n\t\tif(match[2]){\r\n\t\t\t// an #id\r\n\t\t\t// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that\r\n\t\t\tvar found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);\r\n\t\t\tif(!found || (match[1] && match[1] != found.tagName.toLowerCase())){\r\n\t\t\t\t// if there is a tag qualifer and it doesn't match, no matches\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t\tif(root != doc){\r\n\t\t\t\t// there is a root element, make sure we are a child of it\r\n\t\t\t\tvar parent = found;\r\n\t\t\t\twhile(parent != root){\r\n\t\t\t\t\tparent = parent.parentNode;\r\n\t\t\t\t\tif(!parent){\r\n\t\t\t\t\t\treturn [];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn match[3] ?\r\n\t\t\t\t\tliteEngine(match[3], found) \r\n\t\t\t\t\t: [found];\r\n\t\t}\r\n\t\tif(match[3] && root.getElementsByClassName){\r\n\t\t\t// a .class\r\n\t\t\treturn root.getElementsByClassName(match[4]);\r\n\t\t}\r\n\t\tvar found;\r\n\t\tif(match[5]){\r\n\t\t\t// a tag\r\n\t\t\tfound = root.getElementsByTagName(match[5]);\r\n\t\t\tif(match[4] || match[6]){\r\n\t\t\t\tselector = (match[4] || \"\") + match[6];\r\n\t\t\t}else{\r\n\t\t\t\t// that was the entirety of the query, return results\r\n\t\t\t\treturn found;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(querySelectorAll){\r\n\t\t// qSA works strangely on Element-rooted queries\r\n\t\t// We can work around this by specifying an extra ID on the root\r\n\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\r\n\t\t// IE 8 doesn't work on object elements\r\n\t\tif (root.nodeType === 1 && root.nodeName.toLowerCase() !== \"object\"){\t\t\t\t\r\n\t\t\treturn useRoot(root, selector, root.querySelectorAll);\r\n\t\t}else{\r\n\t\t\t// we can use the native qSA\r\n\t\t\treturn root.querySelectorAll(selector);\r\n\t\t}\r\n\t}else if(!found){\r\n\t\t// search all children and then filter\r\n\t\tfound = root.getElementsByTagName(\"*\");\r\n\t}\r\n\t// now we filter the nodes that were found using the matchesSelector\r\n\tvar results = [];\r\n\tfor(var i = 0, l = found.length; i < l; i++){\r\n\t\tvar node = found[i];\r\n\t\tif(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){\r\n\t\t\t// keep the nodes that match the selector\r\n\t\t\tresults.push(node);\r\n\t\t}\r\n\t}\r\n\treturn results;\r\n};\r\nvar useRoot = function(context, query, method){\r\n\t// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle\r\n\tvar oldContext = context,\r\n\t\told = context.getAttribute(\"id\"),\r\n\t\tnid = old || \"__dojo__\",\r\n\t\thasParent = context.parentNode,\r\n\t\trelativeHierarchySelector = /^\\s*[+~]/.test(query);\r\n\r\n\tif(relativeHierarchySelector && !hasParent){\r\n\t\treturn [];\r\n\t}\r\n\tif(!old){\r\n\t\tcontext.setAttribute(\"id\", nid);\r\n\t}else{\r\n\t\tnid = nid.replace(/'/g, \"\\\\$&\");\r\n\t}\r\n\tif(relativeHierarchySelector && hasParent){\r\n\t\tcontext = context.parentNode;\r\n\t}\r\n\tvar selectors = query.match(unionSplit);\r\n\tfor(var i = 0; i < selectors.length; i++){\r\n\t\tselectors[i] = \"[id='\" + nid + \"'] \" + selectors[i];\r\n\t}\r\n\tquery = selectors.join(\",\");\r\n\r\n\ttry{\r\n\t\treturn method.call(context, query);\r\n\t}finally{\r\n\t\tif(!old){\r\n\t\t\toldContext.removeAttribute(\"id\");\r\n\t\t}\r\n\t}\r\n};\r\n\r\nif(!has(\"dom-matches-selector\")){\r\n\tvar jsMatchesSelector = (function(){\r\n\t\t// a JS implementation of CSS selector matching, first we start with the various handlers\r\n\t\tvar caseFix = testDiv.tagName == \"div\" ? \"toLowerCase\" : \"toUpperCase\";\r\n\t\tvar selectorTypes = {\r\n\t\t\t\"\": function(tagName){\r\n\t\t\t\ttagName = tagName[caseFix]();\r\n\t\t\t\treturn function(node){\r\n\t\t\t\t\treturn node.tagName == tagName;\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\t\".\": function(className){\r\n\t\t\t\tvar classNameSpaced = ' ' + className + ' ';\r\n\t\t\t\treturn function(node){\r\n\t\t\t\t\treturn node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\t\"#\": function(id){\r\n\t\t\t\treturn function(node){\r\n\t\t\t\t\treturn node.id == id;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar attrComparators = {\r\n\t\t\t\"^=\": function(attrValue, value){\r\n\t\t\t\treturn attrValue.indexOf(value) == 0;\r\n\t\t\t},\r\n\t\t\t\"*=\": function(attrValue, value){\r\n\t\t\t\treturn attrValue.indexOf(value) > -1;\r\n\t\t\t},\r\n\t\t\t\"$=\": function(attrValue, value){\r\n\t\t\t\treturn attrValue.substring(attrValue.length - value.length, attrValue.length) == value;\r\n\t\t\t},\r\n\t\t\t\"~=\": function(attrValue, value){\r\n\t\t\t\treturn (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;\r\n\t\t\t},\r\n\t\t\t\"|=\": function(attrValue, value){\r\n\t\t\t\treturn (attrValue + '-').indexOf(value + '-') == 0;\r\n\t\t\t},\r\n\t\t\t\"=\": function(attrValue, value){\r\n\t\t\t\treturn attrValue == value;\r\n\t\t\t},\r\n\t\t\t\"\": function(attrValue, value){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction attr(name, value, type){\r\n\t\t\tvar firstChar = value.charAt(0);\r\n\t\t\tif(firstChar == '\"' || firstChar == \"'\"){\r\n\t\t\t\t// it is quoted, remove the quotes\r\n\t\t\t\tvalue = value.slice(1, -1);\r\n\t\t\t}\r\n\t\t\tvalue = value.replace(/\\\\/g,'');\r\n\t\t\tvar comparator = attrComparators[type || \"\"];\r\n\t\t\treturn function(node){\r\n\t\t\t\tvar attrValue = node.getAttribute(name);\r\n\t\t\t\treturn attrValue && comparator(attrValue, value);\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction ancestor(matcher){\r\n\t\t\treturn function(node, root){\r\n\t\t\t\twhile((node = node.parentNode) != root){\r\n\t\t\t\t\tif(matcher(node, root)){\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction parent(matcher){\r\n\t\t\treturn function(node, root){\r\n\t\t\t\tnode = node.parentNode;\r\n\t\t\t\treturn matcher ? \r\n\t\t\t\t\tnode != root && matcher(node, root)\r\n\t\t\t\t\t: node == root;\r\n\t\t\t};\r\n\t\t}\r\n\t\tvar cache = {};\r\n\t\tfunction and(matcher, next){\r\n\t\t\treturn matcher ?\r\n\t\t\t\tfunction(node, root){\r\n\t\t\t\t\treturn next(node) && matcher(node, root);\r\n\t\t\t\t}\r\n\t\t\t\t: next;\r\n\t\t}\r\n\t\treturn function(node, selector, root){\r\n\t\t\t// this returns true or false based on if the node matches the selector (optionally within the given root)\r\n\t\t\tvar matcher = cache[selector]; // check to see if we have created a matcher function for the given selector\r\n\t\t\tif(!matcher){\r\n\t\t\t\t// create a matcher function for the given selector\r\n\t\t\t\t// parse the selectors\r\n\t\t\t\tif(selector.replace(/(?:\\s*([> ])\\s*)|(#|\\.)?((?:\\\\.|[\\w-])+)|\\[\\s*([\\w-]+)\\s*(.?=)?\\s*(\"(?:\\\\.|[^\"])+\"|'(?:\\\\.|[^'])+'|(?:\\\\.|[^\\]])*)\\s*\\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){\r\n\t\t\t\t\tif(value){\r\n\t\t\t\t\t\tmatcher = and(matcher, selectorTypes[type || \"\"](value.replace(/\\\\/g, '')));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(combinator){\r\n\t\t\t\t\t\tmatcher = (combinator == \" \" ? ancestor : parent)(matcher);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(attrName){\r\n\t\t\t\t\t\tmatcher = and(matcher, attr(attrName, attrValue, attrType));\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t})){\r\n\t\t\t\t\tthrow new Error(\"Syntax error in query\");\r\n\t\t\t\t}\r\n\t\t\t\tif(!matcher){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tcache[selector] = matcher;\r\n\t\t\t}\r\n\t\t\t// now run the matcher function on the node\r\n\t\t\treturn matcher(node, root);\r\n\t\t};\r\n\t})();\r\n}\r\nif(!has(\"dom-qsa\")){\r\n\tvar combine = function(selector, root){\r\n\t\t// combined queries\r\n\t\tvar selectors = selector.match(unionSplit);\r\n\t\tvar indexed = [];\r\n\t\t// add all results and keep unique ones, this only runs in IE, so we take advantage \r\n\t\t// of known IE features, particularly sourceIndex which is unique and allows us to \r\n\t\t// order the results \r\n\t\tfor(var i = 0; i < selectors.length; i++){\r\n\t\t\tselector = new String(selectors[i].replace(/\\s*$/,''));\r\n\t\t\tselector.indexOf = escape; // keep it from recursively entering combine\r\n\t\t\tvar results = liteEngine(selector, root);\r\n\t\t\tfor(var j = 0, l = results.length; j < l; j++){\r\n\t\t\t\tvar node = results[j];\r\n\t\t\t\tindexed[node.sourceIndex] = node;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// now convert from a sparse array to a dense array\r\n\t\tvar totalResults = [];\r\n\t\tfor(i in indexed){\r\n\t\t\ttotalResults.push(indexed[i]);\r\n\t\t}\r\n\t\treturn totalResults;\r\n\t};\r\n}\r\n\r\nliteEngine.match = matchesSelector ? function(node, selector, root){\r\n\tif(root && root.nodeType != 9){\r\n\t\t// doesn't support three args, use rooted id trick\r\n\t\treturn useRoot(root, selector, function(query){\r\n\t\t\treturn matchesSelector.call(node, query);\r\n\t\t});\r\n\t}\r\n\t// we have a native matchesSelector, use that\r\n\treturn matchesSelector.call(node, selector);\r\n} : jsMatchesSelector; // otherwise use the JS matches impl\r\n\r\nreturn liteEngine;\r\n});\r\n"]}