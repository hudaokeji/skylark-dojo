{"version":3,"sources":["selector/acme.js"],"names":["define","dom","has","array","lang","win","trim","each","forEach","getDoc","doc","cssCaseBug","caseSensitive","yesman","getQueryParts","query","indexOf","slice","currentQuoteChar","pStart","ts","s","e","queryParts","inBrackets","inParens","inMatchFor","inPseudo","inClass","inId","inTag","lc","cc","x","ql","length","currentPart","_cp","endAll","id","replace","tv","endTag","classes","push","charAt","pseudos","attrs","tag","oper","getTag","this","otag","attr","matchFor","cmf","addToCc","type","value","name","loops","oquery","toUpperCase","infixOper","pop","agree","first","second","apply","window","arguments","getArr","i","arr","r","_isElement","n","nodeType","_getAttr","elem","className","htmlFor","style","cssText","getAttribute","*=","^=","$=","ea","lastIndex","lastIndexOf","~=","tval","|=","valueDash","=","_noNES","firstChild","nextElementSibling","_ns","_ps","_simpleNodeTest","_lookLeft","node","_lookRight","getNodeIndex","root","parentNode","tret","nextSibling","children","childNodes","ci","cl","l","setAttribute","te","isEven","isOdd","checked","condition","selected","disabled","enabled","first-child","last-child","only-child","empty","cn","nt","contains","cz","innerHTML","not","p","ignores","el","ntf","getSimpleFilterFunc","nth-child","pi","parseInt","tparts","split","pred","idx","lb","ub","ncount","defaultGetter","cond","clc","toLowerCase","hasAttribute","ff","tagName","cname","re","RegExp","test","count","pseudo","pn","matcher","a","_getElementsFuncCache","getElementsFunc","retFunc","io","filterFunc","wildcardTag","ecs","skipFilters","ret","bag","_isUnique","_nextSibling","_nextSiblings","_childElements","byId","ownerDocument","_isDescendant","String","classesString","join","getElementsByClassName","getElementsByTagName","_queryFuncCacheDOM","_queryFuncCacheQSA","getStepQueryFunc","qparts","tef","nozip","qp","candidates","qpl","gef","j","filterDown","noZip","qsa","qsaAvail","infixSpaceRe","infixSpaceFunc","match","pre","ch","post","attRe","attFunc","nonAtt","att","getQueryFunc","forceDOM","qsaCached","domCached","qcz","nospace","tq","parts","tp","pindex","concat","_zipIdx","_nodeUID","uniqueID","_uid","od","createElement","szidx","commentStrip","_zip","filter","nodeList","tmpNodeList"],"mappings":"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","file":"../../selector/acme.js","sourcesContent":["define([\r\n\t\"../dom\", \"../sniff\", \"../_base/array\", \"../_base/lang\", \"../_base/window\"\r\n], function(dom, has, array, lang, win){\r\n\r\n\t// module:\r\n\t//\t\tdojo/selector/acme\r\n\r\n/*\r\n\tacme architectural overview:\r\n\r\n\t\tacme is a relatively full-featured CSS3 query library. It is\r\n\t\tdesigned to take any valid CSS3 selector and return the nodes matching\r\n\t\tthe selector. To do this quickly, it processes queries in several\r\n\t\tsteps, applying caching where profitable.\r\n\r\n\t\tThe steps (roughly in reverse order of the way they appear in the code):\r\n\t\t\t1.) check to see if we already have a \"query dispatcher\"\r\n\t\t\t\t- if so, use that with the given parameterization. Skip to step 4.\r\n\t\t\t2.) attempt to determine which branch to dispatch the query to:\r\n\t\t\t\t- JS (optimized DOM iteration)\r\n\t\t\t\t- native (FF3.1+, Safari 3.1+, IE 8+)\r\n\t\t\t3.) tokenize and convert to executable \"query dispatcher\"\r\n\t\t\t\t- this is where the lion's share of the complexity in the\r\n\t\t\t\t\tsystem lies. In the DOM version, the query dispatcher is\r\n\t\t\t\t\tassembled as a chain of \"yes/no\" test functions pertaining to\r\n\t\t\t\t\ta section of a simple query statement (\".blah:nth-child(odd)\"\r\n\t\t\t\t\tbut not \"div div\", which is 2 simple statements). Individual\r\n\t\t\t\t\tstatement dispatchers are cached (to prevent re-definition)\r\n\t\t\t\t\tas are entire dispatch chains (to make re-execution of the\r\n\t\t\t\t\tsame query fast)\r\n\t\t\t4.) the resulting query dispatcher is called in the passed scope\r\n\t\t\t\t\t(by default the top-level document)\r\n\t\t\t\t- for DOM queries, this results in a recursive, top-down\r\n\t\t\t\t\tevaluation of nodes based on each simple query section\r\n\t\t\t\t- for native implementations, this may mean working around spec\r\n\t\t\t\t\tbugs. So be it.\r\n\t\t\t5.) matched nodes are pruned to ensure they are unique (if necessary)\r\n*/\r\n\r\n\r\n\t////////////////////////////////////////////////////////////////////////\r\n\t// Toolkit aliases\r\n\t////////////////////////////////////////////////////////////////////////\r\n\r\n\t// if you are extracting acme for use in your own system, you will\r\n\t// need to provide these methods and properties. No other porting should be\r\n\t// necessary, save for configuring the system to use a class other than\r\n\t// dojo/NodeList as the return instance instantiator\r\n\tvar trim = \t\t\tlang.trim;\r\n\tvar each = \t\t\tarray.forEach;\r\n\r\n\tvar getDoc = function(){ return win.doc; };\r\n\t// NOTE(alex): the spec is idiotic. CSS queries should ALWAYS be case-sensitive, but nooooooo\r\n\tvar cssCaseBug = (getDoc().compatMode) == \"BackCompat\";\r\n\r\n\t////////////////////////////////////////////////////////////////////////\r\n\t// Global utilities\r\n\t////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\tvar specials = \">~+\";\r\n\r\n\t// global thunk to determine whether we should treat the current query as\r\n\t// case sensitive or not. This switch is flipped by the query evaluator\r\n\t// based on the document passed as the context to search.\r\n\tvar caseSensitive = false;\r\n\r\n\t// how high?\r\n\tvar yesman = function(){ return true; };\r\n\r\n\t////////////////////////////////////////////////////////////////////////\r\n\t// Tokenizer\r\n\t////////////////////////////////////////////////////////////////////////\r\n\r\n\tvar getQueryParts = function(query){\r\n\t\t// summary:\r\n\t\t//\t\tstate machine for query tokenization\r\n\t\t// description:\r\n\t\t//\t\tinstead of using a brittle and slow regex-based CSS parser,\r\n\t\t//\t\tacme implements an AST-style query representation. This\r\n\t\t//\t\trepresentation is only generated once per query. For example,\r\n\t\t//\t\tthe same query run multiple times or under different root nodes\r\n\t\t//\t\tdoes not re-parse the selector expression but instead uses the\r\n\t\t//\t\tcached data structure. The state machine implemented here\r\n\t\t//\t\tterminates on the last \" \" (space) character and returns an\r\n\t\t//\t\tordered array of query component structures (or \"parts\"). Each\r\n\t\t//\t\tpart represents an operator or a simple CSS filtering\r\n\t\t//\t\texpression. The structure for parts is documented in the code\r\n\t\t//\t\tbelow.\r\n\r\n\r\n\t\t// NOTE:\r\n\t\t//\t\tthis code is designed to run fast and compress well. Sacrifices\r\n\t\t//\t\tto readability and maintainability have been made.  Your best\r\n\t\t//\t\tbet when hacking the tokenizer is to put The Donnas on *really*\r\n\t\t//\t\tloud (may we recommend their \"Spend The Night\" release?) and\r\n\t\t//\t\tjust assume you're gonna make mistakes. Keep the unit tests\r\n\t\t//\t\topen and run them frequently. Knowing is half the battle ;-)\r\n\t\tif(specials.indexOf(query.slice(-1)) >= 0){\r\n\t\t\t// if we end with a \">\", \"+\", or \"~\", that means we're implicitly\r\n\t\t\t// searching all children, so make it explicit\r\n\t\t\tquery += \" * \";\r\n\t\t}else{\r\n\t\t\t// if you have not provided a terminator, one will be provided for\r\n\t\t\t// you...\r\n\t\t\tquery += \" \";\r\n\t\t}\r\n\r\n\t\tvar ts = function(/*Integer*/ s, /*Integer*/ e){\r\n\t\t\t// trim and slice.\r\n\r\n\t\t\t// take an index to start a string slice from and an end position\r\n\t\t\t// and return a trimmed copy of that sub-string\r\n\t\t\treturn trim(query.slice(s, e));\r\n\t\t};\r\n\r\n\t\t// the overall data graph of the full query, as represented by queryPart objects\r\n\t\tvar queryParts = [];\r\n\r\n\r\n\t\t// state keeping vars\r\n\t\tvar inBrackets = -1, inParens = -1, inMatchFor = -1,\r\n\t\t\tinPseudo = -1, inClass = -1, inId = -1, inTag = -1, currentQuoteChar,\r\n\t\t\tlc = \"\", cc = \"\", pStart;\r\n\r\n\t\t// iteration vars\r\n\t\tvar x = 0, // index in the query\r\n\t\t\tql = query.length,\r\n\t\t\tcurrentPart = null, // data structure representing the entire clause\r\n\t\t\t_cp = null; // the current pseudo or attr matcher\r\n\r\n\t\t// several temporary variables are assigned to this structure during a\r\n\t\t// potential sub-expression match:\r\n\t\t//\t\tattr:\r\n\t\t//\t\t\ta string representing the current full attribute match in a\r\n\t\t//\t\t\tbracket expression\r\n\t\t//\t\ttype:\r\n\t\t//\t\t\tif there's an operator in a bracket expression, this is\r\n\t\t//\t\t\tused to keep track of it\r\n\t\t//\t\tvalue:\r\n\t\t//\t\t\tthe internals of parenthetical expression for a pseudo. for\r\n\t\t//\t\t\t:nth-child(2n+1), value might be \"2n+1\"\r\n\r\n\t\tvar endTag = function(){\r\n\t\t\t// called when the tokenizer hits the end of a particular tag name.\r\n\t\t\t// Re-sets state variables for tag matching and sets up the matcher\r\n\t\t\t// to handle the next type of token (tag or operator).\r\n\t\t\tif(inTag >= 0){\r\n\t\t\t\tvar tv = (inTag == x) ? null : ts(inTag, x); // .toLowerCase();\r\n\t\t\t\tcurrentPart[ (specials.indexOf(tv) < 0) ? \"tag\" : \"oper\" ] = tv;\r\n\t\t\t\tinTag = -1;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar endId = function(){\r\n\t\t\t// called when the tokenizer might be at the end of an ID portion of a match\r\n\t\t\tif(inId >= 0){\r\n\t\t\t\tcurrentPart.id = ts(inId, x).replace(/\\\\/g, \"\");\r\n\t\t\t\tinId = -1;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar endClass = function(){\r\n\t\t\t// called when the tokenizer might be at the end of a class name\r\n\t\t\t// match. CSS allows for multiple classes, so we augment the\r\n\t\t\t// current item with another class in its list\r\n\t\t\tif(inClass >= 0){\r\n\t\t\t\tcurrentPart.classes.push(ts(inClass + 1, x).replace(/\\\\/g, \"\"));\r\n\t\t\t\tinClass = -1;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar endAll = function(){\r\n\t\t\t// at the end of a simple fragment, so wall off the matches\r\n\t\t\tendId();\r\n\t\t\tendTag();\r\n\t\t\tendClass();\r\n\t\t};\r\n\r\n\t\tvar endPart = function(){\r\n\t\t\tendAll();\r\n\t\t\tif(inPseudo >= 0){\r\n\t\t\t\tcurrentPart.pseudos.push({ name: ts(inPseudo + 1, x) });\r\n\t\t\t}\r\n\t\t\t// hint to the selector engine to tell it whether or not it\r\n\t\t\t// needs to do any iteration. Many simple selectors don't, and\r\n\t\t\t// we can avoid significant construction-time work by advising\r\n\t\t\t// the system to skip them\r\n\t\t\tcurrentPart.loops = (\r\n\t\t\t\t\tcurrentPart.pseudos.length ||\r\n\t\t\t\t\tcurrentPart.attrs.length ||\r\n\t\t\t\t\tcurrentPart.classes.length\t);\r\n\r\n\t\t\tcurrentPart.oquery = currentPart.query = ts(pStart, x); // save the full expression as a string\r\n\r\n\r\n\t\t\t// otag/tag are hints to suggest to the system whether or not\r\n\t\t\t// it's an operator or a tag. We save a copy of otag since the\r\n\t\t\t// tag name is cast to upper-case in regular HTML matches. The\r\n\t\t\t// system has a global switch to figure out if the current\r\n\t\t\t// expression needs to be case sensitive or not and it will use\r\n\t\t\t// otag or tag accordingly\r\n\t\t\tcurrentPart.otag = currentPart.tag = (currentPart[\"oper\"]) ? null : (currentPart.tag || \"*\");\r\n\r\n\t\t\tif(currentPart.tag){\r\n\t\t\t\t// if we're in a case-insensitive HTML doc, we likely want\r\n\t\t\t\t// the toUpperCase when matching on element.tagName. If we\r\n\t\t\t\t// do it here, we can skip the string op per node\r\n\t\t\t\t// comparison\r\n\t\t\t\tcurrentPart.tag = currentPart.tag.toUpperCase();\r\n\t\t\t}\r\n\r\n\t\t\t// add the part to the list\r\n\t\t\tif(queryParts.length && (queryParts[queryParts.length-1].oper)){\r\n\t\t\t\t// operators are always infix, so we remove them from the\r\n\t\t\t\t// list and attach them to the next match. The evaluator is\r\n\t\t\t\t// responsible for sorting out how to handle them.\r\n\t\t\t\tcurrentPart.infixOper = queryParts.pop();\r\n\t\t\t\tcurrentPart.query = currentPart.infixOper.query + \" \" + currentPart.query;\r\n\t\t\t\t/*\r\n\t\t\t\tconsole.debug(\t\"swapping out the infix\",\r\n\t\t\t\t\t\t\t\tcurrentPart.infixOper,\r\n\t\t\t\t\t\t\t\t\"and attaching it to\",\r\n\t\t\t\t\t\t\t\tcurrentPart);\r\n\t\t\t\t*/\r\n\t\t\t}\r\n\t\t\tqueryParts.push(currentPart);\r\n\r\n\t\t\tcurrentPart = null;\r\n\t\t};\r\n\r\n\t\t// iterate over the query, character by character, building up a\r\n\t\t// list of query part objects\r\n\t\tfor(; lc=cc, cc=query.charAt(x), x < ql; x++){\r\n\t\t\t//\t\tcc: the current character in the match\r\n\t\t\t//\t\tlc: the last character (if any)\r\n\r\n\t\t\t// someone is trying to escape something, so don't try to match any\r\n\t\t\t// fragments. We assume we're inside a literal.\r\n\t\t\tif(lc == \"\\\\\"){ continue; }\r\n\t\t\tif(!currentPart){ // a part was just ended or none has yet been created\r\n\t\t\t\t// NOTE: I hate all this alloc, but it's shorter than writing tons of if's\r\n\t\t\t\tpStart = x;\r\n\t\t\t\t//\trules describe full CSS sub-expressions, like:\r\n\t\t\t\t//\t\t#someId\r\n\t\t\t\t//\t\t.className:first-child\r\n\t\t\t\t//\tbut not:\r\n\t\t\t\t//\t\tthinger > div.howdy[type=thinger]\r\n\t\t\t\t//\tthe indidual components of the previous query would be\r\n\t\t\t\t//\tsplit into 3 parts that would be represented a structure like:\r\n\t\t\t\t//\t\t[\r\n\t\t\t\t//\t\t\t{\r\n\t\t\t\t//\t\t\t\tquery: \"thinger\",\r\n\t\t\t\t//\t\t\t\ttag: \"thinger\",\r\n\t\t\t\t//\t\t\t},\r\n\t\t\t\t//\t\t\t{\r\n\t\t\t\t//\t\t\t\tquery: \"div.howdy[type=thinger]\",\r\n\t\t\t\t//\t\t\t\tclasses: [\"howdy\"],\r\n\t\t\t\t//\t\t\t\tinfixOper: {\r\n\t\t\t\t//\t\t\t\t\tquery: \">\",\r\n\t\t\t\t//\t\t\t\t\toper: \">\",\r\n\t\t\t\t//\t\t\t\t}\r\n\t\t\t\t//\t\t\t},\r\n\t\t\t\t//\t\t]\r\n\t\t\t\tcurrentPart = {\r\n\t\t\t\t\tquery: null, // the full text of the part's rule\r\n\t\t\t\t\tpseudos: [], // CSS supports multiple pseud-class matches in a single rule\r\n\t\t\t\t\tattrs: [],\t// CSS supports multi-attribute match, so we need an array\r\n\t\t\t\t\tclasses: [], // class matches may be additive, e.g.: .thinger.blah.howdy\r\n\t\t\t\t\ttag: null,\t// only one tag...\r\n\t\t\t\t\toper: null, // ...or operator per component. Note that these wind up being exclusive.\r\n\t\t\t\t\tid: null,\t// the id component of a rule\r\n\t\t\t\t\tgetTag: function(){\r\n\t\t\t\t\t\treturn caseSensitive ? this.otag : this.tag;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// if we don't have a part, we assume we're going to start at\r\n\t\t\t\t// the beginning of a match, which should be a tag name. This\r\n\t\t\t\t// might fault a little later on, but we detect that and this\r\n\t\t\t\t// iteration will still be fine.\r\n\t\t\t\tinTag = x;\r\n\t\t\t}\r\n\r\n\t\t\t// Skip processing all quoted characters.\r\n\t\t\t// If we are inside quoted text then currentQuoteChar stores the character that began the quote,\r\n\t\t\t// thus that character that will end it.\r\n\t\t\tif(currentQuoteChar){\r\n\t\t\t\tif(cc == currentQuoteChar){\r\n\t\t\t\t\tcurrentQuoteChar = null;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}else if (cc == \"'\" || cc == '\"'){\r\n\t\t\t\tcurrentQuoteChar = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif(inBrackets >= 0){\r\n\t\t\t\t// look for a the close first\r\n\t\t\t\tif(cc == \"]\"){ // if we're in a [...] clause and we end, do assignment\r\n\t\t\t\t\tif(!_cp.attr){\r\n\t\t\t\t\t\t// no attribute match was previously begun, so we\r\n\t\t\t\t\t\t// assume this is an attribute existence match in the\r\n\t\t\t\t\t\t// form of [someAttributeName]\r\n\t\t\t\t\t\t_cp.attr = ts(inBrackets+1, x);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// we had an attribute already, so we know that we're\r\n\t\t\t\t\t\t// matching some sort of value, as in [attrName=howdy]\r\n\t\t\t\t\t\t_cp.matchFor = ts((inMatchFor||inBrackets+1), x);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar cmf = _cp.matchFor;\r\n\t\t\t\t\tif(cmf){\r\n\t\t\t\t\t\t// try to strip quotes from the matchFor value. We want\r\n\t\t\t\t\t\t// [attrName=howdy] to match the same\r\n\t\t\t\t\t\t//\tas [attrName = 'howdy' ]\r\n\t\t\t\t\t\tif(\t(cmf.charAt(0) == '\"') || (cmf.charAt(0) == \"'\") ){\r\n\t\t\t\t\t\t\t_cp.matchFor = cmf.slice(1, -1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// remove backslash escapes from an attribute match, since DOM\r\n\t\t\t\t\t// querying will get attribute values without backslashes\r\n\t\t\t\t\tif(_cp.matchFor){\r\n\t\t\t\t\t\t_cp.matchFor = _cp.matchFor.replace(/\\\\/g, \"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end the attribute by adding it to the list of attributes.\r\n\t\t\t\t\tcurrentPart.attrs.push(_cp);\r\n\t\t\t\t\t_cp = null; // necessary?\r\n\t\t\t\t\tinBrackets = inMatchFor = -1;\r\n\t\t\t\t}else if(cc == \"=\"){\r\n\t\t\t\t\t// if the last char was an operator prefix, make sure we\r\n\t\t\t\t\t// record it along with the \"=\" operator.\r\n\t\t\t\t\tvar addToCc = (\"|~^$*\".indexOf(lc) >=0 ) ? lc : \"\";\r\n\t\t\t\t\t_cp.type = addToCc+cc;\r\n\t\t\t\t\t_cp.attr = ts(inBrackets+1, x-addToCc.length);\r\n\t\t\t\t\tinMatchFor = x+1;\r\n\t\t\t\t}\r\n\t\t\t\t// now look for other clause parts\r\n\t\t\t}else if(inParens >= 0){\r\n\t\t\t\t// if we're in a parenthetical expression, we need to figure\r\n\t\t\t\t// out if it's attached to a pseudo-selector rule like\r\n\t\t\t\t// :nth-child(1)\r\n\t\t\t\tif(cc == \")\"){\r\n\t\t\t\t\tif(inPseudo >= 0){\r\n\t\t\t\t\t\t_cp.value = ts(inParens+1, x);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinPseudo = inParens = -1;\r\n\t\t\t\t}\r\n\t\t\t}else if(cc == \"#\"){\r\n\t\t\t\t// start of an ID match\r\n\t\t\t\tendAll();\r\n\t\t\t\tinId = x+1;\r\n\t\t\t}else if(cc == \".\"){\r\n\t\t\t\t// start of a class match\r\n\t\t\t\tendAll();\r\n\t\t\t\tinClass = x;\r\n\t\t\t}else if(cc == \":\"){\r\n\t\t\t\t// start of a pseudo-selector match\r\n\t\t\t\tendAll();\r\n\t\t\t\tinPseudo = x;\r\n\t\t\t}else if(cc == \"[\"){\r\n\t\t\t\t// start of an attribute match.\r\n\t\t\t\tendAll();\r\n\t\t\t\tinBrackets = x;\r\n\t\t\t\t// provide a new structure for the attribute match to fill-in\r\n\t\t\t\t_cp = {\r\n\t\t\t\t\t/*=====\r\n\t\t\t\t\tattr: null, type: null, matchFor: null\r\n\t\t\t\t\t=====*/\r\n\t\t\t\t};\r\n\t\t\t}else if(cc == \"(\"){\r\n\t\t\t\t// we really only care if we've entered a parenthetical\r\n\t\t\t\t// expression if we're already inside a pseudo-selector match\r\n\t\t\t\tif(inPseudo >= 0){\r\n\t\t\t\t\t// provide a new structure for the pseudo match to fill-in\r\n\t\t\t\t\t_cp = {\r\n\t\t\t\t\t\tname: ts(inPseudo+1, x),\r\n\t\t\t\t\t\tvalue: null\r\n\t\t\t\t\t};\r\n\t\t\t\t\tcurrentPart.pseudos.push(_cp);\r\n\t\t\t\t}\r\n\t\t\t\tinParens = x;\r\n\t\t\t}else if(\r\n\t\t\t\t(cc == \" \") &&\r\n\t\t\t\t// if it's a space char and the last char is too, consume the\r\n\t\t\t\t// current one without doing more work\r\n\t\t\t\t(lc != cc)\r\n\t\t\t){\r\n\t\t\t\tendPart();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn queryParts;\r\n\t};\r\n\r\n\r\n\t////////////////////////////////////////////////////////////////////////\r\n\t// DOM query infrastructure\r\n\t////////////////////////////////////////////////////////////////////////\r\n\r\n\tvar agree = function(first, second){\r\n\t\t// the basic building block of the yes/no chaining system. agree(f1,\r\n\t\t// f2) generates a new function which returns the boolean results of\r\n\t\t// both of the passed functions to a single logical-anded result. If\r\n\t\t// either are not passed, the other is used exclusively.\r\n\t\tif(!first){ return second; }\r\n\t\tif(!second){ return first; }\r\n\r\n\t\treturn function(){\r\n\t\t\treturn first.apply(window, arguments) && second.apply(window, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\tvar getArr = function(i, arr){\r\n\t\t// helps us avoid array alloc when we don't need it\r\n\t\tvar r = arr||[]; // FIXME: should this be 'new d._NodeListCtor()' ?\r\n\t\tif(i){ r.push(i); }\r\n\t\treturn r;\r\n\t};\r\n\r\n\tvar _isElement = function(n){ return (1 == n.nodeType); };\r\n\r\n\t// FIXME: need to coalesce _getAttr with defaultGetter\r\n\tvar blank = \"\";\r\n\tvar _getAttr = function(elem, attr){\r\n\t\tif(!elem){ return blank; }\r\n\t\tif(attr == \"class\"){\r\n\t\t\treturn elem.className || blank;\r\n\t\t}\r\n\t\tif(attr == \"for\"){\r\n\t\t\treturn elem.htmlFor || blank;\r\n\t\t}\r\n\t\tif(attr == \"style\"){\r\n\t\t\treturn elem.style.cssText || blank;\r\n\t\t}\r\n\t\treturn (caseSensitive ? elem.getAttribute(attr) : elem.getAttribute(attr, 2)) || blank;\r\n\t};\r\n\r\n\tvar attrs = {\r\n\t\t\"*=\": function(attr, value){\r\n\t\t\treturn function(elem){\r\n\t\t\t\t// E[foo*=\"bar\"]\r\n\t\t\t\t//\t\tan E element whose \"foo\" attribute value contains\r\n\t\t\t\t//\t\tthe substring \"bar\"\r\n\t\t\t\treturn (_getAttr(elem, attr).indexOf(value)>=0);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"^=\": function(attr, value){\r\n\t\t\t// E[foo^=\"bar\"]\r\n\t\t\t//\t\tan E element whose \"foo\" attribute value begins exactly\r\n\t\t\t//\t\twith the string \"bar\"\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn (_getAttr(elem, attr).indexOf(value)==0);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"$=\": function(attr, value){\r\n\t\t\t// E[foo$=\"bar\"]\r\n\t\t\t//\t\tan E element whose \"foo\" attribute value ends exactly\r\n\t\t\t//\t\twith the string \"bar\"\r\n\t\t\treturn function(elem){\r\n\t\t\t\tvar ea = \" \"+_getAttr(elem, attr);\r\n\t\t\t\tvar lastIndex = ea.lastIndexOf(value);\r\n\t\t\t\treturn lastIndex > -1 && (lastIndex==(ea.length-value.length));\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"~=\": function(attr, value){\r\n\t\t\t// E[foo~=\"bar\"]\r\n\t\t\t//\t\tan E element whose \"foo\" attribute value is a list of\r\n\t\t\t//\t\tspace-separated values, one of which is exactly equal\r\n\t\t\t//\t\tto \"bar\"\r\n\r\n\t\t\t// return \"[contains(concat(' ',@\"+attr+\",' '), ' \"+ value +\" ')]\";\r\n\t\t\tvar tval = \" \"+value+\" \";\r\n\t\t\treturn function(elem){\r\n\t\t\t\tvar ea = \" \"+_getAttr(elem, attr)+\" \";\r\n\t\t\t\treturn (ea.indexOf(tval)>=0);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"|=\": function(attr, value){\r\n\t\t\t// E[hreflang|=\"en\"]\r\n\t\t\t//\t\tan E element whose \"hreflang\" attribute has a\r\n\t\t\t//\t\thyphen-separated list of values beginning (from the\r\n\t\t\t//\t\tleft) with \"en\"\r\n\t\t\tvar valueDash = value+\"-\";\r\n\t\t\treturn function(elem){\r\n\t\t\t\tvar ea = _getAttr(elem, attr);\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(ea == value) ||\r\n\t\t\t\t\t(ea.indexOf(valueDash)==0)\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"=\": function(attr, value){\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn (_getAttr(elem, attr) == value);\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\t// avoid testing for node type if we can. Defining this in the negative\r\n\t// here to avoid negation in the fast path.\r\n\tvar _noNES = (typeof getDoc().firstChild.nextElementSibling == \"undefined\");\r\n\tvar _ns = !_noNES ? \"nextElementSibling\" : \"nextSibling\";\r\n\tvar _ps = !_noNES ? \"previousElementSibling\" : \"previousSibling\";\r\n\tvar _simpleNodeTest = (_noNES ? _isElement : yesman);\r\n\r\n\tvar _lookLeft = function(node){\r\n\t\t// look left\r\n\t\twhile(node = node[_ps]){\r\n\t\t\tif(_simpleNodeTest(node)){ return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tvar _lookRight = function(node){\r\n\t\t// look right\r\n\t\twhile(node = node[_ns]){\r\n\t\t\tif(_simpleNodeTest(node)){ return false; }\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tvar getNodeIndex = function(node){\r\n\t\tvar root = node.parentNode;\r\n\t\troot = root.nodeType != 7 ? root : root.nextSibling; // PROCESSING_INSTRUCTION_NODE\r\n\t\tvar i = 0,\r\n\t\t\ttret = root.children || root.childNodes,\r\n\t\t\tci = (node[\"_i\"]||node.getAttribute(\"_i\")||-1),\r\n\t\t\tcl = (root[\"_l\"]|| (typeof root.getAttribute !== \"undefined\" ? root.getAttribute(\"_l\") : -1));\r\n\r\n\t\tif(!tret){ return -1; }\r\n\t\tvar l = tret.length;\r\n\r\n\t\t// we calculate the parent length as a cheap way to invalidate the\r\n\t\t// cache. It's not 100% accurate, but it's much more honest than what\r\n\t\t// other libraries do\r\n\t\tif( cl == l && ci >= 0 && cl >= 0 ){\r\n\t\t\t// if it's legit, tag and release\r\n\t\t\treturn ci;\r\n\t\t}\r\n\r\n\t\t// else re-key things\r\n\t\tif(has(\"ie\") && typeof root.setAttribute !== \"undefined\"){\r\n\t\t\troot.setAttribute(\"_l\", l);\r\n\t\t}else{\r\n\t\t\troot[\"_l\"] = l;\r\n\t\t}\r\n\t\tci = -1;\r\n\t\tfor(var te = root[\"firstElementChild\"]||root[\"firstChild\"]; te; te = te[_ns]){\r\n\t\t\tif(_simpleNodeTest(te)){\r\n\t\t\t\tif(has(\"ie\")){\r\n\t\t\t\t\tte.setAttribute(\"_i\", ++i);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tte[\"_i\"] = ++i;\r\n\t\t\t\t}\r\n\t\t\t\tif(node === te){\r\n\t\t\t\t\t// NOTE:\r\n\t\t\t\t\t//\tshortcutting the return at this step in indexing works\r\n\t\t\t\t\t//\tvery well for benchmarking but we avoid it here since\r\n\t\t\t\t\t//\tit leads to potential O(n^2) behavior in sequential\r\n\t\t\t\t\t//\tgetNodexIndex operations on a previously un-indexed\r\n\t\t\t\t\t//\tparent. We may revisit this at a later time, but for\r\n\t\t\t\t\t//\tnow we just want to get the right answer more often\r\n\t\t\t\t\t//\tthan not.\r\n\t\t\t\t\tci = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ci;\r\n\t};\r\n\r\n\tvar isEven = function(elem){\r\n\t\treturn !((getNodeIndex(elem)) % 2);\r\n\t};\r\n\r\n\tvar isOdd = function(elem){\r\n\t\treturn ((getNodeIndex(elem)) % 2);\r\n\t};\r\n\r\n\tvar pseudos = {\r\n\t\t\"checked\": function(name, condition){\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn !!(\"checked\" in elem ? elem.checked : elem.selected);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"disabled\": function(name, condition){\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn elem.disabled;\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"enabled\": function(name, condition){\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn !elem.disabled;\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"first-child\": function(){ return _lookLeft; },\r\n\t\t\"last-child\": function(){ return _lookRight; },\r\n\t\t\"only-child\": function(name, condition){\r\n\t\t\treturn function(node){\r\n\t\t\t\treturn _lookLeft(node) && _lookRight(node);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"empty\": function(name, condition){\r\n\t\t\treturn function(elem){\r\n\t\t\t\t// DomQuery and jQuery get this wrong, oddly enough.\r\n\t\t\t\t// The CSS 3 selectors spec is pretty explicit about it, too.\r\n\t\t\t\tvar cn = elem.childNodes;\r\n\t\t\t\tvar cnl = elem.childNodes.length;\r\n\t\t\t\t// if(!cnl){ return true; }\r\n\t\t\t\tfor(var x=cnl-1; x >= 0; x--){\r\n\t\t\t\t\tvar nt = cn[x].nodeType;\r\n\t\t\t\t\tif((nt === 1)||(nt == 3)){ return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"contains\": function(name, condition){\r\n\t\t\tvar cz = condition.charAt(0);\r\n\t\t\tif( cz == '\"' || cz == \"'\" ){ //remove quote\r\n\t\t\t\tcondition = condition.slice(1, -1);\r\n\t\t\t}\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn (elem.innerHTML.indexOf(condition) >= 0);\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"not\": function(name, condition){\r\n\t\t\tvar p = getQueryParts(condition)[0];\r\n\t\t\tvar ignores = { el: 1 };\r\n\t\t\tif(p.tag != \"*\"){\r\n\t\t\t\tignores.tag = 1;\r\n\t\t\t}\r\n\t\t\tif(!p.classes.length){\r\n\t\t\t\tignores.classes = 1;\r\n\t\t\t}\r\n\t\t\tvar ntf = getSimpleFilterFunc(p, ignores);\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn (!ntf(elem));\r\n\t\t\t};\r\n\t\t},\r\n\t\t\"nth-child\": function(name, condition){\r\n\t\t\tvar pi = parseInt;\r\n\t\t\t// avoid re-defining function objects if we can\r\n\t\t\tif(condition == \"odd\"){\r\n\t\t\t\treturn isOdd;\r\n\t\t\t}else if(condition == \"even\"){\r\n\t\t\t\treturn isEven;\r\n\t\t\t}\r\n\t\t\t// FIXME: can we shorten this?\r\n\t\t\tif(condition.indexOf(\"n\") != -1){\r\n\t\t\t\tvar tparts = condition.split(\"n\", 2);\r\n\t\t\t\tvar pred = tparts[0] ? ((tparts[0] == '-') ? -1 : pi(tparts[0])) : 1;\r\n\t\t\t\tvar idx = tparts[1] ? pi(tparts[1]) : 0;\r\n\t\t\t\tvar lb = 0, ub = -1;\r\n\t\t\t\tif(pred > 0){\r\n\t\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t\tidx = (idx % pred) && (pred + (idx % pred));\r\n\t\t\t\t\t}else if(idx>0){\r\n\t\t\t\t\t\tif(idx >= pred){\r\n\t\t\t\t\t\t\tlb = idx - idx % pred;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tidx = idx % pred;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(pred<0){\r\n\t\t\t\t\tpred *= -1;\r\n\t\t\t\t\t// idx has to be greater than 0 when pred is negative;\r\n\t\t\t\t\t// shall we throw an error here?\r\n\t\t\t\t\tif(idx > 0){\r\n\t\t\t\t\t\tub = idx;\r\n\t\t\t\t\t\tidx = idx % pred;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(pred > 0){\r\n\t\t\t\t\treturn function(elem){\r\n\t\t\t\t\t\tvar i = getNodeIndex(elem);\r\n\t\t\t\t\t\treturn (i>=lb) && (ub<0 || i<=ub) && ((i % pred) == idx);\r\n\t\t\t\t\t};\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcondition = idx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar ncount = pi(condition);\r\n\t\t\treturn function(elem){\r\n\t\t\t\treturn (getNodeIndex(elem) == ncount);\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\tvar defaultGetter = (has(\"ie\") < 9 || has(\"ie\") == 9 && has(\"quirks\")) ? function(cond){\r\n\t\tvar clc = cond.toLowerCase();\r\n\t\tif(clc == \"class\"){ cond = \"className\"; }\r\n\t\treturn function(elem){\r\n\t\t\treturn (caseSensitive ? elem.getAttribute(cond) : elem[cond]||elem[clc]);\r\n\t\t};\r\n\t} : function(cond){\r\n\t\treturn function(elem){\r\n\t\t\treturn (elem && elem.getAttribute && elem.hasAttribute(cond));\r\n\t\t};\r\n\t};\r\n\r\n\tvar getSimpleFilterFunc = function(query, ignores){\r\n\t\t// generates a node tester function based on the passed query part. The\r\n\t\t// query part is one of the structures generated by the query parser\r\n\t\t// when it creates the query AST. The \"ignores\" object specifies which\r\n\t\t// (if any) tests to skip, allowing the system to avoid duplicating\r\n\t\t// work where it may have already been taken into account by other\r\n\t\t// factors such as how the nodes to test were fetched in the first\r\n\t\t// place\r\n\t\tif(!query){ return yesman; }\r\n\t\tignores = ignores||{};\r\n\r\n\t\tvar ff = null;\r\n\r\n\t\tif(!(\"el\" in ignores)){\r\n\t\t\tff = agree(ff, _isElement);\r\n\t\t}\r\n\r\n\t\tif(!(\"tag\" in ignores)){\r\n\t\t\tif(query.tag != \"*\"){\r\n\t\t\t\tff = agree(ff, function(elem){\r\n\t\t\t\t\treturn (elem && ((caseSensitive ? elem.tagName : elem.tagName.toUpperCase()) == query.getTag()));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!(\"classes\" in ignores)){\r\n\t\t\teach(query.classes, function(cname, idx, arr){\r\n\t\t\t\t// get the class name\r\n\t\t\t\t/*\r\n\t\t\t\tvar isWildcard = cname.charAt(cname.length-1) == \"*\";\r\n\t\t\t\tif(isWildcard){\r\n\t\t\t\t\tcname = cname.substr(0, cname.length-1);\r\n\t\t\t\t}\r\n\t\t\t\t// I dislike the regex thing, even if memoized in a cache, but it's VERY short\r\n\t\t\t\tvar re = new RegExp(\"(?:^|\\\\s)\" + cname + (isWildcard ? \".*\" : \"\") + \"(?:\\\\s|$)\");\r\n\t\t\t\t*/\r\n\t\t\t\tvar re = new RegExp(\"(?:^|\\\\s)\" + cname + \"(?:\\\\s|$)\");\r\n\t\t\t\tff = agree(ff, function(elem){\r\n\t\t\t\t\treturn re.test(elem.className);\r\n\t\t\t\t});\r\n\t\t\t\tff.count = idx;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(!(\"pseudos\" in ignores)){\r\n\t\t\teach(query.pseudos, function(pseudo){\r\n\t\t\t\tvar pn = pseudo.name;\r\n\t\t\t\tif(pseudos[pn]){\r\n\t\t\t\t\tff = agree(ff, pseudos[pn](pn, pseudo.value));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(!(\"attrs\" in ignores)){\r\n\t\t\teach(query.attrs, function(attr){\r\n\t\t\t\tvar matcher;\r\n\t\t\t\tvar a = attr.attr;\r\n\t\t\t\t// type, attr, matchFor\r\n\t\t\t\tif(attr.type && attrs[attr.type]){\r\n\t\t\t\t\tmatcher = attrs[attr.type](a, attr.matchFor);\r\n\t\t\t\t}else if(a.length){\r\n\t\t\t\t\tmatcher = defaultGetter(a);\r\n\t\t\t\t}\r\n\t\t\t\tif(matcher){\r\n\t\t\t\t\tff = agree(ff, matcher);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(!(\"id\" in ignores)){\r\n\t\t\tif(query.id){\r\n\t\t\t\tff = agree(ff, function(elem){\r\n\t\t\t\t\treturn (!!elem && (elem.id == query.id));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!ff){\r\n\t\t\tif(!(\"default\" in ignores)){\r\n\t\t\t\tff = yesman;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ff;\r\n\t};\r\n\r\n\tvar _nextSibling = function(filterFunc){\r\n\t\treturn function(node, ret, bag){\r\n\t\t\twhile(node = node[_ns]){\r\n\t\t\t\tif(_noNES && (!_isElement(node))){ continue; }\r\n\t\t\t\tif(\r\n\t\t\t\t\t(!bag || _isUnique(node, bag)) &&\r\n\t\t\t\t\tfilterFunc(node)\r\n\t\t\t\t){\r\n\t\t\t\t\tret.push(node);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t};\r\n\t};\r\n\r\n\tvar _nextSiblings = function(filterFunc){\r\n\t\treturn function(root, ret, bag){\r\n\t\t\tvar te = root[_ns];\r\n\t\t\twhile(te){\r\n\t\t\t\tif(_simpleNodeTest(te)){\r\n\t\t\t\t\tif(bag && !_isUnique(te, bag)){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(filterFunc(te)){\r\n\t\t\t\t\t\tret.push(te);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tte = te[_ns];\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t};\r\n\t};\r\n\r\n\t// get an array of child *elements*, skipping text and comment nodes\r\n\tvar _childElements = function(filterFunc){\r\n\t\tfilterFunc = filterFunc||yesman;\r\n\t\treturn function(root, ret, bag){\r\n\t\t\t// get an array of child elements, skipping text and comment nodes\r\n\t\t\tvar te, x = 0, tret = root.children || root.childNodes;\r\n\t\t\twhile(te = tret[x++]){\r\n\t\t\t\tif(\r\n\t\t\t\t\t_simpleNodeTest(te) &&\r\n\t\t\t\t\t(!bag || _isUnique(te, bag)) &&\r\n\t\t\t\t\t(filterFunc(te, x))\r\n\t\t\t\t){\r\n\t\t\t\t\tret.push(te);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t};\r\n\t};\r\n\r\n\t// test to see if node is below root\r\n\tvar _isDescendant = function(node, root){\r\n\t\tvar pn = node.parentNode;\r\n\t\twhile(pn){\r\n\t\t\tif(pn == root){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpn = pn.parentNode;\r\n\t\t}\r\n\t\treturn !!pn;\r\n\t};\r\n\r\n\tvar _getElementsFuncCache = {};\r\n\r\n\tvar getElementsFunc = function(query){\r\n\t\tvar retFunc = _getElementsFuncCache[query.query];\r\n\t\t// if we've got a cached dispatcher, just use that\r\n\t\tif(retFunc){ return retFunc; }\r\n\t\t// else, generate a new on\r\n\r\n\t\t// NOTE:\r\n\t\t//\t\tthis function returns a function that searches for nodes and\r\n\t\t//\t\tfilters them.  The search may be specialized by infix operators\r\n\t\t//\t\t(\">\", \"~\", or \"+\") else it will default to searching all\r\n\t\t//\t\tdescendants (the \" \" selector). Once a group of children is\r\n\t\t//\t\tfound, a test function is applied to weed out the ones we\r\n\t\t//\t\tdon't want. Many common cases can be fast-pathed. We spend a\r\n\t\t//\t\tlot of cycles to create a dispatcher that doesn't do more work\r\n\t\t//\t\tthan necessary at any point since, unlike this function, the\r\n\t\t//\t\tdispatchers will be called every time. The logic of generating\r\n\t\t//\t\tefficient dispatchers looks like this in pseudo code:\r\n\t\t//\r\n\t\t//\t\t# if it's a purely descendant query (no \">\", \"+\", or \"~\" modifiers)\r\n\t\t//\t\tif infixOperator == \" \":\r\n\t\t//\t\t\tif only(id):\r\n\t\t//\t\t\t\treturn def(root):\r\n\t\t//\t\t\t\t\treturn d.byId(id, root);\r\n\t\t//\r\n\t\t//\t\t\telif id:\r\n\t\t//\t\t\t\treturn def(root):\r\n\t\t//\t\t\t\t\treturn filter(d.byId(id, root));\r\n\t\t//\r\n\t\t//\t\t\telif cssClass && getElementsByClassName:\r\n\t\t//\t\t\t\treturn def(root):\r\n\t\t//\t\t\t\t\treturn filter(root.getElementsByClassName(cssClass));\r\n\t\t//\r\n\t\t//\t\t\telif only(tag):\r\n\t\t//\t\t\t\treturn def(root):\r\n\t\t//\t\t\t\t\treturn root.getElementsByTagName(tagName);\r\n\t\t//\r\n\t\t//\t\t\telse:\r\n\t\t//\t\t\t\t# search by tag name, then filter\r\n\t\t//\t\t\t\treturn def(root):\r\n\t\t//\t\t\t\t\treturn filter(root.getElementsByTagName(tagName||\"*\"));\r\n\t\t//\r\n\t\t//\t\telif infixOperator == \">\":\r\n\t\t//\t\t\t# search direct children\r\n\t\t//\t\t\treturn def(root):\r\n\t\t//\t\t\t\treturn filter(root.children);\r\n\t\t//\r\n\t\t//\t\telif infixOperator == \"+\":\r\n\t\t//\t\t\t# search next sibling\r\n\t\t//\t\t\treturn def(root):\r\n\t\t//\t\t\t\treturn filter(root.nextElementSibling);\r\n\t\t//\r\n\t\t//\t\telif infixOperator == \"~\":\r\n\t\t//\t\t\t# search rightward siblings\r\n\t\t//\t\t\treturn def(root):\r\n\t\t//\t\t\t\treturn filter(nextSiblings(root));\r\n\r\n\t\tvar io = query.infixOper;\r\n\t\tvar oper = (io ? io.oper : \"\");\r\n\t\t// the default filter func which tests for all conditions in the query\r\n\t\t// part. This is potentially inefficient, so some optimized paths may\r\n\t\t// re-define it to test fewer things.\r\n\t\tvar filterFunc = getSimpleFilterFunc(query, { el: 1 });\r\n\t\tvar qt = query.tag;\r\n\t\tvar wildcardTag = (\"*\" == qt);\r\n\t\tvar ecs = getDoc()[\"getElementsByClassName\"];\r\n\r\n\t\tif(!oper){\r\n\t\t\t// if there's no infix operator, then it's a descendant query. ID\r\n\t\t\t// and \"elements by class name\" variants can be accelerated so we\r\n\t\t\t// call them out explicitly:\r\n\t\t\tif(query.id){\r\n\t\t\t\t// testing shows that the overhead of yesman() is acceptable\r\n\t\t\t\t// and can save us some bytes vs. re-defining the function\r\n\t\t\t\t// everywhere.\r\n\t\t\t\tfilterFunc = (!query.loops && wildcardTag) ?\r\n\t\t\t\t\tyesman :\r\n\t\t\t\t\tgetSimpleFilterFunc(query, { el: 1, id: 1 });\r\n\r\n\t\t\t\tretFunc = function(root, arr){\r\n\t\t\t\t\tvar te = dom.byId(query.id, (root.ownerDocument||root));\r\n\t\t\t\t\tif(!te || !filterFunc(te)){ return; }\r\n\t\t\t\t\tif(9 == root.nodeType){ // if root's a doc, we just return directly\r\n\t\t\t\t\t\treturn getArr(te, arr);\r\n\t\t\t\t\t}else{ // otherwise check ancestry\r\n\t\t\t\t\t\tif(_isDescendant(te, root)){\r\n\t\t\t\t\t\t\treturn getArr(te, arr);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}else if(\r\n\t\t\t\tecs &&\r\n\t\t\t\t// isAlien check. Workaround for Prototype.js being totally evil/dumb.\r\n\t\t\t\t/\\{\\s*\\[native code\\]\\s*\\}/.test(String(ecs)) &&\r\n\t\t\t\tquery.classes.length &&\r\n\t\t\t\t!cssCaseBug\r\n\t\t\t){\r\n\t\t\t\t// it's a class-based query and we've got a fast way to run it.\r\n\r\n\t\t\t\t// ignore class and ID filters since we will have handled both\r\n\t\t\t\tfilterFunc = getSimpleFilterFunc(query, { el: 1, classes: 1, id: 1 });\r\n\t\t\t\tvar classesString = query.classes.join(\" \");\r\n\t\t\t\tretFunc = function(root, arr, bag){\r\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\r\n\t\t\t\t\tvar tret = root.getElementsByClassName(classesString);\r\n\t\t\t\t\twhile((te = tret[x++])){\r\n\t\t\t\t\t\tif(filterFunc(te, root) && _isUnique(te, bag)){\r\n\t\t\t\t\t\t\tret.push(te);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t};\r\n\r\n\t\t\t}else if(!wildcardTag && !query.loops){\r\n\t\t\t\t// it's tag only. Fast-path it.\r\n\t\t\t\tretFunc = function(root, arr, bag){\r\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\r\n\t\t\t\t\tvar tag = query.getTag(),\r\n\t\t\t\t\t\ttret = tag ? root.getElementsByTagName(tag) : [];\r\n\t\t\t\t\twhile((te = tret[x++])){\r\n\t\t\t\t\t\tif(_isUnique(te, bag)){\r\n\t\t\t\t\t\t\tret.push(te);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t};\r\n\t\t\t}else{\r\n\t\t\t\t// the common case:\r\n\t\t\t\t//\t\ta descendant selector without a fast path. By now it's got\r\n\t\t\t\t//\t\tto have a tag selector, even if it's just \"*\" so we query\r\n\t\t\t\t//\t\tby that and filter\r\n\t\t\t\tfilterFunc = getSimpleFilterFunc(query, { el: 1, tag: 1, id: 1 });\r\n\t\t\t\tretFunc = function(root, arr, bag){\r\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\r\n\t\t\t\t\t// we use getTag() to avoid case sensitivity issues\r\n\t\t\t\t\tvar tag = query.getTag(),\r\n\t\t\t\t\t\ttret = tag ? root.getElementsByTagName(tag) : [];\r\n\t\t\t\t\twhile((te = tret[x++])){\r\n\t\t\t\t\t\tif(filterFunc(te, root) && _isUnique(te, bag)){\r\n\t\t\t\t\t\t\tret.push(te);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// the query is scoped in some way. Instead of querying by tag we\r\n\t\t\t// use some other collection to find candidate nodes\r\n\t\t\tvar skipFilters = { el: 1 };\r\n\t\t\tif(wildcardTag){\r\n\t\t\t\tskipFilters.tag = 1;\r\n\t\t\t}\r\n\t\t\tfilterFunc = getSimpleFilterFunc(query, skipFilters);\r\n\t\t\tif(\"+\" == oper){\r\n\t\t\t\tretFunc = _nextSibling(filterFunc);\r\n\t\t\t}else if(\"~\" == oper){\r\n\t\t\t\tretFunc = _nextSiblings(filterFunc);\r\n\t\t\t}else if(\">\" == oper){\r\n\t\t\t\tretFunc = _childElements(filterFunc);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// cache it and return\r\n\t\treturn _getElementsFuncCache[query.query] = retFunc;\r\n\t};\r\n\r\n\tvar filterDown = function(root, queryParts){\r\n\t\t// NOTE:\r\n\t\t//\t\tthis is the guts of the DOM query system. It takes a list of\r\n\t\t//\t\tparsed query parts and a root and finds children which match\r\n\t\t//\t\tthe selector represented by the parts\r\n\t\tvar candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;\r\n\r\n\t\tfor(var i = 0; i < qpl; i++){\r\n\t\t\tret = [];\r\n\t\t\tqp = queryParts[i];\r\n\t\t\tx = candidates.length - 1;\r\n\t\t\tif(x > 0){\r\n\t\t\t\t// if we have more than one root at this level, provide a new\r\n\t\t\t\t// hash to use for checking group membership but tell the\r\n\t\t\t\t// system not to post-filter us since we will already have been\r\n\t\t\t\t// guaranteed to be unique\r\n\t\t\t\tbag = {};\r\n\t\t\t\tret.nozip = true;\r\n\t\t\t}\r\n\t\t\tvar gef = getElementsFunc(qp);\r\n\t\t\tfor(var j = 0; (te = candidates[j]); j++){\r\n\t\t\t\t// for every root, get the elements that match the descendant\r\n\t\t\t\t// selector, adding them to the \"ret\" array and filtering them\r\n\t\t\t\t// via membership in this level's bag. If there are more query\r\n\t\t\t\t// parts, then this level's return will be used as the next\r\n\t\t\t\t// level's candidates\r\n\t\t\t\tgef(te, ret, bag);\r\n\t\t\t}\r\n\t\t\tif(!ret.length){ break; }\r\n\t\t\tcandidates = ret;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n\r\n\t////////////////////////////////////////////////////////////////////////\r\n\t// the query runner\r\n\t////////////////////////////////////////////////////////////////////////\r\n\r\n\t// these are the primary caches for full-query results. The query\r\n\t// dispatcher functions are generated then stored here for hash lookup in\r\n\t// the future\r\n\tvar _queryFuncCacheDOM = {},\r\n\t\t_queryFuncCacheQSA = {};\r\n\r\n\t// this is the second level of splitting, from full-length queries (e.g.,\r\n\t// \"div.foo .bar\") into simple query expressions (e.g., [\"div.foo\",\r\n\t// \".bar\"])\r\n\tvar getStepQueryFunc = function(query){\r\n\t\tvar qparts = getQueryParts(trim(query));\r\n\r\n\t\t// if it's trivial, avoid iteration and zipping costs\r\n\t\tif(qparts.length == 1){\r\n\t\t\t// we optimize this case here to prevent dispatch further down the\r\n\t\t\t// chain, potentially slowing things down. We could more elegantly\r\n\t\t\t// handle this in filterDown(), but it's slower for simple things\r\n\t\t\t// that need to be fast (e.g., \"#someId\").\r\n\t\t\tvar tef = getElementsFunc(qparts[0]);\r\n\t\t\treturn function(root){\r\n\t\t\t\tvar r = tef(root, []);\r\n\t\t\t\tif(r){ r.nozip = true; }\r\n\t\t\t\treturn r;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// otherwise, break it up and return a runner that iterates over the parts recursively\r\n\t\treturn function(root){\r\n\t\t\treturn filterDown(root, qparts);\r\n\t\t};\r\n\t};\r\n\r\n\t// NOTES:\r\n\t//\t* we can't trust QSA for anything but document-rooted queries, so\r\n\t//\t  caching is split into DOM query evaluators and QSA query evaluators\r\n\t//\t* caching query results is dirty and leak-prone (or, at a minimum,\r\n\t//\t  prone to unbounded growth). Other toolkits may go this route, but\r\n\t//\t  they totally destroy their own ability to manage their memory\r\n\t//\t  footprint. If we implement it, it should only ever be with a fixed\r\n\t//\t  total element reference # limit and an LRU-style algorithm since JS\r\n\t//\t  has no weakref support. Caching compiled query evaluators is also\r\n\t//\t  potentially problematic, but even on large documents the size of the\r\n\t//\t  query evaluators is often < 100 function objects per evaluator (and\r\n\t//\t  LRU can be applied if it's ever shown to be an issue).\r\n\t//\t* since IE's QSA support is currently only for HTML documents and even\r\n\t//\t  then only in IE 8's \"standards mode\", we have to detect our dispatch\r\n\t//\t  route at query time and keep 2 separate caches. Ugg.\r\n\r\n\t// we need to determine if we think we can run a given query via\r\n\t// querySelectorAll or if we'll need to fall back on DOM queries to get\r\n\t// there. We need a lot of information about the environment and the query\r\n\t// to make the determination (e.g. does it support QSA, does the query in\r\n\t// question work in the native QSA impl, etc.).\r\n\r\n\t// IE QSA queries may incorrectly include comment nodes, so we throw the\r\n\t// zipping function into \"remove\" comments mode instead of the normal \"skip\r\n\t// it\" which every other QSA-clued browser enjoys\r\n\tvar noZip = has(\"ie\") ? \"commentStrip\" : \"nozip\";\r\n\r\n\tvar qsa = \"querySelectorAll\";\r\n\tvar qsaAvail = !!getDoc()[qsa];\r\n\r\n\t//Don't bother with n+3 type of matches, IE complains if we modify those.\r\n\tvar infixSpaceRe = /\\\\[>~+]|n\\+\\d|([^ \\\\])?([>~+])([^ =])?/g;\r\n\tvar infixSpaceFunc = function(match, pre, ch, post){\r\n\t\treturn ch ? (pre ? pre + \" \" : \"\") + ch + (post ? \" \" + post : \"\") : /*n+3*/ match;\r\n\t};\r\n\t\r\n\t//Don't apply the infixSpaceRe to attribute value selectors\r\n\tvar attRe = /([^[]*)([^\\]]*])?/g;\r\n\tvar attFunc = function(match, nonAtt, att){\r\n\t\treturn nonAtt.replace(infixSpaceRe, infixSpaceFunc) + (att||\"\");\r\n\t};\r\n\tvar getQueryFunc = function(query, forceDOM){\r\n\t\t//Normalize query. The CSS3 selectors spec allows for omitting spaces around\r\n\t\t//infix operators, >, ~ and +\r\n\t\t//Do the work here since detection for spaces is used as a simple \"not use QSA\"\r\n\t\t//test below.\r\n\t\tquery = query.replace(attRe, attFunc);\r\n\r\n\t\tif(qsaAvail){\r\n\t\t\t// if we've got a cached variant and we think we can do it, run it!\r\n\t\t\tvar qsaCached = _queryFuncCacheQSA[query];\r\n\t\t\tif(qsaCached && !forceDOM){ return qsaCached; }\r\n\t\t}\r\n\r\n\t\t// else if we've got a DOM cached variant, assume that we already know\r\n\t\t// all we need to and use it\r\n\t\tvar domCached = _queryFuncCacheDOM[query];\r\n\t\tif(domCached){ return domCached; }\r\n\r\n\t\t// TODO:\r\n\t\t//\t\ttoday we're caching DOM and QSA branches separately so we\r\n\t\t//\t\trecalc useQSA every time. If we had a way to tag root+query\r\n\t\t//\t\tefficiently, we'd be in good shape to do a global cache.\r\n\r\n\t\tvar qcz = query.charAt(0);\r\n\t\tvar nospace = (-1 == query.indexOf(\" \"));\r\n\r\n\t\t// byId searches are wicked fast compared to QSA, even when filtering\r\n\t\t// is required\r\n\t\tif( (query.indexOf(\"#\") >= 0) && (nospace) ){\r\n\t\t\tforceDOM = true;\r\n\t\t}\r\n\r\n\t\tvar useQSA = (\r\n\t\t\tqsaAvail && (!forceDOM) &&\r\n\t\t\t// as per CSS 3, we can't currently start w/ combinator:\r\n\t\t\t//\t\thttp://www.w3.org/TR/css3-selectors/#w3cselgrammar\r\n\t\t\t(specials.indexOf(qcz) == -1) &&\r\n\t\t\t// IE's QSA impl sucks on pseudos\r\n\t\t\t(!has(\"ie\") || (query.indexOf(\":\") == -1)) &&\r\n\r\n\t\t\t(!(cssCaseBug && (query.indexOf(\".\") >= 0))) &&\r\n\r\n\t\t\t// FIXME:\r\n\t\t\t//\t\tneed to tighten up browser rules on \":contains\" and \"|=\" to\r\n\t\t\t//\t\tfigure out which aren't good\r\n\t\t\t//\t\tLatest webkit (around 531.21.8) does not seem to do well with :checked on option\r\n\t\t\t//\t\telements, even though according to spec, selected options should\r\n\t\t\t//\t\tmatch :checked. So go nonQSA for it:\r\n\t\t\t//\t\thttp://bugs.dojotoolkit.org/ticket/5179\r\n\t\t\t(query.indexOf(\":contains\") == -1) && (query.indexOf(\":checked\") == -1) &&\r\n\t\t\t(query.indexOf(\"|=\") == -1) // some browsers don't grok it\r\n\t\t);\r\n\r\n\t\t// TODO:\r\n\t\t//\t\tif we've got a descendant query (e.g., \"> .thinger\" instead of\r\n\t\t//\t\tjust \".thinger\") in a QSA-able doc, but are passed a child as a\r\n\t\t//\t\troot, it should be possible to give the item a synthetic ID and\r\n\t\t//\t\ttrivially rewrite the query to the form \"#synid > .thinger\" to\r\n\t\t//\t\tuse the QSA branch\r\n\r\n\r\n\t\tif(useQSA){\r\n\t\t\tvar tq = (specials.indexOf(query.charAt(query.length-1)) >= 0) ?\r\n\t\t\t\t\t\t(query + \" *\") : query;\r\n\t\t\treturn _queryFuncCacheQSA[query] = function(root){\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// the QSA system contains an egregious spec bug which\r\n\t\t\t\t\t// limits us, effectively, to only running QSA queries over\r\n\t\t\t\t\t// entire documents.  See:\r\n\t\t\t\t\t//\t\thttp://ejohn.org/blog/thoughts-on-queryselectorall/\r\n\t\t\t\t\t//\tdespite this, we can also handle QSA runs on simple\r\n\t\t\t\t\t//\tselectors, but we don't want detection to be expensive\r\n\t\t\t\t\t//\tso we're just checking for the presence of a space char\r\n\t\t\t\t\t//\tright now. Not elegant, but it's cheaper than running\r\n\t\t\t\t\t//\tthe query parser when we might not need to\r\n\t\t\t\t\tif(!((9 == root.nodeType) || nospace)){ throw \"\"; }\r\n\t\t\t\t\tvar r = root[qsa](tq);\r\n\t\t\t\t\t// skip expensive duplication checks and just wrap in a NodeList\r\n\t\t\t\t\tr[noZip] = true;\r\n\t\t\t\t\treturn r;\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\t// else run the DOM branch on this query, ensuring that we\r\n\t\t\t\t\t// default that way in the future\r\n\t\t\t\t\treturn getQueryFunc(query, true)(root);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}else{\r\n\t\t\t// DOM branch\r\n\t\t\tvar parts = query.match(/([^\\s,](?:\"(?:\\\\.|[^\"])+\"|'(?:\\\\.|[^'])+'|[^,])*)/g);\r\n\t\t\treturn _queryFuncCacheDOM[query] = ((parts.length < 2) ?\r\n\t\t\t\t// if not a compound query (e.g., \".foo, .bar\"), cache and return a dispatcher\r\n\t\t\t\tgetStepQueryFunc(query) :\r\n\t\t\t\t// if it *is* a complex query, break it up into its\r\n\t\t\t\t// constituent parts and return a dispatcher that will\r\n\t\t\t\t// merge the parts when run\r\n\t\t\t\tfunction(root){\r\n\t\t\t\t\tvar pindex = 0, // avoid array alloc for every invocation\r\n\t\t\t\t\t\tret = [],\r\n\t\t\t\t\t\ttp;\r\n\t\t\t\t\twhile((tp = parts[pindex++])){\r\n\t\t\t\t\t\tret = ret.concat(getStepQueryFunc(tp)(root));\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n\r\n\tvar _zipIdx = 0;\r\n\r\n\t// NOTE:\r\n\t//\t\tthis function is Moo inspired, but our own impl to deal correctly\r\n\t//\t\twith XML in IE\r\n\tvar _nodeUID = has(\"ie\") ? function(node){\r\n\t\tif(caseSensitive){\r\n\t\t\t// XML docs don't have uniqueID on their nodes\r\n\t\t\treturn (node.getAttribute(\"_uid\") || node.setAttribute(\"_uid\", ++_zipIdx) || _zipIdx);\r\n\r\n\t\t}else{\r\n\t\t\treturn node.uniqueID;\r\n\t\t}\r\n\t} :\r\n\tfunction(node){\r\n\t\treturn (node._uid || (node._uid = ++_zipIdx));\r\n\t};\r\n\r\n\t// determine if a node in is unique in a \"bag\". In this case we don't want\r\n\t// to flatten a list of unique items, but rather just tell if the item in\r\n\t// question is already in the bag. Normally we'd just use hash lookup to do\r\n\t// this for us but IE's DOM is busted so we can't really count on that. On\r\n\t// the upside, it gives us a built in unique ID function.\r\n\tvar _isUnique = function(node, bag){\r\n\t\tif(!bag){ return 1; }\r\n\t\tvar id = _nodeUID(node);\r\n\t\tif(!bag[id]){ return bag[id] = 1; }\r\n\t\treturn 0;\r\n\t};\r\n\r\n\t// attempt to efficiently determine if an item in a list is a dupe,\r\n\t// returning a list of \"uniques\", hopefully in document order\r\n\tvar _zipIdxName = \"_zipIdx\";\r\n\tvar _zip = function(arr){\r\n\t\tif(arr && arr.nozip){ return arr; }\r\n\r\n\t\tif(!arr || !arr.length){ return []; }\r\n\t\tif(arr.length < 2){ return [arr[0]]; }\r\n\r\n\t\tvar ret = [];\r\n\r\n\t\t_zipIdx++;\r\n\r\n\t\t// we have to fork here for IE and XML docs because we can't set\r\n\t\t// expandos on their nodes (apparently). *sigh*\r\n\t\tvar x, te;\r\n\t\tif(has(\"ie\") && caseSensitive){\r\n\t\t\tvar szidx = _zipIdx+\"\";\r\n\t\t\tfor(x = 0; x < arr.length; x++){\r\n\t\t\t\tif((te = arr[x]) && te.getAttribute(_zipIdxName) != szidx){\r\n\t\t\t\t\tret.push(te);\r\n\t\t\t\t\tte.setAttribute(_zipIdxName, szidx);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else if(has(\"ie\") && arr.commentStrip){\r\n\t\t\ttry{\r\n\t\t\t\tfor(x = 0; x < arr.length; x++){\r\n\t\t\t\t\tif((te = arr[x]) && _isElement(te)){\r\n\t\t\t\t\t\tret.push(te);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}catch(e){ /* squelch */ }\r\n\t\t}else{\r\n\t\t\tfor(x = 0; x < arr.length; x++){\r\n\t\t\t\tif((te = arr[x]) && te[_zipIdxName] != _zipIdx){\r\n\t\t\t\t\tret.push(te);\r\n\t\t\t\t\tte[_zipIdxName] = _zipIdx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n\r\n\t// the main executor\r\n\tvar query = function(/*String*/ query, /*String|DOMNode?*/ root){\r\n\t\t// summary:\r\n\t\t//\t\tReturns nodes which match the given CSS3 selector, searching the\r\n\t\t//\t\tentire document by default but optionally taking a node to scope\r\n\t\t//\t\tthe search by. Returns an array.\r\n\t\t// description:\r\n\t\t//\t\tdojo.query() is the swiss army knife of DOM node manipulation in\r\n\t\t//\t\tDojo. Much like Prototype's \"$$\" (bling-bling) function or JQuery's\r\n\t\t//\t\t\"$\" function, dojo.query provides robust, high-performance\r\n\t\t//\t\tCSS-based node selector support with the option of scoping searches\r\n\t\t//\t\tto a particular sub-tree of a document.\r\n\t\t//\r\n\t\t//\t\tSupported Selectors:\r\n\t\t//\t\t--------------------\r\n\t\t//\r\n\t\t//\t\tacme supports a rich set of CSS3 selectors, including:\r\n\t\t//\r\n\t\t//\t\t- class selectors (e.g., `.foo`)\r\n\t\t//\t\t- node type selectors like `span`\r\n\t\t//\t\t- ` ` descendant selectors\r\n\t\t//\t\t- `>` child element selectors\r\n\t\t//\t\t- `#foo` style ID selectors\r\n\t\t//\t\t- `*` universal selector\r\n\t\t//\t\t- `~`, the preceded-by sibling selector\r\n\t\t//\t\t- `+`, the immediately preceded-by sibling selector\r\n\t\t//\t\t- attribute queries:\r\n\t\t//\t\t\t- `[foo]` attribute presence selector\r\n\t\t//\t\t\t- `[foo='bar']` attribute value exact match\r\n\t\t//\t\t\t- `[foo~='bar']` attribute value list item match\r\n\t\t//\t\t\t- `[foo^='bar']` attribute start match\r\n\t\t//\t\t\t- `[foo$='bar']` attribute end match\r\n\t\t//\t\t\t- `[foo*='bar']` attribute substring match\r\n\t\t//\t\t- `:first-child`, `:last-child`, and `:only-child` positional selectors\r\n\t\t//\t\t- `:empty` content emtpy selector\r\n\t\t//\t\t- `:checked` pseudo selector\r\n\t\t//\t\t- `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations\r\n\t\t//\t\t- `:nth-child(even)`, `:nth-child(odd)` positional selectors\r\n\t\t//\t\t- `:not(...)` negation pseudo selectors\r\n\t\t//\r\n\t\t//\t\tAny legal combination of these selectors will work with\r\n\t\t//\t\t`dojo.query()`, including compound selectors (\",\" delimited).\r\n\t\t//\t\tVery complex and useful searches can be constructed with this\r\n\t\t//\t\tpalette of selectors and when combined with functions for\r\n\t\t//\t\tmanipulation presented by dojo/NodeList, many types of DOM\r\n\t\t//\t\tmanipulation operations become very straightforward.\r\n\t\t//\r\n\t\t//\t\tUnsupported Selectors:\r\n\t\t//\t\t----------------------\r\n\t\t//\r\n\t\t//\t\tWhile dojo.query handles many CSS3 selectors, some fall outside of\r\n\t\t//\t\twhat's reasonable for a programmatic node querying engine to\r\n\t\t//\t\thandle. Currently unsupported selectors include:\r\n\t\t//\r\n\t\t//\t\t- namespace-differentiated selectors of any form\r\n\t\t//\t\t- all `::` pseduo-element selectors\r\n\t\t//\t\t- certain pseudo-selectors which don't get a lot of day-to-day use:\r\n\t\t//\t\t\t- `:root`, `:lang()`, `:target`, `:focus`\r\n\t\t//\t\t- all visual and state selectors:\r\n\t\t//\t\t\t- `:root`, `:active`, `:hover`, `:visited`, `:link`,\r\n\t\t//\t\t\t\t  `:enabled`, `:disabled`\r\n\t\t//\t\t\t- `:*-of-type` pseudo selectors\r\n\t\t//\r\n\t\t//\t\tdojo.query and XML Documents:\r\n\t\t//\t\t-----------------------------\r\n\t\t//\r\n\t\t//\t\t`dojo.query` (as of dojo 1.2) supports searching XML documents\r\n\t\t//\t\tin a case-sensitive manner. If an HTML document is served with\r\n\t\t//\t\ta doctype that forces case-sensitivity (e.g., XHTML 1.1\r\n\t\t//\t\tStrict), dojo.query() will detect this and \"do the right\r\n\t\t//\t\tthing\". Case sensitivity is dependent upon the document being\r\n\t\t//\t\tsearched and not the query used. It is therefore possible to\r\n\t\t//\t\tuse case-sensitive queries on strict sub-documents (iframes,\r\n\t\t//\t\tetc.) or XML documents while still assuming case-insensitivity\r\n\t\t//\t\tfor a host/root document.\r\n\t\t//\r\n\t\t//\t\tNon-selector Queries:\r\n\t\t//\t\t---------------------\r\n\t\t//\r\n\t\t//\t\tIf something other than a String is passed for the query,\r\n\t\t//\t\t`dojo.query` will return a new `dojo/NodeList` instance\r\n\t\t//\t\tconstructed from that parameter alone and all further\r\n\t\t//\t\tprocessing will stop. This means that if you have a reference\r\n\t\t//\t\tto a node or NodeList, you can quickly construct a new NodeList\r\n\t\t//\t\tfrom the original by calling `dojo.query(node)` or\r\n\t\t//\t\t`dojo.query(list)`.\r\n\t\t//\r\n\t\t// query:\r\n\t\t//\t\tThe CSS3 expression to match against. For details on the syntax of\r\n\t\t//\t\tCSS3 selectors, see <http://www.w3.org/TR/css3-selectors/#selectors>\r\n\t\t// root:\r\n\t\t//\t\tA DOMNode (or node id) to scope the search from. Optional.\r\n\t\t// returns: Array\r\n\t\t// example:\r\n\t\t//\t\tsearch the entire document for elements with the class \"foo\":\r\n\t\t//\t|\trequire([\"dojo/query\"], function(query) {\r\n\t\t//\t|\t    query(\".foo\").forEach(function(q) { console.log(q); });\r\n\t\t//\t|\t});\r\n\t\t//\t\tthese elements will match:\r\n\t\t//\t|\t<span class=\"foo\"></span>\r\n\t\t//\t|\t<span class=\"foo bar\"></span>\r\n\t\t//\t|\t<p class=\"thud foo\"></p>\r\n\t\t// example:\r\n\t\t//\t\tsearch the entire document for elements with the classes \"foo\" *and* \"bar\":\r\n\t\t//\t|\trequire([\"dojo/query\"], function(query) {\r\n\t\t//\t|\t    query(\".foo.bar\").forEach(function(q) { console.log(q); });\r\n\t\t//\t|\t});\r\n\t\t\r\n\t\t//\t\tthese elements will match:\r\n\t\t//\t|\t<span class=\"foo bar\"></span>\r\n\t\t//\t\twhile these will not:\r\n\t\t//\t|\t<span class=\"foo\"></span>\r\n\t\t//\t|\t<p class=\"thud foo\"></p>\r\n\t\t// example:\r\n\t\t//\t\tfind `<span>` elements which are descendants of paragraphs and\r\n\t\t//\t\twhich have a \"highlighted\" class:\r\n\t\t//\t|\trequire([\"dojo/query\"], function(query) {\r\n\t\t//\t|\t    query(\"p span.highlighted\").forEach(function(q) { console.log(q); });\r\n\t\t//\t|\t});\r\n\t\t//\t\tthe innermost span in this fragment matches:\r\n\t\t//\t|\t<p class=\"foo\">\r\n\t\t//\t|\t\t<span>...\r\n\t\t//\t|\t\t\t<span class=\"highlighted foo bar\">...</span>\r\n\t\t//\t|\t\t</span>\r\n\t\t//\t|\t</p>\r\n\t\t// example:\r\n\t\t//\t\tset an \"odd\" class on all odd table rows inside of the table\r\n\t\t//\t\t`#tabular_data`, using the `>` (direct child) selector to avoid\r\n\t\t//\t\taffecting any nested tables:\r\n\t\t//\t|\trequire([\"dojo/query\"], function(query) {    \r\n\t\t//\t|\t    query(\"#tabular_data > tbody > tr:nth-child(odd)\").addClass(\"odd\");\r\n\t\t//\t|\t);\r\n\t\t// example:\r\n\t\t//\t\tremove all elements with the class \"error\" from the document:\r\n\t\t//\t|\trequire([\"dojo/query\"], function(query) {\r\n\t\t//\t|\t    query(\".error\").orphan();\r\n\t\t//\t|\t);\r\n\t\t// example:\r\n\t\t//\t\tadd an onclick handler to every submit button in the document\r\n\t\t//\t\twhich causes the form to be sent via Ajax instead:\r\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/request\", \"dojo/dom-construct\", \"dojo/dom-style\"\r\n\t\t//\t|\t], function (query, request, domConstruct, domStyle) {\r\n\t\t//\t|\t    query(\"input[type='submit']\").on(\"click\", function (e) {\r\n\t\t//\t|\t        e.stopPropagation();\r\n\t\t//\t|\t        e.preventDefault();\r\n\t\t//\t|\t        var btn = e.target;\r\n\t\t//\t|\t        request.post(\"\", { data: btn.form, timeout: 2000 })\r\n\t\t//\t|\t        .then(function (data) {\r\n\t\t//\t|\t            // replace the form with the response\r\n\t\t//\t|\t            domConstruct.create(\"div\", { innerHTML: data }, btn.form, \"after\");\r\n\t\t//\t|\t            domStyle.set(btn.form, \"display\", \"none\");\r\n\t\t//\t|\t        });\r\n\t\t//\t|\t    });\r\n\t\t//\t|\t});\r\n\r\n\r\n\t\troot = root || getDoc();\r\n\r\n\t\t// throw the big case sensitivity switch\r\n\t\tvar od = root.ownerDocument || root;\t// root is either Document or a node inside the document\r\n\t\tcaseSensitive = (od.createElement(\"div\").tagName === \"div\");\r\n\r\n\t\t// NOTE:\r\n\t\t//\t\tadding \"true\" as the 2nd argument to getQueryFunc is useful for\r\n\t\t//\t\ttesting the DOM branch without worrying about the\r\n\t\t//\t\tbehavior/performance of the QSA branch.\r\n\t\tvar r = getQueryFunc(query)(root);\r\n\r\n\t\t// FIXME:\r\n\t\t//\t\tneed to investigate this branch WRT #8074 and #8075\r\n\t\tif(r && r.nozip){\r\n\t\t\treturn r;\r\n\t\t}\r\n\t\treturn _zip(r); // dojo/NodeList\r\n\t};\r\n\tquery.filter = function(/*Node[]*/ nodeList, /*String*/ filter, /*String|DOMNode?*/ root){\r\n\t\t// summary:\r\n\t\t//\t\tfunction for filtering a NodeList based on a selector, optimized for simple selectors\r\n\t\tvar tmpNodeList = [],\r\n\t\t\tparts = getQueryParts(filter),\r\n\t\t\tfilterFunc =\r\n\t\t\t\t(parts.length == 1 && !/[^\\w#\\.]/.test(filter)) ?\r\n\t\t\t\tgetSimpleFilterFunc(parts[0]) :\r\n\t\t\t\tfunction(node){\r\n\t\t\t\t\treturn array.indexOf(query(filter, dom.byId(root)), node) != -1;\r\n\t\t\t\t};\r\n\t\tfor(var x = 0, te; te = nodeList[x]; x++){\r\n\t\t\tif(filterFunc(te)){ tmpNodeList.push(te); }\r\n\t\t}\r\n\t\treturn tmpNodeList;\r\n\t};\r\n\treturn query;\r\n});\r\n"]}