{"version":3,"sources":["_base/loader.js"],"names":["define","dojo","has","require","thisModule","json","lang","array","console","error","add","makeErrorToken","id","src","slashName","name","replace","buildDetectRe","dojoRequireCallbacks","dojoRequireModuleStack","dojoRequirePlugin","mid","loaded","push","forEach","split","module","getModule","injectModule","checkDojoRequirePlugin","modules","undefined","noReqPluginCheck","test","executed","injected","requested","guardCheckComplete","oldCallbacks","cb","traverse","m","touched","t","deps","i","length","arrived","end","dojoLoadInitPlugin","bundle","names","scopeText","args","arguments","eval","callingModule","requireList","i18nDeps","syncLoaderApi","provide","moduleName","providedModule","setArrived","omitModuleCheck","result","nonmodule","requireLocalization","bundleName","locale","toLowerCase","isXd","loadInit","f","hold","p","def","apply","e","signal","concat","join","extractApplication","text","startSearch","startApplication","match","parenRe","matchCount","lastIndex","exec","trim","substring","removeCommentRe","syncLoaderApiRe","amdLoaderApiRe","extractLegacyApiApplications","noCommentText","application","loadInitApplications","otherApplications","allApplications","transformToAmd","extractResult","namesAsStrings","scopeMap","stringify","loaderVars","initSyncLoader","sync","executing","syncExecStack","execQ","finishExec","execModule","getLegacyMode","executingModule","mixin","getObject","provides","finish","currentMode","cjs","unshift","doRequire","exists","setObject","registerModulePath","prefix","paths","platformRequire","modMap","temp","common","_name","isArray","shift","requireIf","requireAfterIf","condition","i18n","getLocalization"],"mappings":"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","file":"../../_base/loader.js","sourcesContent":["define([\"./kernel\", \"../has\", \"require\", \"module\", \"../json\", \"./lang\", \"./array\"], function(dojo, has, require, thisModule, json, lang, array) {\r\n\t// module:\r\n\t//\t\tdojo/_base/loader\r\n\r\n\t//\t\tThis module defines the v1.x synchronous loader API.\r\n\r\n\t// signal the loader in sync mode...\r\n\t//>>pure-amd\r\n\r\n\tif (!has(\"dojo-loader\")){\r\n\t\tconsole.error(\"cannot load the Dojo v1.x loader with a foreign loader\");\r\n\t\treturn 0;\r\n\t}\r\n\r\n\thas.add(\"dojo-fast-sync-require\", 1);\r\n\r\n\r\n\tvar makeErrorToken = function(id){\r\n\t\t\treturn {src:thisModule.id, id:id};\r\n\t\t},\r\n\r\n\t\tslashName = function(name){\r\n\t\t\treturn name.replace(/\\./g, \"/\");\r\n\t\t},\r\n\r\n\t\tbuildDetectRe = /\\/\\/>>built/,\r\n\r\n\t\tdojoRequireCallbacks = [],\r\n\t\tdojoRequireModuleStack = [],\r\n\r\n\t\tdojoRequirePlugin = function(mid, require, loaded){\r\n\t\t\tdojoRequireCallbacks.push(loaded);\r\n\t\t\tarray.forEach(mid.split(\",\"), function(mid){\r\n\t\t\t\tvar module = getModule(mid, require.module);\r\n\t\t\t\tdojoRequireModuleStack.push(module);\r\n\t\t\t\tinjectModule(module);\r\n\t\t\t});\r\n\t\t\tcheckDojoRequirePlugin();\r\n\t\t},\r\n\r\n\t\tcheckDojoRequirePlugin = (has(\"dojo-fast-sync-require\") ?\r\n\t\t\t// This version of checkDojoRequirePlugin makes the observation that all dojoRequireCallbacks can be released\r\n\t\t\t// when all *non-dojo/require!, dojo/loadInit!* modules are either executed, not requested, or arrived. This is\r\n\t\t\t// the case since there are no more modules the loader is waiting for, therefore, dojo/require! must have\r\n\t\t\t// everything it needs on board.\r\n\t\t\t//\r\n\t\t\t// The potential weakness of this algorithm is that dojo/require will not execute callbacks until *all* dependency\r\n\t\t\t// trees are ready. It is possible that some trees may be ready earlier than others, and this extra wait is non-optimal.\r\n\t\t\t// Still, for big projects, this seems better than the original algorithm below that proved slow in some cases.\r\n\t\t\t// Note, however, the original algorithm had the potential to execute partial trees,  but that potential was never enabled.\r\n\t\t\t// There are also other optimization available with the original algorithm that have not been explored.\r\n\t\t\tfunction(){\r\n\t\t\t\tvar module, mid;\r\n\t\t\t\tfor(mid in modules){\r\n\t\t\t\t\tmodule = modules[mid];\r\n\t\t\t\t\tif(module.noReqPluginCheck===undefined){\r\n\t\t\t\t\t\t// tag the module as either a loadInit or require plugin or not for future reference\r\n\t\t\t\t\t\tmodule.noReqPluginCheck = /loadInit\\!/.test(mid) || /require\\!/.test(mid) ? 1 : 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!module.executed && !module.noReqPluginCheck && module.injected==requested){\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tguardCheckComplete(function(){\r\n\t\t\t\t\tvar oldCallbacks = dojoRequireCallbacks;\r\n\t\t\t\t\tdojoRequireCallbacks = [];\r\n\t\t\t\t\tarray.forEach(oldCallbacks, function(cb){cb(1);});\r\n\t\t\t\t});\r\n\t\t} : (function(){\r\n\t\t\t// Note: this is the original checkDojoRequirePlugin that is much slower than the algorithm above. However, we know it\r\n\t\t\t// works, so we leave it here in case the algorithm above fails in some corner case.\r\n\t\t\t//\r\n\t\t\t// checkDojoRequirePlugin inspects all of the modules demanded by a dojo/require!<module-list> dependency\r\n\t\t\t// to see if they have arrived. The loader does not release *any* of these modules to be instantiated\r\n\t\t\t// until *all* of these modules are on board, thereby preventing the evaluation of a module with dojo.require's\r\n\t\t\t// that reference modules that are not available.\r\n\t\t\t//\r\n\t\t\t// The algorithm works by traversing the dependency graphs (remember, there can be cycles so they are not trees)\r\n\t\t\t// of each module in the dojoRequireModuleStack array (which contains the list of modules demanded by dojo/require!).\r\n\t\t\t// The moment a single module is discovered that is missing, the algorithm gives up and indicates that not all\r\n\t\t\t// modules are on board. dojo/loadInit! and dojo/require! are ignored because there dependencies are inserted\r\n\t\t\t// directly in dojoRequireModuleStack. For example, if \"your/module\" module depends on \"dojo/require!my/module\", then\r\n\t\t\t// *both* \"dojo/require!my/module\" and \"my/module\" will be in dojoRequireModuleStack. Obviously, if \"my/module\"\r\n\t\t\t// is on board, then \"dojo/require!my/module\" is also satisfied, so the algorithm doesn't check for \"dojo/require!my/module\".\r\n\t\t\t//\r\n\t\t\t// Note: inserting a dojo/require!<some-module-list> dependency in the dojoRequireModuleStack achieves nothing\r\n\t\t\t// with the current algorithm; however, having such modules present makes it possible to optimize the algorithm\r\n\t\t\t//\r\n\t\t\t// Note: prior versions of this algorithm had an optimization that signaled loaded on dojo/require! dependencies\r\n\t\t\t// individually (rather than waiting for them all to be resolved). The implementation proved problematic with cycles\r\n\t\t\t// and plugins. However, it is possible to reattach that strategy in the future.\r\n\r\n\t\t\t// a set from module-id to {undefined | 1 | 0}, where...\r\n\t\t\t//\t undefined => the module has not been inspected\r\n\t\t\t//\t 0 => the module or at least one of its dependencies has not arrived\r\n\t\t\t//\t 1 => the module is a loadInit! or require! plugin resource, or is currently being traversed (therefore, assume\r\n\t\t\t//\t\t  OK until proven otherwise), or has been completely traversed and all dependencies have arrived\r\n\r\n\t\t\tvar touched,\r\n\t\t\ttraverse = function(m){\r\n\t\t\t\ttouched[m.mid] = 1;\r\n\t\t\t\tfor(var t, module, deps = m.deps || [], i= 0; i<deps.length; i++){\r\n\t\t\t\t\tmodule = deps[i];\r\n\t\t\t\t\tif(!(t = touched[module.mid])){\r\n\t\t\t\t\t\tif(t===0 || !traverse(module)){\r\n\t\t\t\t\t\t\ttouched[m.mid] = 0;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\r\n\t\t\treturn function(){\r\n\t\t\t\t// initialize the touched hash with easy-to-compute values that help short circuit recursive algorithm;\r\n\t\t\t\t// recall loadInit/require plugin modules are dependencies of modules in dojoRequireModuleStack...\r\n\t\t\t\t// which would cause a circular dependency chain that would never be resolved if checked here\r\n\t\t\t\t// notice all dependencies of any particular loadInit/require plugin module will already\r\n\t\t\t\t// be checked since those are pushed into dojoRequireModuleStack explicitly by the\r\n\t\t\t\t// plugin...so if a particular loadInitPlugin module's dependencies are not really\r\n\t\t\t\t// on board, that *will* be detected elsewhere in the traversal.\r\n\t\t\t\tvar module, mid;\r\n\t\t\t\ttouched = {};\r\n\t\t\t\tfor(mid in modules){\r\n\t\t\t\t\tmodule = modules[mid];\r\n\t\t\t\t\tif(module.executed || module.noReqPluginCheck){\r\n\t\t\t\t\t\ttouched[mid] = 1;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(module.noReqPluginCheck!==0){\r\n\t\t\t\t\t\t\t// tag the module as either a loadInit or require plugin or not for future reference\r\n\t\t\t\t\t\t\tmodule.noReqPluginCheck = /loadInit\\!/.test(mid) || /require\\!/.test(mid) ? 1 : 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(module.noReqPluginCheck){\r\n\t\t\t\t\t\t\ttouched[mid] = 1;\r\n\t\t\t\t\t\t}else if(module.injected!==arrived){\r\n\t\t\t\t\t\t\t// not executed, has not arrived, and is not a loadInit or require plugin resource\r\n\t\t\t\t\t\t\ttouched[mid] = 0;\r\n\t\t\t\t\t\t}// else, leave undefined and we'll traverse the dependencies\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor(var t, i = 0, end = dojoRequireModuleStack.length; i<end; i++){\r\n\t\t\t\t\tmodule = dojoRequireModuleStack[i];\r\n\t\t\t\t\tif(!(t = touched[module.mid])){\r\n\t\t\t\t\t\tif(t===0 || !traverse(module)){\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tguardCheckComplete(function(){\r\n\t\t\t\t\tvar oldCallbacks = dojoRequireCallbacks;\r\n\t\t\t\t\tdojoRequireCallbacks = [];\r\n\t\t\t\t\tarray.forEach(oldCallbacks, function(cb){cb(1);});\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t})()),\r\n\r\n\t\tdojoLoadInitPlugin = function(mid, require, loaded){\r\n\t\t\t// mid names a module that defines a \"dojo load init\" bundle, an object with two properties:\r\n\t\t\t//\r\n\t\t\t//\t * names: a vector of module ids that give top-level names to define in the lexical scope of def\r\n\t\t\t//\t * def: a function that contains some some legacy loader API applications\r\n\t\t\t//\r\n\t\t\t// The point of def is to possibly cause some modules to be loaded (but not executed) by dojo/require! where the module\r\n\t\t\t// ids are possibly-determined at runtime. For example, here is dojox.gfx from v1.6 expressed as an AMD module using the dojo/loadInit\r\n\t\t\t// and dojo/require plugins.\r\n\t\t\t//\r\n\t\t\t// // dojox/gfx:\r\n\t\t\t//\r\n\t\t\t//\t define(\"*loadInit_12, {\r\n\t\t\t//\t   names:[\"dojo\", \"dijit\", \"dojox\"],\r\n\t\t\t//\t   def: function(){\r\n\t\t\t//\t\t dojo.loadInit(function(){\r\n\t\t\t//\t\t   var gfx = lang.getObject(\"dojox.gfx\", true);\r\n\t\t\t//\r\n\t\t\t//\t\t   //\r\n\t\t\t//\t\t   // code required to set gfx properties ommitted...\r\n\t\t\t//\t\t   //\r\n\t\t\t//\r\n\t\t\t//\t\t   // now use the calculations to include the runtime-dependent module\r\n\t\t\t//\t\t   dojo.require(\"dojox.gfx.\" + gfx.renderer);\r\n\t\t\t//\t\t });\r\n\t\t\t//\t   }\r\n\t\t\t//\t });\r\n\t\t\t//\r\n\t\t\t//\t define([\"dojo\", \"dojo/loadInit!\" + id].concat(\"dojo/require!dojox/gfx/matric,dojox/gfx/_base\"), function(dojo){\r\n\t\t\t//\t   // when this AMD factory function is executed, the following modules are guaranteed downloaded but not executed:\r\n\t\t\t//\t   //\t\"dojox.gfx.\" + gfx.renderer\r\n\t\t\t//\t   //\tdojox.gfx.matrix\r\n\t\t\t//\t   //\tdojox.gfx._base\r\n\t\t\t//\t   dojo.provide(\"dojo.gfx\");\r\n\t\t\t//\t   dojo.require(\"dojox.gfx.matrix\");\r\n\t\t\t//\t   dojo.require(\"dojox.gfx._base\");\r\n\t\t\t//\t   dojo.require(\"dojox.gfx.\" + gfx.renderer);\r\n\t\t\t//\t   return lang.getObject(\"dojo.gfx\");\r\n\t\t\t//\t });\r\n\t\t\t//\t})();\r\n\t\t\t//\r\n\t\t\t// The idea is to run the legacy loader API with global variables shadowed, which allows these variables to\r\n\t\t\t// be relocated. For example, dojox and dojo could be relocated to different names by giving a map and the code above will\r\n\t\t\t// execute properly (because the plugin below resolves the load init bundle.names module with respect to the module that demanded\r\n\t\t\t// the plugin resource).\r\n\t\t\t//\r\n\t\t\t// Note that the relocation is specified in the runtime configuration; relocated names need not be set at build-time.\r\n\t\t\t//\r\n\t\t\t// Warning: this is not the best way to express dojox.gfx as and AMD module. In fact, the module has been properly converted in\r\n\t\t\t// v1.7. However, this technique allows the builder to convert legacy modules into AMD modules and guarantee the codepath is the\r\n\t\t\t// same in the converted AMD module.\r\n\t\t\trequire([mid], function(bundle){\r\n\t\t\t\t// notice how names is resolved with respect to the module that demanded the plugin resource\r\n\t\t\t\trequire(bundle.names, function(){\r\n\t\t\t\t\t// bring the bundle names into scope\r\n\t\t\t\t\tfor(var scopeText = \"\", args= [], i = 0; i<arguments.length; i++){\r\n\t\t\t\t\t\tscopeText+= \"var \" + bundle.names[i] + \"= arguments[\" + i + \"]; \";\r\n\t\t\t\t\t\targs.push(arguments[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\teval(scopeText);\r\n\r\n\t\t\t\t\tvar callingModule = require.module,\r\n\t\t\t\t\t\t// the list of modules that need to be downloaded but not executed before the callingModule can be executed\r\n\t\t\t\t\t\trequireList = [],\r\n\r\n\t\t\t\t\t\t// the list of i18n bundles that are xdomain; undefined if none\r\n\t\t\t\t\t\ti18nDeps,\r\n\r\n\t\t\t\t\t\tsyncLoaderApi = {\r\n\t\t\t\t\t\t\tprovide:function(moduleName){\r\n\t\t\t\t\t\t\t\t// mark modules that arrive consequent to multiple provides in this module as arrived since they can't be injected\r\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName);\r\n\t\t\t\t\t\t\t\tvar providedModule = getModule(moduleName, callingModule);\r\n\t\t\t\t\t\t\t\tif(providedModule!==callingModule){\r\n\t\t\t\t\t\t\t\t\tsetArrived(providedModule);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\trequire:function(moduleName, omitModuleCheck){\r\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName);\r\n\t\t\t\t\t\t\t\tomitModuleCheck && (getModule(moduleName, callingModule).result = nonmodule);\r\n\t\t\t\t\t\t\t\trequireList.push(moduleName);\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\trequireLocalization:function(moduleName, bundleName, locale){\r\n\t\t\t\t\t\t\t\t// since we're going to need dojo/i8n, add it to i18nDeps if not already there\r\n\t\t\t\t\t\t\t\tif(!i18nDeps){\r\n\t\t\t\t\t\t\t\t\t// don't have to map since that will occur when the dependency is resolved\r\n\t\t\t\t\t\t\t\t\ti18nDeps = [\"dojo/i18n\"]; \r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// figure out if the bundle is xdomain; if so, add it to the i18nDepsSet\r\n\t\t\t\t\t\t\t\tlocale = (locale || dojo.locale).toLowerCase();\r\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName) + \"/nls/\" + (/root/i.test(locale) ? \"\" : locale + \"/\") + slashName(bundleName);\r\n\t\t\t\t\t\t\t\tif(getModule(moduleName, callingModule).isXd){\r\n\t\t\t\t\t\t\t\t\t// don't have to map since that will occur when the dependency is resolved\r\n\t\t\t\t\t\t\t\t\ti18nDeps.push(\"dojo/i18n!\" + moduleName);\r\n\t\t\t\t\t\t\t\t}// else the bundle will be loaded synchronously when the module is evaluated\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tloadInit:function(f){\r\n\t\t\t\t\t\t\t\tf();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\thold = {},\r\n\t\t\t\t\t\tp;\r\n\r\n\t\t\t\t\t// hijack the correct dojo and apply bundle.def\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tfor(p in syncLoaderApi){\r\n\t\t\t\t\t\t\thold[p] = dojo[p];\r\n\t\t\t\t\t\t\tdojo[p] = syncLoaderApi[p];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbundle.def.apply(null, args);\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tsignal(\"error\", [makeErrorToken(\"failedDojoLoadInit\"), e]);\r\n\t\t\t\t\t}finally{\r\n\t\t\t\t\t\tfor(p in syncLoaderApi){\r\n\t\t\t\t\t\t\tdojo[p] = hold[p];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(i18nDeps){\r\n\t\t\t\t\t\trequireList = requireList.concat(i18nDeps);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(requireList.length){\r\n\t\t\t\t\t\tdojoRequirePlugin(requireList.join(\",\"), require, loaded);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tloaded();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\textractApplication = function(\r\n\t\t\ttext,\t\t\t  // the text to search\r\n\t\t\tstartSearch,\t  // the position in text to start looking for the closing paren\r\n\t\t\tstartApplication  // the position in text where the function application expression starts\r\n\t\t){\r\n\t\t\t// find end of the call by finding the matching end paren\r\n\t\t\t// Warning: as usual, this will fail in the presence of unmatched right parans contained in strings, regexs, or unremoved comments\r\n\t\t\tvar parenRe = /\\(|\\)/g,\r\n\t\t\t\tmatchCount = 1,\r\n\t\t\t\tmatch;\r\n\t\t\tparenRe.lastIndex = startSearch;\r\n\t\t\twhile((match = parenRe.exec(text))){\r\n\t\t\t\tif(match[0] == \")\"){\r\n\t\t\t\t\tmatchCount -= 1;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tmatchCount += 1;\r\n\t\t\t\t}\r\n\t\t\t\tif(matchCount == 0){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(matchCount != 0){\r\n\t\t\t\tthrow \"unmatched paren around character \" + parenRe.lastIndex + \" in: \" + text;\r\n\t\t\t}\r\n\r\n\t\t\t//Put the master matching string in the results.\r\n\t\t\treturn [dojo.trim(text.substring(startApplication, parenRe.lastIndex))+\";\\n\", parenRe.lastIndex];\r\n\t\t},\r\n\r\n\t\t// the following regex is taken from 1.6. It is a very poor technique to remove comments and\r\n\t\t// will fail in some cases; for example, consider the code...\r\n\t\t//\r\n\t\t//\t  var message = \"Category-1 */* Category-2\";\r\n\t\t//\r\n\t\t// The regex that follows will see a /* comment and trash the code accordingly. In fact, there are all\r\n\t\t// kinds of cases like this with strings and regexs that will cause this design to fail miserably.\r\n\t\t//\r\n\t\t// Alternative regex designs exist that will result in less-likely failures, but will still fail in many cases.\r\n\t\t// The only solution guaranteed 100% correct is to parse the code and that seems overkill for this\r\n\t\t// backcompat/unbuilt-xdomain layer. In the end, since it's been this way for a while, we won't change it.\r\n\t\t// See the opening paragraphs of Chapter 7 or ECME-262 which describes the lexical abiguity further.\r\n\t\tremoveCommentRe = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\r\n\r\n\t\tsyncLoaderApiRe = /(^|\\s)dojo\\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\\s*\\(/mg,\r\n\r\n\t\tamdLoaderApiRe = /(^|\\s)(require|define)\\s*\\(/m,\r\n\r\n\t\textractLegacyApiApplications = function(text, noCommentText){\r\n\t\t\t// scan the noCommentText for any legacy loader API applications. Copy such applications into result (this is\r\n\t\t\t// used by the builder). Move dojo.loadInit applications to loadInitApplications string. Copy all other applications\r\n\t\t\t// to otherApplications string. If no applications were found, return 0, signalling an AMD module. Otherwise, return\r\n\t\t\t// loadInitApplications + otherApplications. Fixup text by replacing\r\n\t\t\t//\r\n\t\t\t//\t dojo.loadInit(// etc...\r\n\t\t\t//\r\n\t\t\t// with\r\n\t\t\t//\r\n\t\t\t//\t \\n 0 && dojo.loadInit(// etc...\r\n\t\t\t//\r\n\t\t\t// Which results in the dojo.loadInit from *not* being applied. This design goes a long way towards protecting the\r\n\t\t\t// code from an over-agressive removeCommentRe. However...\r\n\t\t\t//\r\n\t\t\t// WARNING: the removeCommentRe will cause an error if a detected comment removes all or part of a legacy-loader application\r\n\t\t\t// that is not in a comment.\r\n\r\n\t\t\tvar match, startSearch, startApplication, application,\r\n\t\t\t\tloadInitApplications = [],\r\n\t\t\t\totherApplications = [],\r\n\t\t\t\tallApplications = [];\r\n\r\n\t\t\t// noCommentText may be provided by a build app with comments extracted by a better method than regex (hopefully)\r\n\t\t\tnoCommentText = noCommentText || text.replace(removeCommentRe, function(match){\r\n\t\t\t\t// remove iff the detected comment has text that looks like a sync loader API application; this helps by\r\n\t\t\t\t// removing as little as possible, minimizing the changes the janky regex will kill the module\r\n\t\t\t\tsyncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = 0;\r\n\t\t\t\treturn (syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match)) ? \"\" : match;\r\n\t\t\t});\r\n\r\n\t\t\t// find and extract all dojo.loadInit applications\r\n\t\t\twhile((match = syncLoaderApiRe.exec(noCommentText))){\r\n\t\t\t\tstartSearch = syncLoaderApiRe.lastIndex;\r\n\t\t\t\tstartApplication = startSearch\t- match[0].length;\r\n\t\t\t\tapplication = extractApplication(noCommentText, startSearch, startApplication);\r\n\t\t\t\tif(match[2]==\"loadInit\"){\r\n\t\t\t\t\tloadInitApplications.push(application[0]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\totherApplications.push(application[0]);\r\n\t\t\t\t}\r\n\t\t\t\tsyncLoaderApiRe.lastIndex = application[1];\r\n\t\t\t}\r\n\t\t\tallApplications = loadInitApplications.concat(otherApplications);\r\n\t\t\tif(allApplications.length || !amdLoaderApiRe.test(noCommentText)){\r\n\t\t\t\t// either there were some legacy loader API applications or there were no AMD API applications\r\n\t\t\t\treturn [text.replace(/(^|\\s)dojo\\.loadInit\\s*\\(/g, \"\\n0 && dojo.loadInit(\"), allApplications.join(\"\"), allApplications];\r\n\t\t\t}else{\r\n\t\t\t\t// legacy loader API *was not* detected and AMD API *was* detected; therefore, assume it's an AMD module\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttransformToAmd = function(module, text){\r\n\t\t\t// This is roughly the equivalent of dojo._xdCreateResource in 1.6-; however, it expresses a v1.6- dojo\r\n\t\t\t// module in terms of AMD define instead of creating the dojo proprietary xdomain module expression.\r\n\t\t\t// The module could have originated from several sources:\r\n\t\t\t//\r\n\t\t\t//\t * amd require() a module, e.g., require([\"my/module\"])\r\n\t\t\t//\t * amd require() a nonmodule, e.g., require([\"my/resource.js\"')\r\n\t\t\t//\t * amd define() deps vector (always a module)\r\n\t\t\t//\t * dojo.require() a module, e.g. dojo.require(\"my.module\")\r\n\t\t\t//\t * dojo.require() a nonmodule, e.g., dojo.require(\"my.module\", true)\r\n\t\t\t//\t * dojo.requireIf/requireAfterIf/platformRequire a module\r\n\t\t\t//\r\n\t\t\t// The module is scanned for legacy loader API applications; if none are found, then assume the module is an\r\n\t\t\t// AMD module and return 0. Otherwise, a synthetic dojo/loadInit plugin resource is created and the module text\r\n\t\t\t// is rewritten as an AMD module with the single dependency of this synthetic resource. When the dojo/loadInit\r\n\t\t\t// plugin loaded the synthetic resource, it will cause all dojo.loadInit's to be executed, find all dojo.require's\r\n\t\t\t// (either directly consequent to dojo.require or indirectly consequent to dojo.require[After]If or\r\n\t\t\t// dojo.platformRequire, and finally cause loading of all dojo.required modules with the dojo/require plugin. Thus,\r\n\t\t\t// when the dojo/loadInit plugin reports it has been loaded, all modules required by the given module are guaranteed\r\n\t\t\t// loaded (but not executed). This then allows the module to execute it's code path without interupts, thereby\r\n\t\t\t// following the synchronous code path.\r\n\t\t\t//\r\n\t\t\t// Notice that this function behaves the same whether or not it happens to be in a mapped dojo/loader module.\r\n\r\n\t\t\tvar extractResult, id, names = [], namesAsStrings = [];\r\n\t\t\tif(buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))){\r\n\t\t\t\t// buildDetectRe.test(text) => a built module, always AMD\r\n\t\t\t\t// extractResult==0 => no sync API\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\t// manufacture a synthetic module id that can never be a real mdule id (just like require does)\r\n\t\t\tid = module.mid + \"-*loadInit\";\r\n\r\n\t\t\t// construct the dojo/loadInit names vector which causes any relocated names to be defined as lexical variables under their not-relocated name\r\n\t\t\t// the dojo/loadInit plugin assumes the first name in names is \"dojo\"\r\n\r\n\t\t\tfor(var p in getModule(\"dojo\", module).result.scopeMap){\r\n\t\t\t\tnames.push(p);\r\n\t\t\t\tnamesAsStrings.push('\"' + p + '\"');\r\n\t\t\t}\r\n\r\n\t\t\t// rewrite the module as a synthetic dojo/loadInit plugin resource + the module expressed as an AMD module that depends on this synthetic resource\r\n\t\t\t// don't have to map dojo/init since that will occur when the dependency is resolved\r\n\t\t\treturn \"// xdomain rewrite of \" + module.mid + \"\\n\" +\r\n\t\t\t\t\"define('\" + id + \"',{\\n\" +\r\n\t\t\t\t\"\\tnames:\" + json.stringify(names) + \",\\n\" +\r\n\t\t\t\t\"\\tdef:function(\" + names.join(\",\") + \"){\" + extractResult[1] + \"}\" +\r\n\t\t\t\t\"});\\n\\n\" +\r\n\t\t\t\t\"define(\" + json.stringify(names.concat([\"dojo/loadInit!\"+id])) + \", function(\" + names.join(\",\") + \"){\\n\" + extractResult[0] + \"});\";\r\n\t\t},\r\n\r\n\t\tloaderVars = require.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd),\r\n\r\n\t\tsync =\r\n\t\t\tloaderVars.sync,\r\n\r\n\t\trequested =\r\n\t\t\tloaderVars.requested,\r\n\r\n\t\tarrived =\r\n\t\t\tloaderVars.arrived,\r\n\r\n\t\tnonmodule =\r\n\t\t\tloaderVars.nonmodule,\r\n\r\n\t\texecuting =\r\n\t\t\tloaderVars.executing,\r\n\r\n\t\texecuted =\r\n\t\t\tloaderVars.executed,\r\n\r\n\t\tsyncExecStack =\r\n\t\t\tloaderVars.syncExecStack,\r\n\r\n\t\tmodules =\r\n\t\t\tloaderVars.modules,\r\n\r\n\t\texecQ =\r\n\t\t\tloaderVars.execQ,\r\n\r\n\t\tgetModule =\r\n\t\t\tloaderVars.getModule,\r\n\r\n\t\tinjectModule =\r\n\t\t\tloaderVars.injectModule,\r\n\r\n\t\tsetArrived =\r\n\t\t\tloaderVars.setArrived,\r\n\r\n\t\tsignal =\r\n\t\t\tloaderVars.signal,\r\n\r\n\t\tfinishExec =\r\n\t\t\tloaderVars.finishExec,\r\n\r\n\t\texecModule =\r\n\t\t\tloaderVars.execModule,\r\n\r\n\t\tgetLegacyMode =\r\n\t\t\tloaderVars.getLegacyMode,\r\n\r\n\t\tguardCheckComplete =\r\n\t\t\tloaderVars.guardCheckComplete;\r\n\r\n\t// there is exactly one dojoRequirePlugin among possibly-many dojo/_base/loader's (owing to mapping)\r\n\tdojoRequirePlugin = loaderVars.dojoRequirePlugin;\r\n\r\n\tdojo.provide = function(mid){\r\n\t\tvar executingModule = syncExecStack[0],\r\n\t\t\tmodule = lang.mixin(getModule(slashName(mid), require.module), {\r\n\t\t\t\texecuted:executing,\r\n\t\t\t\tresult:lang.getObject(mid, true)\r\n\t\t\t});\r\n\t\tsetArrived(module);\r\n\t\tif(executingModule){\r\n\t\t\t(executingModule.provides || (executingModule.provides = [])).push(function(){\r\n\t\t\t\tmodule.result = lang.getObject(mid);\r\n\t\t\t\tdelete module.provides;\r\n\t\t\t\tmodule.executed!==executed && finishExec(module);\r\n\t\t\t});\r\n\t\t}// else dojo.provide called not consequent to loading; therefore, give up trying to publish module value to loader namespace\r\n\t\treturn module.result;\r\n\t};\r\n\r\n\thas.add(\"config-publishRequireResult\", 1, 0, 0);\r\n\r\n\tdojo.require = function(moduleName, omitModuleCheck) {\r\n\t\t// summary:\r\n\t\t//\t\tloads a Javascript module from the appropriate URI\r\n\t\t//\r\n\t\t// moduleName: String\r\n\t\t//\t\tmodule name to load, using periods for separators,\r\n\t\t//\t\t e.g. \"dojo.date.locale\".  Module paths are de-referenced by dojo's\r\n\t\t//\t\tinternal mapping of locations to names and are disambiguated by\r\n\t\t//\t\tlongest prefix. See `dojo.registerModulePath()` for details on\r\n\t\t//\t\tregistering new modules.\r\n\t\t//\r\n\t\t// omitModuleCheck: Boolean?\r\n\t\t//\t\tif `true`, omitModuleCheck skips the step of ensuring that the\r\n\t\t//\t\tloaded file actually defines the symbol it is referenced by.\r\n\t\t//\t\tFor example if it called as `dojo.require(\"a.b.c\")` and the\r\n\t\t//\t\tfile located at `a/b/c.js` does not define an object `a.b.c`,\r\n\t\t//\t\tand exception will be throws whereas no exception is raised\r\n\t\t//\t\twhen called as `dojo.require(\"a.b.c\", true)`\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tModules are loaded via dojo.require by using one of two loaders: the normal loader\r\n\t\t//\t\tand the xdomain loader. The xdomain loader is used when dojo was built with a\r\n\t\t//\t\tcustom build that specified loader=xdomain and the module lives on a modulePath\r\n\t\t//\t\tthat is a whole URL, with protocol and a domain. The versions of Dojo that are on\r\n\t\t//\t\tthe Google and AOL CDNs use the xdomain loader.\r\n\t\t//\r\n\t\t//\t\tIf the module is loaded via the xdomain loader, it is an asynchronous load, since\r\n\t\t//\t\tthe module is added via a dynamically created script tag. This\r\n\t\t//\t\tmeans that dojo.require() can return before the module has loaded. However, this\r\n\t\t//\t\tshould only happen in the case where you do dojo.require calls in the top-level\r\n\t\t//\t\tHTML page, or if you purposely avoid the loader checking for dojo.require\r\n\t\t//\t\tdependencies in your module by using a syntax like dojo[\"require\"] to load the module.\r\n\t\t//\r\n\t\t//\t\tSometimes it is useful to not have the loader detect the dojo.require calls in the\r\n\t\t//\t\tmodule so that you can dynamically load the modules as a result of an action on the\r\n\t\t//\t\tpage, instead of right at module load time.\r\n\t\t//\r\n\t\t//\t\tAlso, for script blocks in an HTML page, the loader does not pre-process them, so\r\n\t\t//\t\tit does not know to download the modules before the dojo.require calls occur.\r\n\t\t//\r\n\t\t//\t\tSo, in those two cases, when you want on-the-fly module loading or for script blocks\r\n\t\t//\t\tin the HTML page, special care must be taken if the dojo.required code is loaded\r\n\t\t//\t\tasynchronously. To make sure you can execute code that depends on the dojo.required\r\n\t\t//\t\tmodules, be sure to add the code that depends on the modules in a dojo.addOnLoad()\r\n\t\t//\t\tcallback. dojo.addOnLoad waits for all outstanding modules to finish loading before\r\n\t\t//\t\texecuting.\r\n\t\t//\r\n\t\t//\t\tThis type of syntax works with both xdomain and normal loaders, so it is good\r\n\t\t//\t\tpractice to always use this idiom for on-the-fly code loading and in HTML script\r\n\t\t//\t\tblocks. If at some point you change loaders and where the code is loaded from,\r\n\t\t//\t\tit will all still work.\r\n\t\t//\r\n\t\t//\t\tMore on how dojo.require\r\n\t\t//\t\t`dojo.require(\"A.B\")` first checks to see if symbol A.B is\r\n\t\t//\t\tdefined. If it is, it is simply returned (nothing to do).\r\n\t\t//\r\n\t\t//\t\tIf it is not defined, it will look for `A/B.js` in the script root\r\n\t\t//\t\tdirectory.\r\n\t\t//\r\n\t\t//\t\t`dojo.require` throws an exception if it cannot find a file\r\n\t\t//\t\tto load, or if the symbol `A.B` is not defined after loading.\r\n\t\t//\r\n\t\t//\t\tIt returns the object `A.B`, but note the caveats above about on-the-fly loading and\r\n\t\t//\t\tHTML script blocks when the xdomain loader is loading a module.\r\n\t\t//\r\n\t\t//\t\t`dojo.require()` does nothing about importing symbols into\r\n\t\t//\t\tthe current namespace.\tIt is presumed that the caller will\r\n\t\t//\t\ttake care of that.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tTo use dojo.require in conjunction with dojo.ready:\r\n\t\t//\r\n\t\t//\t\t|\tdojo.require(\"foo\");\r\n\t\t//\t\t|\tdojo.require(\"bar\");\r\n\t\t//\t\t|\tdojo.addOnLoad(function(){\r\n\t\t//\t\t|\t\t//you can now safely do something with foo and bar\r\n\t\t//\t\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tFor example, to import all symbols into a local block, you might write:\r\n\t\t//\r\n\t\t//\t\t|\twith (dojo.require(\"A.B\")) {\r\n\t\t//\t\t|\t\t...\r\n\t\t//\t\t|\t}\r\n\t\t//\r\n\t\t//\t\tAnd to import just the leaf symbol to a local variable:\r\n\t\t//\r\n\t\t//\t\t|\tvar B = dojo.require(\"A.B\");\r\n\t\t//\t\t|\t...\r\n\t\t//\r\n\t\t// returns:\r\n\t\t//\t\tthe required namespace object\r\n\t\tfunction doRequire(mid, omitModuleCheck){\r\n\t\t\tvar module = getModule(slashName(mid), require.module);\r\n\t\t\tif(syncExecStack.length && syncExecStack[0].finish){\r\n\t\t\t\t// switched to async loading in the middle of evaluating a legacy module; stop\r\n\t\t\t\t// applying dojo.require so the remaining dojo.requires are applied in order\r\n\t\t\t\tsyncExecStack[0].finish.push(mid);\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\r\n\t\t\t// recall module.executed has values {0, executing, executed}; therefore, truthy indicates executing or executed\r\n\t\t\tif(module.executed){\r\n\t\t\t\treturn module.result;\r\n\t\t\t}\r\n\t\t\tomitModuleCheck && (module.result = nonmodule);\r\n\r\n\t\t\t// rcg...why here and in two lines??\r\n\t\t\tvar currentMode = getLegacyMode();\r\n\r\n\t\t\t// recall, in sync mode to inject is to *eval* the module text\r\n\t\t\t// if the module is a legacy module, this is the same as executing\r\n\t\t\t// but if the module is an AMD module, this means defining, not executing\r\n\t\t\tinjectModule(module);\r\n\t\t\t// the inject may have changed the mode\r\n\t\t\tcurrentMode = getLegacyMode();\r\n\r\n\t\t\t// in sync mode to dojo.require is to execute\r\n\t\t\tif(module.executed!==executed && module.injected===arrived){\r\n\t\t\t\t// the module was already here before injectModule was called probably finishing up a xdomain\r\n\t\t\t\t// load, but maybe a module given to the loader directly rather than having the loader retrieve it\r\n\r\n\t\t\t\tloaderVars.guardCheckComplete(function(){\r\n\t\t\t\t\texecModule(module);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif(module.executed){\r\n\t\t\t\treturn module.result;\r\n\t\t\t}\r\n\r\n\t\t\tif(currentMode==sync){\r\n\t\t\t\t// the only way to get here is in sync mode and dojo.required a module that\r\n\t\t\t\t//\t * was loaded async in the injectModule application a few lines up\r\n\t\t\t\t//\t * was an AMD module that had deps that are being loaded async and therefore couldn't execute\r\n\t\t\t\tif(module.cjs){\r\n\t\t\t\t\t// the module was an AMD module; unshift, not push, which causes the current traversal to be reattempted from the top\r\n\t\t\t\t\texecQ.unshift(module);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// the module was a legacy module\r\n\t\t\t\t\tsyncExecStack.length && (syncExecStack[0].finish= [mid]);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// the loader wasn't in sync mode on entry; probably async mode; therefore, no expectation of getting\r\n\t\t\t\t// the module value synchronously; make sure it gets executed though\r\n\t\t\t\texecQ.push(module);\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tvar result = doRequire(moduleName, omitModuleCheck);\r\n\t\tif(has(\"config-publishRequireResult\") && !lang.exists(moduleName) && result!==undefined){\r\n\t\t\tlang.setObject(moduleName, result);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\tdojo.loadInit = function(f) {\r\n\t\tf();\r\n\t};\r\n\r\n\tdojo.registerModulePath = function(/*String*/moduleName, /*String*/prefix){\r\n\t\t// summary:\r\n\t\t//\t\tMaps a module name to a path\r\n\t\t// description:\r\n\t\t//\t\tAn unregistered module is given the default path of ../[module],\r\n\t\t//\t\trelative to Dojo root. For example, module acme is mapped to\r\n\t\t//\t\t../acme.  If you want to use a different module name, use\r\n\t\t//\t\tdojo.registerModulePath.\r\n\t\t// example:\r\n\t\t//\t\tIf your dojo.js is located at this location in the web root:\r\n\t\t//\t|\t/myapp/js/dojo/dojo/dojo.js\r\n\t\t//\t\tand your modules are located at:\r\n\t\t//\t|\t/myapp/js/foo/bar.js\r\n\t\t//\t|\t/myapp/js/foo/baz.js\r\n\t\t//\t|\t/myapp/js/foo/thud/xyzzy.js\r\n\t\t//\t\tYour application can tell Dojo to locate the \"foo\" namespace by calling:\r\n\t\t//\t|\tdojo.registerModulePath(\"foo\", \"../../foo\");\r\n\t\t//\t\tAt which point you can then use dojo.require() to load the\r\n\t\t//\t\tmodules (assuming they provide() the same things which are\r\n\t\t//\t\trequired). The full code might be:\r\n\t\t//\t|\t<script type=\"text/javascript\"\r\n\t\t//\t|\t\tsrc=\"/myapp/js/dojo/dojo/dojo.js\"></script>\r\n\t\t//\t|\t<script type=\"text/javascript\">\r\n\t\t//\t|\t\tdojo.registerModulePath(\"foo\", \"../../foo\");\r\n\t\t//\t|\t\tdojo.require(\"foo.bar\");\r\n\t\t//\t|\t\tdojo.require(\"foo.baz\");\r\n\t\t//\t|\t\tdojo.require(\"foo.thud.xyzzy\");\r\n\t\t//\t|\t</script>\r\n\r\n\t\tvar paths = {};\r\n\t\tpaths[moduleName.replace(/\\./g, \"/\")] = prefix;\r\n\t\trequire({paths:paths});\r\n\t};\r\n\r\n\tdojo.platformRequire = function(/*Object*/modMap){\r\n\t\t// summary:\r\n\t\t//\t\trequire one or more modules based on which host environment\r\n\t\t//\t\tDojo is currently operating in\r\n\t\t// description:\r\n\t\t//\t\tThis method takes a \"map\" of arrays which one can use to\r\n\t\t//\t\toptionally load dojo modules. The map is indexed by the\r\n\t\t//\t\tpossible dojo.name_ values, with two additional values:\r\n\t\t//\t\t\"default\" and \"common\". The items in the \"default\" array will\r\n\t\t//\t\tbe loaded if none of the other items have been chosen based on\r\n\t\t//\t\tdojo.name_, set by your host environment. The items in the\r\n\t\t//\t\t\"common\" array will *always* be loaded, regardless of which\r\n\t\t//\t\tlist is chosen.\r\n\t\t// example:\r\n\t\t//\t\t|\tdojo.platformRequire({\r\n\t\t//\t\t|\t\tbrowser: [\r\n\t\t//\t\t|\t\t\t\"foo.sample\", // simple module\r\n\t\t//\t\t|\t\t\t\"foo.test\",\r\n\t\t//\t\t|\t\t\t[\"foo.bar.baz\", true] // skip object check in _loadModule (dojo.require)\r\n\t\t//\t\t|\t\t],\r\n\t\t//\t\t|\t\tdefault: [ \"foo.sample._base\" ],\r\n\t\t//\t\t|\t\tcommon: [ \"important.module.common\" ]\r\n\t\t//\t\t|\t});\r\n\r\n\t\tvar result = (modMap.common || []).concat(modMap[dojo._name] || modMap[\"default\"] || []),\r\n\t\t\ttemp;\r\n\t\twhile(result.length){\r\n\t\t\tif(lang.isArray(temp = result.shift())){\r\n\t\t\t\tdojo.require.apply(dojo, temp);\r\n\t\t\t}else{\r\n\t\t\t\tdojo.require(temp);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tdojo.requireIf = dojo.requireAfterIf = function(/*Boolean*/ condition, /*String*/ moduleName, /*Boolean?*/omitModuleCheck){\r\n\t\t// summary:\r\n\t\t//\t\tIf the condition is true then call `dojo.require()` for the specified\r\n\t\t//\t\tresource\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tdojo.requireIf(dojo.isBrowser, \"my.special.Module\");\r\n\r\n\t\tif(condition){\r\n\t\t\tdojo.require(moduleName, omitModuleCheck);\r\n\t\t}\r\n\t};\r\n\r\n\tdojo.requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale){\r\n\t\trequire([\"../i18n\"], function(i18n){\r\n\t\t\ti18n.getLocalization(moduleName, bundleName, locale);\r\n\t\t});\r\n\t};\r\n\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tThis module defines the v1.x synchronous loader API.\r\n\r\n\t\textractLegacyApiApplications:extractLegacyApiApplications,\r\n\t\trequire:dojoRequirePlugin,\r\n\t\tloadInit:dojoLoadInitPlugin\r\n\t};\r\n});\r\n"]}