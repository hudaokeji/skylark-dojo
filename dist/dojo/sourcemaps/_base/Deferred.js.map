{"version":3,"sources":["_base/Deferred.js"],"names":["define","dojo","NewDeferred","Promise","CancelError","has","lang","when","mutator","freeze","Object","Deferred","canceller","result","finished","canceled","fired","isError","head","nextListener","promise","this","complete","value","Error","notify","mutated","listener","next","progress","func","error","resolved","instrumentRejected","newResult","then","hitch","deferred","unchanged","undefined","e","reject","resolve","isResolved","isRejected","isFulfilled","isCanceled","callback","results","errback","update","addCallbacks","resolvedCallback","errorCallback","progressCallback","returnDeferred","cancel","log","extend","addCallback","apply","arguments","addErrback","addBoth","enclosed"],"mappings":"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","file":"../../_base/Deferred.js","sourcesContent":["define([\r\n\t\"./kernel\",\r\n\t\"../Deferred\",\r\n\t\"../promise/Promise\",\r\n\t\"../errors/CancelError\",\r\n\t\"../has\",\r\n\t\"./lang\",\r\n\t\"../when\"\r\n], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){\r\n\t// module:\r\n\t//\t\tdojo/_base/Deferred\r\n\r\n\tvar mutator = function(){};\r\n\tvar freeze = Object.freeze || function(){};\r\n\t// A deferred provides an API for creating and resolving a promise.\r\n\tvar Deferred = dojo.Deferred = function(/*Function?*/ canceller){\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated.   This module defines the legacy dojo/_base/Deferred API.\r\n\t\t//\t\tNew code should use dojo/Deferred instead.\r\n\t\t// description:\r\n\t\t//\t\tThe Deferred API is based on the concept of promises that provide a\r\n\t\t//\t\tgeneric interface into the eventual completion of an asynchronous action.\r\n\t\t//\t\tThe motivation for promises fundamentally is about creating a\r\n\t\t//\t\tseparation of concerns that allows one to achieve the same type of\r\n\t\t//\t\tcall patterns and logical data flow in asynchronous code as can be\r\n\t\t//\t\tachieved in synchronous code. Promises allows one\r\n\t\t//\t\tto be able to call a function purely with arguments needed for\r\n\t\t//\t\texecution, without conflating the call with concerns of whether it is\r\n\t\t//\t\tsync or async. One shouldn't need to alter a call's arguments if the\r\n\t\t//\t\timplementation switches from sync to async (or vice versa). By having\r\n\t\t//\t\tasync functions return promises, the concerns of making the call are\r\n\t\t//\t\tseparated from the concerns of asynchronous interaction (which are\r\n\t\t//\t\thandled by the promise).\r\n\t\t//\r\n\t\t//\t\tThe Deferred is a type of promise that provides methods for fulfilling the\r\n\t\t//\t\tpromise with a successful result or an error. The most important method for\r\n\t\t//\t\tworking with Dojo's promises is the then() method, which follows the\r\n\t\t//\t\tCommonJS proposed promise API. An example of using a Dojo promise:\r\n\t\t//\r\n\t\t//\t\t|\tvar resultingPromise = someAsyncOperation.then(function(result){\r\n\t\t//\t\t|\t\t... handle result ...\r\n\t\t//\t\t|\t},\r\n\t\t//\t\t|\tfunction(error){\r\n\t\t//\t\t|\t\t... handle error ...\r\n\t\t//\t\t|\t});\r\n\t\t//\r\n\t\t//\t\tThe .then() call returns a new promise that represents the result of the\r\n\t\t//\t\texecution of the callback. The callbacks will never affect the original promises value.\r\n\t\t//\r\n\t\t//\t\tThe Deferred instances also provide the following functions for backwards compatibility:\r\n\t\t//\r\n\t\t//\t\t- addCallback(handler)\r\n\t\t//\t\t- addErrback(handler)\r\n\t\t//\t\t- callback(result)\r\n\t\t//\t\t- errback(result)\r\n\t\t//\r\n\t\t//\t\tCallbacks are allowed to return promises themselves, so\r\n\t\t//\t\tyou can build complicated sequences of events with ease.\r\n\t\t//\r\n\t\t//\t\tThe creator of the Deferred may specify a canceller.  The canceller\r\n\t\t//\t\tis a function that will be called if Deferred.cancel is called\r\n\t\t//\t\tbefore the Deferred fires. You can use this to implement clean\r\n\t\t//\t\taborting of an XMLHttpRequest, etc. Note that cancel will fire the\r\n\t\t//\t\tdeferred with a CancelledError (unless your canceller returns\r\n\t\t//\t\tanother kind of error), so the errbacks should be prepared to\r\n\t\t//\t\thandle that error for cancellable Deferreds.\r\n\t\t// example:\r\n\t\t//\t|\tvar deferred = new Deferred();\r\n\t\t//\t|\tsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\r\n\t\t//\t|\treturn deferred;\r\n\t\t// example:\r\n\t\t//\t\tDeferred objects are often used when making code asynchronous. It\r\n\t\t//\t\tmay be easiest to write functions in a synchronous manner and then\r\n\t\t//\t\tsplit code using a deferred to trigger a response to a long-lived\r\n\t\t//\t\toperation. For example, instead of register a callback function to\r\n\t\t//\t\tdenote when a rendering operation completes, the function can\r\n\t\t//\t\tsimply return a deferred:\r\n\t\t//\r\n\t\t//\t\t|\t// callback style:\r\n\t\t//\t\t|\tfunction renderLotsOfData(data, callback){\r\n\t\t//\t\t|\t\tvar success = false\r\n\t\t//\t\t|\t\ttry{\r\n\t\t//\t\t|\t\t\tfor(var x in data){\r\n\t\t//\t\t|\t\t\t\trenderDataitem(data[x]);\r\n\t\t//\t\t|\t\t\t}\r\n\t\t//\t\t|\t\t\tsuccess = true;\r\n\t\t//\t\t|\t\t}catch(e){ }\r\n\t\t//\t\t|\t\tif(callback){\r\n\t\t//\t\t|\t\t\tcallback(success);\r\n\t\t//\t\t|\t\t}\r\n\t\t//\t\t|\t}\r\n\t\t//\r\n\t\t//\t\t|\t// using callback style\r\n\t\t//\t\t|\trenderLotsOfData(someDataObj, function(success){\r\n\t\t//\t\t|\t\t// handles success or failure\r\n\t\t//\t\t|\t\tif(!success){\r\n\t\t//\t\t|\t\t\tpromptUserToRecover();\r\n\t\t//\t\t|\t\t}\r\n\t\t//\t\t|\t});\r\n\t\t//\t\t|\t// NOTE: no way to add another callback here!!\r\n\t\t// example:\r\n\t\t//\t\tUsing a Deferred doesn't simplify the sending code any, but it\r\n\t\t//\t\tprovides a standard interface for callers and senders alike,\r\n\t\t//\t\tproviding both with a simple way to service multiple callbacks for\r\n\t\t//\t\tan operation and freeing both sides from worrying about details\r\n\t\t//\t\tsuch as \"did this get called already?\". With Deferreds, new\r\n\t\t//\t\tcallbacks can be added at any time.\r\n\t\t//\r\n\t\t//\t\t|\t// Deferred style:\r\n\t\t//\t\t|\tfunction renderLotsOfData(data){\r\n\t\t//\t\t|\t\tvar d = new Deferred();\r\n\t\t//\t\t|\t\ttry{\r\n\t\t//\t\t|\t\t\tfor(var x in data){\r\n\t\t//\t\t|\t\t\t\trenderDataitem(data[x]);\r\n\t\t//\t\t|\t\t\t}\r\n\t\t//\t\t|\t\t\td.callback(true);\r\n\t\t//\t\t|\t\t}catch(e){\r\n\t\t//\t\t|\t\t\td.errback(new Error(\"rendering failed\"));\r\n\t\t//\t\t|\t\t}\r\n\t\t//\t\t|\t\treturn d;\r\n\t\t//\t\t|\t}\r\n\t\t//\r\n\t\t//\t\t|\t// using Deferred style\r\n\t\t//\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\r\n\t\t//\t\t|\t\tpromptUserToRecover();\r\n\t\t//\t\t|\t});\r\n\t\t//\t\t|\t// NOTE: addErrback and addCallback both return the Deferred\r\n\t\t//\t\t|\t// again, so we could chain adding callbacks or save the\r\n\t\t//\t\t|\t// deferred for later should we need to be notified again.\r\n\t\t// example:\r\n\t\t//\t\tIn this example, renderLotsOfData is synchronous and so both\r\n\t\t//\t\tversions are pretty artificial. Putting the data display on a\r\n\t\t//\t\ttimeout helps show why Deferreds rock:\r\n\t\t//\r\n\t\t//\t\t|\t// Deferred style and async func\r\n\t\t//\t\t|\tfunction renderLotsOfData(data){\r\n\t\t//\t\t|\t\tvar d = new Deferred();\r\n\t\t//\t\t|\t\tsetTimeout(function(){\r\n\t\t//\t\t|\t\t\ttry{\r\n\t\t//\t\t|\t\t\t\tfor(var x in data){\r\n\t\t//\t\t|\t\t\t\t\trenderDataitem(data[x]);\r\n\t\t//\t\t|\t\t\t\t}\r\n\t\t//\t\t|\t\t\t\td.callback(true);\r\n\t\t//\t\t|\t\t\t}catch(e){\r\n\t\t//\t\t|\t\t\t\td.errback(new Error(\"rendering failed\"));\r\n\t\t//\t\t|\t\t\t}\r\n\t\t//\t\t|\t\t}, 100);\r\n\t\t//\t\t|\t\treturn d;\r\n\t\t//\t\t|\t}\r\n\t\t//\r\n\t\t//\t\t|\t// using Deferred style\r\n\t\t//\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\r\n\t\t//\t\t|\t\tpromptUserToRecover();\r\n\t\t//\t\t|\t});\r\n\t\t//\r\n\t\t//\t\tNote that the caller doesn't have to change his code at all to\r\n\t\t//\t\thandle the asynchronous case.\r\n\r\n\t\tvar result, finished, canceled, fired, isError, head, nextListener;\r\n\t\tvar promise = (this.promise = new Promise());\r\n\r\n\t\tfunction complete(value){\r\n\t\t\tif(finished){\r\n\t\t\t\tthrow new Error(\"This deferred has already been resolved\");\r\n\t\t\t}\r\n\t\t\tresult = value;\r\n\t\t\tfinished = true;\r\n\t\t\tnotify();\r\n\t\t}\r\n\t\tfunction notify(){\r\n\t\t\tvar mutated;\r\n\t\t\twhile(!mutated && nextListener){\r\n\t\t\t\tvar listener = nextListener;\r\n\t\t\t\tnextListener = nextListener.next;\r\n\t\t\t\tif((mutated = (listener.progress == mutator))){ // assignment and check\r\n\t\t\t\t\tfinished = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar func = (isError ? listener.error : listener.resolved);\r\n\t\t\t\tif(has(\"config-useDeferredInstrumentation\")){\r\n\t\t\t\t\tif(isError && NewDeferred.instrumentRejected){\r\n\t\t\t\t\t\tNewDeferred.instrumentRejected(result, !!func);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(func){\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar newResult = func(result);\r\n\t\t\t\t\t\tif (newResult && typeof newResult.then === \"function\"){\r\n\t\t\t\t\t\t\tnewResult.then(lang.hitch(listener.deferred, \"resolve\"), lang.hitch(listener.deferred, \"reject\"), lang.hitch(listener.deferred, \"progress\"));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar unchanged = mutated && newResult === undefined;\r\n\t\t\t\t\t\tif(mutated && !unchanged){\r\n\t\t\t\t\t\t\tisError = newResult instanceof Error;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlistener.deferred[unchanged && isError ? \"reject\" : \"resolve\"](unchanged ? result : newResult);\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tlistener.deferred.reject(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(isError){\r\n\t\t\t\t\t\tlistener.deferred.reject(result);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlistener.deferred.resolve(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.isResolved = promise.isResolved = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been resolved.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn fired == 0;\r\n\t\t};\r\n\r\n\t\tthis.isRejected = promise.isRejected = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been rejected.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn fired == 1;\r\n\t\t};\r\n\r\n\t\tthis.isFulfilled = promise.isFulfilled = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been resolved or rejected.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn fired >= 0;\r\n\t\t};\r\n\r\n\t\tthis.isCanceled = promise.isCanceled = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been canceled.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn canceled;\r\n\t\t};\r\n\r\n\t\t// calling resolve will resolve the promise\r\n\t\tthis.resolve = this.callback = function(value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFulfills the Deferred instance successfully with the provide value\r\n\t\t\tthis.fired = fired = 0;\r\n\t\t\tthis.results = [value, null];\r\n\t\t\tcomplete(value);\r\n\t\t};\r\n\r\n\r\n\t\t// calling error will indicate that the promise failed\r\n\t\tthis.reject = this.errback = function(error){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFulfills the Deferred instance as an error with the provided error\r\n\t\t\tisError = true;\r\n\t\t\tthis.fired = fired = 1;\r\n\t\t\tif(has(\"config-useDeferredInstrumentation\")){\r\n\t\t\t\tif(NewDeferred.instrumentRejected){\r\n\t\t\t\t\tNewDeferred.instrumentRejected(error, !!nextListener);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcomplete(error);\r\n\t\t\tthis.results = [null, error];\r\n\t\t};\r\n\t\t// call progress to provide updates on the progress on the completion of the promise\r\n\t\tthis.progress = function(update){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSend progress events to all listeners\r\n\t\t\tvar listener = nextListener;\r\n\t\t\twhile(listener){\r\n\t\t\t\tvar progress = listener.progress;\r\n\t\t\t\tprogress && progress(update);\r\n\t\t\t\tlistener = listener.next;\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.addCallbacks = function(callback, errback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds callback and error callback for this deferred instance.\r\n\t\t\t// callback: Function?\r\n\t\t\t//\t\tThe callback attached to this deferred object.\r\n\t\t\t// errback: Function?\r\n\t\t\t//\t\tThe error callback attached to this deferred object.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns this deferred object.\r\n\t\t\tthis.then(callback, errback, mutator);\r\n\t\t\treturn this;\t// Deferred\r\n\t\t};\r\n\t\t// provide the implementation of the promise\r\n\t\tpromise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds a fulfilledHandler, errorHandler, and progressHandler to be called for\r\n\t\t\t//\t\tcompletion of a promise. The fulfilledHandler is called when the promise\r\n\t\t\t//\t\tis fulfilled. The errorHandler is called when a promise fails. The\r\n\t\t\t//\t\tprogressHandler is called for progress events. All arguments are optional\r\n\t\t\t//\t\tand non-function values are ignored. The progressHandler is not only an\r\n\t\t\t//\t\toptional argument, but progress events are purely optional. Promise\r\n\t\t\t//\t\tproviders are not required to ever create progress events.\r\n\t\t\t//\r\n\t\t\t//\t\tThis function will return a new promise that is fulfilled when the given\r\n\t\t\t//\t\tfulfilledHandler or errorHandler callback is finished. This allows promise\r\n\t\t\t//\t\toperations to be chained together. The value returned from the callback\r\n\t\t\t//\t\thandler is the fulfillment value for the returned promise. If the callback\r\n\t\t\t//\t\tthrows an error, the returned promise will be moved to failed state.\r\n\t\t\t//\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns a new promise that represents the result of the\r\n\t\t\t//\t\texecution of the callback. The callbacks will never affect the original promises value.\r\n\t\t\t// example:\r\n\t\t\t//\t\tAn example of using a CommonJS compliant promise:\r\n\t\t\t//\t\t|\tasyncComputeTheAnswerToEverything().\r\n\t\t\t//\t\t|\t\tthen(addTwo).\r\n\t\t\t//\t\t|\t\tthen(printResult, onError);\r\n\t\t\t//\t\t|\t>44\r\n\t\t\t//\r\n\t\t\tvar returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);\r\n\t\t\tvar listener = {\r\n\t\t\t\tresolved: resolvedCallback,\r\n\t\t\t\terror: errorCallback,\r\n\t\t\t\tprogress: progressCallback,\r\n\t\t\t\tdeferred: returnDeferred\r\n\t\t\t};\r\n\t\t\tif(nextListener){\r\n\t\t\t\thead = head.next = listener;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tnextListener = head = listener;\r\n\t\t\t}\r\n\t\t\tif(finished){\r\n\t\t\t\tnotify();\r\n\t\t\t}\r\n\t\t\treturn returnDeferred.promise; // Promise\r\n\t\t};\r\n\t\tvar deferred = this;\r\n\t\tpromise.cancel = this.cancel = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCancels the asynchronous operation\r\n\t\t\tif(!finished){\r\n\t\t\t\tvar error = canceller && canceller(deferred);\r\n\t\t\t\tif(!finished){\r\n\t\t\t\t\tif (!(error instanceof Error)){\r\n\t\t\t\t\t\terror = new CancelError(error);\r\n\t\t\t\t\t}\r\n\t\t\t\t\terror.log = false;\r\n\t\t\t\t\tdeferred.reject(error);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcanceled = true;\r\n\t\t};\r\n\t\tfreeze(promise);\r\n\t};\r\n\tlang.extend(Deferred, {\r\n\t\taddCallback: function(/*Function*/ callback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds successful callback for this deferred instance.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns this deferred object.\r\n\t\t\treturn this.addCallbacks(lang.hitch.apply(dojo, arguments));\t// Deferred\r\n\t\t},\r\n\r\n\t\taddErrback: function(/*Function*/ errback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds error callback for this deferred instance.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns this deferred object.\r\n\t\t\treturn this.addCallbacks(null, lang.hitch.apply(dojo, arguments));\t// Deferred\r\n\t\t},\r\n\r\n\t\taddBoth: function(/*Function*/ callback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdd handler as both successful callback and error callback for this deferred instance.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns this deferred object.\r\n\t\t\tvar enclosed = lang.hitch.apply(dojo, arguments);\r\n\t\t\treturn this.addCallbacks(enclosed, enclosed);\t// Deferred\r\n\t\t},\r\n\t\tfired: -1\r\n\t});\r\n\r\n\tDeferred.when = dojo.when = when;\r\n\r\n\treturn Deferred;\r\n});\r\n"]}