{"version":3,"sources":["_base/NodeList.js"],"names":["define","dojo","query","array","NodeList","nlp","prototype","connect","_adaptAsForEach","apply","this","arguments","coords","_adaptAsMap","events","forEach","evt","_oe","a","b"],"mappings":";;;;;;;AAAAA,QAAQ,WAAY,WAAY,UAAW,SAAU,mBAAoB,SAASC,EAAMC,EAAOC,GAc9F,IAAIC,EAAWF,EAAME,SACpBC,EAAMD,EAASE,UA6FhB,OA3FAD,EAAIE,QAAUH,EAASI,gBAAgB,WAEtC,OAAOP,EAAKM,QAAQE,MAAMC,KAAMC,aAkCjCN,EAAIO,OAASR,EAASS,YAAYZ,EAAKW,QAcvCR,EAASU,QAGR,OAAQ,QAAS,SAAU,QAAS,QAAS,UAAW,WACxD,QAAS,OAAQ,YAAa,aAAc,aAAc,YAC1D,WAAY,YAAa,UAAW,UAMrCX,EAAMY,QAAQX,EAASU,OAAQ,SAASE,GACtC,IAAIC,EAAM,KAAOD,EACjBX,EAAIY,GAAO,SAASC,EAAGC,GACtB,OAAOT,KAAKH,QAAQU,EAAKC,EAAGC,MA0B/BlB,EAAKG,SAAWA,EACTA","file":"../../_base/NodeList.js","sourcesContent":["define([\"./kernel\", \"../query\", \"./array\", \"./html\", \"../NodeList-dom\"], function(dojo, query, array){\r\n\t// module:\r\n\t//\t\tdojo/_base/NodeList\r\n\r\n\t/*=====\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tThis module extends dojo/NodeList with the legacy connect(), coords(),\r\n\t\t//\t\tblur(), focus(), change(), click(), error(), keydown(), keypress(),\r\n\t\t//\t\tkeyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),\r\n\t\t//\t\tmouseout(), mouseover(), mouseup(), and submit() methods.\r\n\t};\r\n\t=====*/\r\n \r\n\tvar NodeList = query.NodeList,\r\n\t\tnlp = NodeList.prototype;\r\n\r\n\tnlp.connect = NodeList._adaptAsForEach(function(){\r\n\t\t// don't bind early to dojo.connect since we no longer explicitly depend on it\r\n\t\treturn dojo.connect.apply(this, arguments);\r\n\t});\r\n\t/*=====\r\n\tnlp.connect = function(methodName, objOrFunc, funcName){\r\n\t\t// summary:\r\n\t\t//\t\tAttach event handlers to every item of the NodeList. Uses dojo.connect()\r\n\t\t//\t\tso event properties are normalized.\r\n\t\t//\r\n\t\t//\t\tApplication must manually require() \"dojo/_base/connect\" before using this method.\r\n\t\t// methodName: String\r\n\t\t//\t\tthe name of the method to attach to. For DOM events, this should be\r\n\t\t//\t\tthe lower-case name of the event\r\n\t\t// objOrFunc: Object|Function|String\r\n\t\t//\t\tif 2 arguments are passed (methodName, objOrFunc), objOrFunc should\r\n\t\t//\t\treference a function or be the name of the function in the global\r\n\t\t//\t\tnamespace to attach. If 3 arguments are provided\r\n\t\t//\t\t(methodName, objOrFunc, funcName), objOrFunc must be the scope to\r\n\t\t//\t\tlocate the bound function in\r\n\t\t// funcName: String?\r\n\t\t//\t\toptional. A string naming the function in objOrFunc to bind to the\r\n\t\t//\t\tevent. May also be a function reference.\r\n\t\t// example:\r\n\t\t//\t\tadd an onclick handler to every button on the page\r\n\t\t//\t\t|\tquery(\"div:nth-child(odd)\").connect(\"onclick\", function(e){\r\n\t\t//\t\t|\t\tconsole.log(\"clicked!\");\r\n\t\t//\t\t|\t});\r\n\t\t// example:\r\n\t\t//\t\tattach foo.bar() to every odd div's onmouseover\r\n\t\t//\t\t|\tquery(\"div:nth-child(odd)\").connect(\"onmouseover\", foo, \"bar\");\r\n\r\n\t\treturn null;\t// NodeList\r\n\t};\r\n\t=====*/\r\n\r\n\tnlp.coords = NodeList._adaptAsMap(dojo.coords);\r\n\t/*=====\r\n\tnlp.coords = function(){\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated: Use position() for border-box x/y/w/h\r\n\t\t//\t\tor marginBox() for margin-box w/h/l/t.\r\n\t\t//\t\tReturns the box objects of all elements in a node list as\r\n\t\t//\t\tan Array (*not* a NodeList). Acts like `domGeom.coords`, though assumes\r\n\t\t//\t\tthe node passed is each node in this list.\r\n\r\n\t\treturn []; // Array\r\n\t};\r\n\t=====*/\r\n\r\n\tNodeList.events = [\r\n\t\t// summary:\r\n\t\t//\t\tlist of all DOM events used in NodeList\r\n\t\t\"blur\", \"focus\", \"change\", \"click\", \"error\", \"keydown\", \"keypress\",\r\n\t\t\"keyup\", \"load\", \"mousedown\", \"mouseenter\", \"mouseleave\", \"mousemove\",\r\n\t\t\"mouseout\", \"mouseover\", \"mouseup\", \"submit\"\r\n\t];\r\n\r\n\t// FIXME: pseudo-doc the above automatically generated on-event functions\r\n\r\n\t// syntactic sugar for DOM events\r\n\tarray.forEach(NodeList.events, function(evt){\r\n\t\t\tvar _oe = \"on\" + evt;\r\n\t\t\tnlp[_oe] = function(a, b){\r\n\t\t\t\treturn this.connect(_oe, a, b);\r\n\t\t\t};\r\n\t\t\t\t// FIXME: should these events trigger publishes?\r\n\t\t\t\t/*\r\n\t\t\t\treturn (a ? this.connect(_oe, a, b) :\r\n\t\t\t\t\t\t\tthis.forEach(function(n){\r\n\t\t\t\t\t\t\t\t// FIXME:\r\n\t\t\t\t\t\t\t\t//\t\tlisteners get buried by\r\n\t\t\t\t\t\t\t\t//\t\taddEventListener and can't be dug back\r\n\t\t\t\t\t\t\t\t//\t\tout to be triggered externally.\r\n\t\t\t\t\t\t\t\t// see:\r\n\t\t\t\t\t\t\t\t//\t\thttp://developer.mozilla.org/en/docs/DOM:element\r\n\r\n\t\t\t\t\t\t\t\tconsole.log(n, evt, _oe);\r\n\r\n\t\t\t\t\t\t\t\t// FIXME: need synthetic event support!\r\n\t\t\t\t\t\t\t\tvar _e = { target: n, faux: true, type: evt };\r\n\t\t\t\t\t\t\t\t// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });\r\n\t\t\t\t\t\t\t\ttry{ n[evt](_e); }catch(e){ console.log(e); }\r\n\t\t\t\t\t\t\t\ttry{ n[_oe](_e); }catch(e){ console.log(e); }\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t\t*/\r\n\t\t}\r\n\t);\r\n\r\n\tdojo.NodeList = NodeList;\r\n\treturn NodeList;\r\n});\r\n"]}