{"version":3,"sources":["_base/configSpidermonkey.js"],"names":["dojo","config","baseUrl","_name","isSpidermonkey","exit","exitcode","quit","print","console","debug","line2pc","Error","_spidermonkeyCurrentFile","depth","s","e","stack","matches","match","fname","length","_loadUri","uri","load","param","registerModulePath"],"mappings":";;;;;;;AA0BA,GAnBGA,KAAKC,OAAgB,QACvBD,KAAKE,QAAUF,KAAKC,OAAgB,QAEpCD,KAAKE,QAAU,KAGhBF,KAAKG,MAAQ,eAIbH,KAAKI,gBAAiB,EACtBJ,KAAKK,KAAO,SAASC,GACpBC,KAAKD,IAGa,mBAATE,QACTC,QAAQC,MAAQF,OAGI,oBAAXG,QACT,MAAM,IAAIC,MAAM,yEAgDjB,GA7CAZ,KAAKa,yBAA2B,SAASC,GAUxC,IAAIC,EAAI,GACR,IACC,MAAMH,MAAM,YACZ,MAAMI,GACND,EAAIC,EAAEC,MAGP,IAAIC,EAAUH,EAAEI,MAAM,eACtB,IAAID,EACH,MAAMN,MAAM,kCAAoCG,EAAI,KAErD,IAAIK,OAAyB,IAATN,GAAwBA,EAASI,EAAQJ,EAAQ,GAAKI,EAAQA,EAAQG,OAAS,GACnG,IAAID,EACH,MAAMR,MAAM,6CAA+CG,EAAI,KAGhE,OAAOK,GAKRpB,KAAKsB,SAAW,SAASC,GAQxB,OAFAC,KAAKD,GAEE,GAMLvB,KAAKC,OAAoB,YAC3B,IAAI,IAAIwB,SAASzB,KAAKC,OAAoB,YACzCD,KAAK0B,mBAAmBD,MAAOzB,KAAKC,OAAoB,YAAEwB","file":"../../_base/configSpidermonkey.js","sourcesContent":["// TODO: this file needs to be converted to the v1.7 loader\r\n\r\n// module:\r\n//\t\tconfigSpidermonkey\r\n// summary:\r\n//\t\t SpiderMonkey host environment\r\n\r\nif(dojo.config[\"baseUrl\"]){\r\n\tdojo.baseUrl = dojo.config[\"baseUrl\"];\r\n}else{\r\n\tdojo.baseUrl = \"./\";\r\n}\r\n\r\ndojo._name = 'spidermonkey';\r\n\r\n\r\n\r\ndojo.isSpidermonkey = true;\r\ndojo.exit = function(exitcode){\r\n\tquit(exitcode);\r\n};\r\n\r\nif(typeof print == \"function\"){\r\n\tconsole.debug = print;\r\n}\r\n\r\nif(typeof line2pc == 'undefined'){\r\n\tthrow new Error(\"attempt to use SpiderMonkey host environment when no 'line2pc' global\");\r\n}\r\n\r\ndojo._spidermonkeyCurrentFile = function(depth){\r\n\t//\r\n\t//\tThis is a hack that determines the current script file by parsing a\r\n\t//\tgenerated stack trace (relying on the non-standard \"stack\" member variable\r\n\t//\tof the SpiderMonkey Error object).\r\n\t//\r\n\t//\tIf param depth is passed in, it'll return the script file which is that far down\r\n\t//\tthe stack, but that does require that you know how deep your stack is when you are\r\n\t//\tcalling.\r\n\t//\r\n\tvar s = '';\r\n\ttry{\r\n\t\tthrow Error(\"whatever\");\r\n\t}catch(e){\r\n\t\ts = e.stack;\r\n\t}\r\n\t// lines are like: bu_getCurrentScriptURI_spidermonkey(\"ScriptLoader.js\")@burst/Runtime.js:101\r\n\tvar matches = s.match(/[^@]*\\.js/gi);\r\n\tif(!matches){\r\n\t\tthrow Error(\"could not parse stack string: '\" + s + \"'\");\r\n\t}\r\n\tvar fname = (typeof depth != 'undefined' && depth) ? matches[depth + 1] : matches[matches.length - 1];\r\n\tif(!fname){\r\n\t\tthrow Error(\"could not find file name in stack string '\" + s + \"'\");\r\n\t}\r\n\t//print(\"SpiderMonkeyRuntime got fname '\" + fname + \"' from stack string '\" + s + \"'\");\r\n\treturn fname;\r\n};\r\n\r\n// print(dojo._spidermonkeyCurrentFile(0));\r\n\r\ndojo._loadUri = function(uri){\r\n\t// spidermonkey load() evaluates the contents into the global scope (which\r\n\t// is what we want).\r\n\t// TODO: sigh, load() does not return a useful value.\r\n\t// Perhaps it is returning the value of the last thing evaluated?\r\n\t// var ok =\r\n\tload(uri);\r\n\t// console.log(\"spidermonkey load(\", uri, \") returned \", ok);\r\n\treturn 1;\r\n};\r\n\r\n//Register any module paths set up in djConfig. Need to do this\r\n//in the hostenvs since hostenv_browser can read djConfig from a\r\n//script tag's attribute.\r\nif(dojo.config[\"modulePaths\"]){\r\n\tfor(var param in dojo.config[\"modulePaths\"]){\r\n\t\tdojo.registerModulePath(param, dojo.config[\"modulePaths\"][param]);\r\n\t}\r\n}\r\n"]}