{"version":3,"sources":["_base/array.js"],"names":["define","dojo","has","lang","u","cache","buildFn","fn","Function","everyOrSome","some","every","a","o","result","i","l","length","split","call","index","up","delta","lOver","uOver","x","from","last","array","lastIndexOf","end","indexOf","forEach","arr","callback","thisObject","map","Ctr","out","Array","filter","value","push","clearCache","mixin"],"mappings":"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","file":"../../_base/array.js","sourcesContent":["define([\"./kernel\", \"../has\", \"./lang\"], function(dojo, has, lang){\r\n\t// module:\r\n\t//\t\tdojo/_base/array\r\n\r\n\t// our old simple function builder stuff\r\n\tvar cache = {}, u;\r\n\r\n\tfunction buildFn(fn){\r\n\t\treturn cache[fn] = new Function(\"item\", \"index\", \"array\", fn); // Function\r\n\t}\r\n\t// magic snippet: if(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\r\n\r\n\t// every & some\r\n\r\n\tfunction everyOrSome(some){\r\n\t\tvar every = !some;\r\n\t\treturn function(a, fn, o){\r\n\t\t\tvar i = 0, l = a && a.length || 0, result;\r\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\r\n\t\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\r\n\t\t\tif(o){\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tresult = !fn.call(o, a[i], i, a);\r\n\t\t\t\t\tif(some ^ result){\r\n\t\t\t\t\t\treturn !result;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tresult = !fn(a[i], i, a);\r\n\t\t\t\t\tif(some ^ result){\r\n\t\t\t\t\t\treturn !result;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn every; // Boolean\r\n\t\t};\r\n\t}\r\n\r\n\t// indexOf, lastIndexOf\r\n\r\n\tfunction index(up){\r\n\t\tvar delta = 1, lOver = 0, uOver = 0;\r\n\t\tif(!up){\r\n\t\t\tdelta = lOver = uOver = -1;\r\n\t\t}\r\n\t\treturn function(a, x, from, last){\r\n\t\t\tif(last && delta > 0){\r\n\t\t\t\t// TODO: why do we use a non-standard signature? why do we need \"last\"?\r\n\t\t\t\treturn array.lastIndexOf(a, x, from);\r\n\t\t\t}\r\n\t\t\tvar l = a && a.length || 0, end = up ? l + uOver : lOver, i;\r\n\t\t\tif(from === u){\r\n\t\t\t\ti = up ? lOver : l + uOver;\r\n\t\t\t}else{\r\n\t\t\t\tif(from < 0){\r\n\t\t\t\t\ti = l + from;\r\n\t\t\t\t\tif(i < 0){\r\n\t\t\t\t\t\ti = lOver;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\ti = from >= l ? l + uOver : from;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\r\n\t\t\tfor(; i != end; i += delta){\r\n\t\t\t\tif(a[i] == x){\r\n\t\t\t\t\treturn i; // Number\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1; // Number\r\n\t\t};\r\n\t}\r\n\r\n\tvar array = {\r\n\t\t// summary:\r\n\t\t//\t\tThe Javascript v1.6 array extensions.\r\n\r\n\t\tevery: everyOrSome(false),\r\n\t\t/*=====\r\n\t\t every: function(arr, callback, thisObject){\r\n\t\t\t // summary:\r\n\t\t\t //\t\tDetermines whether or not every item in arr satisfies the\r\n\t\t\t //\t\tcondition implemented by callback.\r\n\t\t\t // arr: Array|String\r\n\t\t\t //\t\tthe array to iterate on. If a string, operates on individual characters.\r\n\t\t\t // callback: Function|String\r\n\t\t\t //\t\ta function is invoked with three arguments: item, index,\r\n\t\t\t //\t\tand array and returns true if the condition is met.\r\n\t\t\t // thisObject: Object?\r\n\t\t\t //\t\tmay be used to scope the call to callback\r\n\t\t\t // returns: Boolean\r\n\t\t\t // description:\r\n\t\t\t //\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\r\n\t\t\t //\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n\t\t\t //\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\r\n\t\t\t //\t\tFor more details, see:\r\n\t\t\t //\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\r\n\t\t\t // example:\r\n\t\t\t //\t|\t// returns false\r\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>1; });\r\n\t\t\t // example:\r\n\t\t\t //\t|\t// returns true\r\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>0; });\r\n\t\t },\r\n\t\t =====*/\r\n\r\n\t\tsome: everyOrSome(true),\r\n\t\t/*=====\r\n\t\tsome: function(arr, callback, thisObject){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDetermines whether or not any item in arr satisfies the\r\n\t\t\t//\t\tcondition implemented by callback.\r\n\t\t\t// arr: Array|String\r\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\r\n\t\t\t// callback: Function|String\r\n\t\t\t//\t\ta function is invoked with three arguments: item, index,\r\n\t\t\t//\t\tand array and returns true if the condition is met.\r\n\t\t\t// thisObject: Object?\r\n\t\t\t//\t\tmay be used to scope the call to callback\r\n\t\t\t// returns: Boolean\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\r\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\r\n\t\t\t//\t\tFor more details, see:\r\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\r\n\t\t\t// example:\r\n\t\t\t//\t| // is true\r\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item>1; });\r\n\t\t\t// example:\r\n\t\t\t//\t| // is false\r\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item<1; });\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\tindexOf: index(true),\r\n\t\t/*=====\r\n\t\tindexOf: function(arr, value, fromIndex, findLast){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tlocates the first index of the provided value in the\r\n\t\t\t//\t\tpassed array. If the value is not found, -1 is returned.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\r\n\t\t\t//\r\n\t\t\t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\r\n\t\t\t//\t\t   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.\r\n\t\t\t//\t\t2. uses equality (==) rather than strict equality (===)\r\n\t\t\t//\r\n\t\t\t//\t\tFor details on this method, see:\r\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\r\n\t\t\t// arr: Array\r\n\t\t\t// value: Object\r\n\t\t\t// fromIndex: Integer?\r\n\t\t\t// findLast: Boolean?\r\n\t\t\t//\t\tMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.\r\n\t\t\t// returns: Number\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\tlastIndexOf: index(false),\r\n\t\t/*=====\r\n\t\tlastIndexOf: function(arr, value, fromIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tlocates the last index of the provided value in the passed\r\n\t\t\t//\t\tarray. If the value is not found, -1 is returned.\r\n\t\t\t// description:\r\n\t\t \t//\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\r\n\t\t \t//\r\n\t\t \t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\r\n\t\t \t//\t\t   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.\r\n\t\t \t//\t\t2. uses equality (==) rather than strict equality (===)\r\n\t\t \t//\r\n\t\t \t//\t\tFor details on this method, see:\r\n\t\t \t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\r\n\t\t\t// arr: Array,\r\n\t\t\t// value: Object,\r\n\t\t\t// fromIndex: Integer?\r\n\t\t\t// returns: Number\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\tforEach: function(arr, callback, thisObject){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tfor every item in arr, callback is invoked. Return values are ignored.\r\n\t\t\t//\t\tIf you want to break out of the loop, consider using array.every() or array.some().\r\n\t\t\t//\t\tforEach does not allow breaking out of the loop over the items in arr.\r\n\t\t\t// arr:\r\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\r\n\t\t\t// callback:\r\n\t\t\t//\t\ta function is invoked with three arguments: item, index, and array\r\n\t\t\t// thisObject:\r\n\t\t\t//\t\tmay be used to scope the call to callback\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\r\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\r\n\t\t\t//\t\tFor more details, see:\r\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\r\n\t\t\t// example:\r\n\t\t\t//\t| // log out all members of the array:\r\n\t\t\t//\t| array.forEach(\r\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\r\n\t\t\t//\t|\t\tfunction(item){\r\n\t\t\t//\t|\t\t\tconsole.log(item);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t| );\r\n\t\t\t// example:\r\n\t\t\t//\t| // log out the members and their indexes\r\n\t\t\t//\t| array.forEach(\r\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\r\n\t\t\t//\t|\t\tfunction(item, idx, arr){\r\n\t\t\t//\t|\t\t\tconsole.log(item, \"at index:\", idx);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t| );\r\n\t\t\t// example:\r\n\t\t\t//\t| // use a scoped object member as the callback\r\n\t\t\t//\t|\r\n\t\t\t//\t| var obj = {\r\n\t\t\t//\t|\t\tprefix: \"logged via obj.callback:\",\r\n\t\t\t//\t|\t\tcallback: function(item){\r\n\t\t\t//\t|\t\t\tconsole.log(this.prefix, item);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t| };\r\n\t\t\t//\t|\r\n\t\t\t//\t| // specifying the scope function executes the callback in that scope\r\n\t\t\t//\t| array.forEach(\r\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\r\n\t\t\t//\t|\t\tobj.callback,\r\n\t\t\t//\t|\t\tobj\r\n\t\t\t//\t| );\r\n\t\t\t//\t|\r\n\t\t\t//\t| // alternately, we can accomplish the same thing with lang.hitch()\r\n\t\t\t//\t| array.forEach(\r\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\r\n\t\t\t//\t|\t\tlang.hitch(obj, \"callback\")\r\n\t\t\t//\t| );\r\n\t\t\t// arr: Array|String\r\n\t\t\t// callback: Function|String\r\n\t\t\t// thisObject: Object?\r\n\r\n\t\t\tvar i = 0, l = arr && arr.length || 0;\r\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n\t\t\tif(thisObject){\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tcallback.call(thisObject, arr[i], i, arr);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tcallback(arr[i], i, arr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmap: function(arr, callback, thisObject, Ctr){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tapplies callback to each element of arr and returns\r\n\t\t\t//\t\tan Array with the results\r\n\t\t\t// arr: Array|String\r\n\t\t\t//\t\tthe array to iterate on. If a string, operates on\r\n\t\t\t//\t\tindividual characters.\r\n\t\t\t// callback: Function|String\r\n\t\t\t//\t\ta function is invoked with three arguments, (item, index,\r\n\t\t\t//\t\tarray),\t and returns a value\r\n\t\t\t// thisObject: Object?\r\n\t\t\t//\t\tmay be used to scope the call to callback\r\n\t\t\t// returns: Array\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\r\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\r\n\t\t\t//\t\tFor more details, see:\r\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\r\n\t\t\t// example:\r\n\t\t\t//\t| // returns [2, 3, 4, 5]\r\n\t\t\t//\t| array.map([1, 2, 3, 4], function(item){ return item+1 });\r\n\r\n\t\t\t// TODO: why do we have a non-standard signature here? do we need \"Ctr\"?\r\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);\r\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n\t\t\tif(thisObject){\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tout[i] = callback.call(thisObject, arr[i], i, arr);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tout[i] = callback(arr[i], i, arr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn out; // Array\r\n\t\t},\r\n\r\n\t\tfilter: function(arr, callback, thisObject){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a new Array with those items from arr that match the\r\n\t\t\t//\t\tcondition implemented by callback.\r\n\t\t\t// arr: Array\r\n\t\t\t//\t\tthe array to iterate over.\r\n\t\t\t// callback: Function|String\r\n\t\t\t//\t\ta function that is invoked with three arguments (item,\r\n\t\t\t//\t\tindex, array). The return of this function is expected to\r\n\t\t\t//\t\tbe a boolean which determines whether the passed-in item\r\n\t\t\t//\t\twill be included in the returned array.\r\n\t\t\t// thisObject: Object?\r\n\t\t\t//\t\tmay be used to scope the call to callback\r\n\t\t\t// returns: Array\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\r\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\r\n\t\t\t//\t\tFor more details, see:\r\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\r\n\t\t\t// example:\r\n\t\t\t//\t| // returns [2, 3, 4]\r\n\t\t\t//\t| array.filter([1, 2, 3, 4], function(item){ return item>1; });\r\n\r\n\t\t\t// TODO: do we need \"Ctr\" here like in map()?\r\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = [], value;\r\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n\t\t\tif(thisObject){\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tvalue = arr[i];\r\n\t\t\t\t\tif(callback.call(thisObject, value, i, arr)){\r\n\t\t\t\t\t\tout.push(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(; i < l; ++i){\r\n\t\t\t\t\tvalue = arr[i];\r\n\t\t\t\t\tif(callback(value, i, arr)){\r\n\t\t\t\t\t\tout.push(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn out; // Array\r\n\t\t},\r\n\r\n\t\tclearCache: function(){\r\n\t\t\tcache = {};\r\n\t\t}\r\n\t};\r\n\r\n\r\n\thas(\"extend-dojo\") && lang.mixin(dojo, array);\r\n\r\n\treturn array;\r\n});\r\n"]}