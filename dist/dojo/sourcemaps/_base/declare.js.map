{"version":3,"sources":["_base/declare.js"],"names":["define","dojo","has","lang","mix","mixin","op","Object","prototype","opts","toString","xtor","Function","counter","cname","err","msg","cls","Error","inherited","args","a","f","name","chains","bases","caller","meta","base","proto","opf","pos","cache","this","_inherited","callee","nom","declaredClass","constructor","_meta","p","c","hidden","hasOwnProperty","ctor","apply","getInherited","__inherited","inheritedImpl","config","isDebug","a1","a2","isInstanceOf","i","l","length","mixOwn","target","source","extraNames","_extraNames","extend","declare","safeMixin","createSubclass","mixins","props","Array","undefined","concat","chain","reversed","b","m","step","arguments","forceNew","t","applyNew","className","superclass","parents","call","j","lin","top","rec","refs","result","roots","nameMap","clsCount","count","push","pop","c3mro","postscript","simpleConstructor","ctorSpecial","a0","preamble","singleConstructor","preArgs","chainedConstructor","setObject"],"mappings":"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","file":"../../_base/declare.js","sourcesContent":["define([\"./kernel\", \"../has\", \"./lang\"], function(dojo, has, lang){\r\n\t// module:\r\n\t//\t\tdojo/_base/declare\r\n\r\n\tvar mix = lang.mixin, op = Object.prototype, opts = op.toString,\r\n\t\txtor = new Function, counter = 0, cname = \"constructor\";\r\n\r\n\tfunction err(msg, cls){ throw new Error(\"declare\" + (cls ? \" \" + cls : \"\") + \": \" + msg); }\r\n\r\n\t// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)\r\n\tfunction c3mro(bases, className){\r\n\t\tvar result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,\r\n\t\t\tl = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;\r\n\r\n\t\t// build a list of bases naming them if needed\r\n\t\tfor(; i < l; ++i){\r\n\t\t\tbase = bases[i];\r\n\t\t\tif(!base){\r\n\t\t\t\terr(\"mixin #\" + i + \" is unknown. Did you use dojo.require to pull it in?\", className);\r\n\t\t\t}else if(opts.call(base) != \"[object Function]\"){\r\n\t\t\t\terr(\"mixin #\" + i + \" is not a callable constructor.\", className);\r\n\t\t\t}\r\n\t\t\tlin = base._meta ? base._meta.bases : [base];\r\n\t\t\ttop = 0;\r\n\t\t\t// add bases to the name map\r\n\t\t\tfor(j = lin.length - 1; j >= 0; --j){\r\n\t\t\t\tproto = lin[j].prototype;\r\n\t\t\t\tif(!proto.hasOwnProperty(\"declaredClass\")){\r\n\t\t\t\t\tproto.declaredClass = \"uniqName_\" + (counter++);\r\n\t\t\t\t}\r\n\t\t\t\tname = proto.declaredClass;\r\n\t\t\t\tif(!nameMap.hasOwnProperty(name)){\r\n\t\t\t\t\tnameMap[name] = {count: 0, refs: [], cls: lin[j]};\r\n\t\t\t\t\t++clsCount;\r\n\t\t\t\t}\r\n\t\t\t\trec = nameMap[name];\r\n\t\t\t\tif(top && top !== rec){\r\n\t\t\t\t\trec.refs.push(top);\r\n\t\t\t\t\t++top.count;\r\n\t\t\t\t}\r\n\t\t\t\ttop = rec;\r\n\t\t\t}\r\n\t\t\t++top.count;\r\n\t\t\troots[0].refs.push(top);\r\n\t\t}\r\n\r\n\t\t// remove classes without external references recursively\r\n\t\twhile(roots.length){\r\n\t\t\ttop = roots.pop();\r\n\t\t\tresult.push(top.cls);\r\n\t\t\t--clsCount;\r\n\t\t\t// optimization: follow a single-linked chain\r\n\t\t\twhile(refs = top.refs, refs.length == 1){\r\n\t\t\t\ttop = refs[0];\r\n\t\t\t\tif(!top || --top.count){\r\n\t\t\t\t\t// branch or end of chain => do not end to roots\r\n\t\t\t\t\ttop = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tresult.push(top.cls);\r\n\t\t\t\t--clsCount;\r\n\t\t\t}\r\n\t\t\tif(top){\r\n\t\t\t\t// branch\r\n\t\t\t\tfor(i = 0, l = refs.length; i < l; ++i){\r\n\t\t\t\t\ttop = refs[i];\r\n\t\t\t\t\tif(!--top.count){\r\n\t\t\t\t\t\troots.push(top);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(clsCount){\r\n\t\t\terr(\"can't build consistent linearization\", className);\r\n\t\t}\r\n\r\n\t\t// calculate the superclass offset\r\n\t\tbase = bases[0];\r\n\t\tresult[0] = base ?\r\n\t\t\tbase._meta && base === result[result.length - base._meta.bases.length] ?\r\n\t\t\t\tbase._meta.bases.length : 1 : 0;\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction inherited(args, a, f){\r\n\t\tvar name, chains, bases, caller, meta, base, proto, opf, pos,\r\n\t\t\tcache = this._inherited = this._inherited || {};\r\n\r\n\t\t// crack arguments\r\n\t\tif(typeof args == \"string\"){\r\n\t\t\tname = args;\r\n\t\t\targs = a;\r\n\t\t\ta = f;\r\n\t\t}\r\n\t\tf = 0;\r\n\r\n\t\tcaller = args.callee;\r\n\t\tname = name || caller.nom;\r\n\t\tif(!name){\r\n\t\t\terr(\"can't deduce a name to call inherited()\", this.declaredClass);\r\n\t\t}\r\n\r\n\t\tmeta = this.constructor._meta;\r\n\t\tbases = meta.bases;\r\n\r\n\t\tpos = cache.p;\r\n\t\tif(name != cname){\r\n\t\t\t// method\r\n\t\t\tif(cache.c !== caller){\r\n\t\t\t\t// cache bust\r\n\t\t\t\tpos = 0;\r\n\t\t\t\tbase = bases[0];\r\n\t\t\t\tmeta = base._meta;\r\n\t\t\t\tif(meta.hidden[name] !== caller){\r\n\t\t\t\t\t// error detection\r\n\t\t\t\t\tchains = meta.chains;\r\n\t\t\t\t\tif(chains && typeof chains[name] == \"string\"){\r\n\t\t\t\t\t\terr(\"calling chained method with inherited: \" + name, this.declaredClass);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// find caller\r\n\t\t\t\t\tdo{\r\n\t\t\t\t\t\tmeta = base._meta;\r\n\t\t\t\t\t\tproto = base.prototype;\r\n\t\t\t\t\t\tif(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\r\n\t\t\t\t\tpos = base ? pos : -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// find next\r\n\t\t\tbase = bases[++pos];\r\n\t\t\tif(base){\r\n\t\t\t\tproto = base.prototype;\r\n\t\t\t\tif(base._meta && proto.hasOwnProperty(name)){\r\n\t\t\t\t\tf = proto[name];\r\n\t\t\t\t}else{\r\n\t\t\t\t\topf = op[name];\r\n\t\t\t\t\tdo{\r\n\t\t\t\t\t\tproto = base.prototype;\r\n\t\t\t\t\t\tf = proto[name];\r\n\t\t\t\t\t\tif(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tf = base && f || op[name];\r\n\t\t}else{\r\n\t\t\t// constructor\r\n\t\t\tif(cache.c !== caller){\r\n\t\t\t\t// cache bust\r\n\t\t\t\tpos = 0;\r\n\t\t\t\tmeta = bases[0]._meta;\r\n\t\t\t\tif(meta && meta.ctor !== caller){\r\n\t\t\t\t\t// error detection\r\n\t\t\t\t\tchains = meta.chains;\r\n\t\t\t\t\tif(!chains || chains.constructor !== \"manual\"){\r\n\t\t\t\t\t\terr(\"calling chained constructor with inherited\", this.declaredClass);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// find caller\r\n\t\t\t\t\twhile(base = bases[++pos]){ // intentional assignment\r\n\t\t\t\t\t\tmeta = base._meta;\r\n\t\t\t\t\t\tif(meta && meta.ctor === caller){\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos = base ? pos : -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// find next\r\n\t\t\twhile(base = bases[++pos]){\t// intentional assignment\r\n\t\t\t\tmeta = base._meta;\r\n\t\t\t\tf = meta ? meta.ctor : base;\r\n\t\t\t\tif(f){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tf = base && f;\r\n\t\t}\r\n\r\n\t\t// cache the found super method\r\n\t\tcache.c = f;\r\n\t\tcache.p = pos;\r\n\r\n\t\t// now we have the result\r\n\t\tif(f){\r\n\t\t\treturn a === true ? f : f.apply(this, a || args);\r\n\t\t}\r\n\t\t// intentionally no return if a super method was not found\r\n\t}\r\n\r\n\tfunction getInherited(name, args){\r\n\t\tif(typeof name == \"string\"){\r\n\t\t\treturn this.__inherited(name, args, true);\r\n\t\t}\r\n\t\treturn this.__inherited(name, true);\r\n\t}\r\n\r\n\tfunction inherited__debug(args, a1, a2){\r\n\t\tvar f = this.getInherited(args, a1);\r\n\t\tif(f){ return f.apply(this, a2 || a1 || args); }\r\n\t\t// intentionally no return if a super method was not found\r\n\t}\r\n\r\n\tvar inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;\r\n\r\n\t// emulation of \"instanceof\"\r\n\tfunction isInstanceOf(cls){\r\n\t\tvar bases = this.constructor._meta.bases;\r\n\t\tfor(var i = 0, l = bases.length; i < l; ++i){\r\n\t\t\tif(bases[i] === cls){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this instanceof cls;\r\n\t}\r\n\r\n\tfunction mixOwn(target, source){\r\n\t\t// add props adding metadata for incoming functions skipping a constructor\r\n\t\tfor(var name in source){\r\n\t\t\tif(name != cname && source.hasOwnProperty(name)){\r\n\t\t\t\ttarget[name] = source[name];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\r\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\r\n\t\t\t\tname = extraNames[--i];\r\n\t\t\t\tif(name != cname && source.hasOwnProperty(name)){\r\n\t\t\t\t\t  target[name] = source[name];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// implementation of safe mixin function\r\n\tfunction safeMixin(target, source){\r\n\t\t// summary:\r\n\t\t//\t\tMix in properties skipping a constructor and decorating functions\r\n\t\t//\t\tlike it is done by declare().\r\n\t\t// target: Object\r\n\t\t//\t\tTarget object to accept new properties.\r\n\t\t// source: Object\r\n\t\t//\t\tSource object for new properties.\r\n\t\t// description:\r\n\t\t//\t\tThis function is used to mix in properties like lang.mixin does,\r\n\t\t//\t\tbut it skips a constructor property and decorates functions like\r\n\t\t//\t\tdeclare() does.\r\n\t\t//\r\n\t\t//\t\tIt is meant to be used with classes and objects produced with\r\n\t\t//\t\tdeclare. Functions mixed in with dojo.safeMixin can use\r\n\t\t//\t\tthis.inherited() like normal methods.\r\n\t\t//\r\n\t\t//\t\tThis function is used to implement extend() method of a constructor\r\n\t\t//\t\tproduced with declare().\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar A = declare(null, {\r\n\t\t//\t|\t\tm1: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm2: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar B = declare(A, {\r\n\t\t//\t|\t\tm1: function(){\r\n\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tB.extend({\r\n\t\t//\t|\t\tm2: function(){\r\n\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar x = new B();\r\n\t\t//\t|\tdojo.safeMixin(x, {\r\n\t\t//\t|\t\tm1: function(){\r\n\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t//\t|\t\t\tconsole.log(\"X.m1\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm2: function(){\r\n\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t//\t|\t\t\tconsole.log(\"X.m2\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tx.m2();\r\n\t\t//\t|\t// prints:\r\n\t\t//\t|\t// A.m1\r\n\t\t//\t|\t// B.m1\r\n\t\t//\t|\t// X.m1\r\n\r\n\t\tvar name, t;\r\n\t\t// add props adding metadata for incoming functions skipping a constructor\r\n\t\tfor(name in source){\r\n\t\t\tt = source[name];\r\n\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\r\n\t\t\t\tif(opts.call(t) == \"[object Function]\"){\r\n\t\t\t\t\t// non-trivial function method => attach its name\r\n\t\t\t\t\tt.nom = name;\r\n\t\t\t\t}\r\n\t\t\t\ttarget[name] = t;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\r\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\r\n\t\t\t\tname = extraNames[--i];\r\n\t\t\t\tt = source[name];\r\n\t\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\r\n\t\t\t\t\tif(opts.call(t) == \"[object Function]\"){\r\n\t\t\t\t\t\t// non-trivial function method => attach its name\r\n\t\t\t\t\t\t  t.nom = name;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[name] = t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t}\r\n\r\n\tfunction extend(source){\r\n\t\tdeclare.safeMixin(this.prototype, source);\r\n\t\treturn this;\r\n\t}\r\n\r\n    function createSubclass(mixins, props){\r\n        // crack parameters\r\n        if(!(mixins instanceof Array || typeof mixins == 'function')){\r\n            props = mixins;\r\n            mixins = undefined;\r\n        }\r\n\r\n        props = props || {};\r\n        mixins = mixins || [];\r\n\r\n        return declare([this].concat(mixins), props);\r\n    }\r\n\r\n\t// chained constructor compatible with the legacy declare()\r\n\tfunction chainedConstructor(bases, ctorSpecial){\r\n\t\treturn function(){\r\n\t\t\tvar a = arguments, args = a, a0 = a[0], f, i, m,\r\n\t\t\t\tl = bases.length, preArgs;\r\n\r\n\t\t\tif(!(this instanceof a.callee)){\r\n\t\t\t\t// not called via new, so force it\r\n\t\t\t\treturn applyNew(a);\r\n\t\t\t}\r\n\r\n\t\t\t//this._inherited = {};\r\n\t\t\t// perform the shaman's rituals of the original declare()\r\n\t\t\t// 1) call two types of the preamble\r\n\t\t\tif(ctorSpecial && (a0 && a0.preamble || this.preamble)){\r\n\t\t\t\t// full blown ritual\r\n\t\t\t\tpreArgs = new Array(bases.length);\r\n\t\t\t\t// prepare parameters\r\n\t\t\t\tpreArgs[0] = a;\r\n\t\t\t\tfor(i = 0;;){\r\n\t\t\t\t\t// process the preamble of the 1st argument\r\n\t\t\t\t\ta0 = a[0];\r\n\t\t\t\t\tif(a0){\r\n\t\t\t\t\t\tf = a0.preamble;\r\n\t\t\t\t\t\tif(f){\r\n\t\t\t\t\t\t\ta = f.apply(this, a) || a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// process the preamble of this class\r\n\t\t\t\t\tf = bases[i].prototype;\r\n\t\t\t\t\tf = f.hasOwnProperty(\"preamble\") && f.preamble;\r\n\t\t\t\t\tif(f){\r\n\t\t\t\t\t\ta = f.apply(this, a) || a;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// one peculiarity of the preamble:\r\n\t\t\t\t\t// it is called if it is not needed,\r\n\t\t\t\t\t// e.g., there is no constructor to call\r\n\t\t\t\t\t// let's watch for the last constructor\r\n\t\t\t\t\t// (see ticket #9795)\r\n\t\t\t\t\tif(++i == l){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpreArgs[i] = a;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 2) call all non-trivial constructors using prepared arguments\r\n\t\t\tfor(i = l - 1; i >= 0; --i){\r\n\t\t\t\tf = bases[i];\r\n\t\t\t\tm = f._meta;\r\n\t\t\t\tf = m ? m.ctor : f;\r\n\t\t\t\tif(f){\r\n\t\t\t\t\tf.apply(this, preArgs ? preArgs[i] : a);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 3) continue the original ritual: call the postscript\r\n\t\t\tf = this.postscript;\r\n\t\t\tif(f){\r\n\t\t\t\tf.apply(this, args);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// chained constructor compatible with the legacy declare()\r\n\tfunction singleConstructor(ctor, ctorSpecial){\r\n\t\treturn function(){\r\n\t\t\tvar a = arguments, t = a, a0 = a[0], f;\r\n\r\n\t\t\tif(!(this instanceof a.callee)){\r\n\t\t\t\t// not called via new, so force it\r\n\t\t\t\treturn applyNew(a);\r\n\t\t\t}\r\n\r\n\t\t\t//this._inherited = {};\r\n\t\t\t// perform the shaman's rituals of the original declare()\r\n\t\t\t// 1) call two types of the preamble\r\n\t\t\tif(ctorSpecial){\r\n\t\t\t\t// full blown ritual\r\n\t\t\t\tif(a0){\r\n\t\t\t\t\t// process the preamble of the 1st argument\r\n\t\t\t\t\tf = a0.preamble;\r\n\t\t\t\t\tif(f){\r\n\t\t\t\t\t\tt = f.apply(this, t) || t;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tf = this.preamble;\r\n\t\t\t\tif(f){\r\n\t\t\t\t\t// process the preamble of this class\r\n\t\t\t\t\tf.apply(this, t);\r\n\t\t\t\t\t// one peculiarity of the preamble:\r\n\t\t\t\t\t// it is called even if it is not needed,\r\n\t\t\t\t\t// e.g., there is no constructor to call\r\n\t\t\t\t\t// let's watch for the last constructor\r\n\t\t\t\t\t// (see ticket #9795)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 2) call a constructor\r\n\t\t\tif(ctor){\r\n\t\t\t\tctor.apply(this, a);\r\n\t\t\t}\r\n\t\t\t// 3) continue the original ritual: call the postscript\r\n\t\t\tf = this.postscript;\r\n\t\t\tif(f){\r\n\t\t\t\tf.apply(this, a);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// plain vanilla constructor (can use inherited() to call its base constructor)\r\n\tfunction simpleConstructor(bases){\r\n\t\treturn function(){\r\n\t\t\tvar a = arguments, i = 0, f, m;\r\n\r\n\t\t\tif(!(this instanceof a.callee)){\r\n\t\t\t\t// not called via new, so force it\r\n\t\t\t\treturn applyNew(a);\r\n\t\t\t}\r\n\r\n\t\t\t//this._inherited = {};\r\n\t\t\t// perform the shaman's rituals of the original declare()\r\n\t\t\t// 1) do not call the preamble\r\n\t\t\t// 2) call the top constructor (it can use this.inherited())\r\n\t\t\tfor(; f = bases[i]; ++i){ // intentional assignment\r\n\t\t\t\tm = f._meta;\r\n\t\t\t\tf = m ? m.ctor : f;\r\n\t\t\t\tif(f){\r\n\t\t\t\t\tf.apply(this, a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 3) call the postscript\r\n\t\t\tf = this.postscript;\r\n\t\t\tif(f){\r\n\t\t\t\tf.apply(this, a);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction chain(name, bases, reversed){\r\n\t\treturn function(){\r\n\t\t\tvar b, m, f, i = 0, step = 1;\r\n\t\t\tif(reversed){\r\n\t\t\t\ti = bases.length - 1;\r\n\t\t\t\tstep = -1;\r\n\t\t\t}\r\n\t\t\tfor(; b = bases[i]; i += step){ // intentional assignment\r\n\t\t\t\tm = b._meta;\r\n\t\t\t\tf = (m ? m.hidden : b.prototype)[name];\r\n\t\t\t\tif(f){\r\n\t\t\t\t\tf.apply(this, arguments);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// forceNew(ctor)\r\n\t// return a new object that inherits from ctor.prototype but\r\n\t// without actually running ctor on the object.\r\n\tfunction forceNew(ctor){\r\n\t\t// create object with correct prototype using a do-nothing\r\n\t\t// constructor\r\n\t\txtor.prototype = ctor.prototype;\r\n\t\tvar t = new xtor;\r\n\t\txtor.prototype = null;\t// clean up\r\n\t\treturn t;\r\n\t}\r\n\r\n\t// applyNew(args)\r\n\t// just like 'new ctor()' except that the constructor and its arguments come\r\n\t// from args, which must be an array or an arguments object\r\n\tfunction applyNew(args){\r\n\t\t// create an object with ctor's prototype but without\r\n\t\t// calling ctor on it.\r\n\t\tvar ctor = args.callee, t = forceNew(ctor);\r\n\t\t// execute the real constructor on the new object\r\n\t\tctor.apply(t, args);\r\n\t\treturn t;\r\n\t}\r\n\r\n\tfunction declare(className, superclass, props){\r\n\t\t// summary:\r\n\t\t//\t\tCreate a feature-rich constructor from compact notation.\r\n\t\t// className: String?\r\n\t\t//\t\tThe optional name of the constructor (loosely, a \"class\")\r\n\t\t//\t\tstored in the \"declaredClass\" property in the created prototype.\r\n\t\t//\t\tIt will be used as a global name for a created constructor.\r\n\t\t// superclass: Function|Function[]\r\n\t\t//\t\tMay be null, a Function, or an Array of Functions. This argument\r\n\t\t//\t\tspecifies a list of bases (the left-most one is the most deepest\r\n\t\t//\t\tbase).\r\n\t\t// props: Object\r\n\t\t//\t\tAn object whose properties are copied to the created prototype.\r\n\t\t//\t\tAdd an instance-initialization function by making it a property\r\n\t\t//\t\tnamed \"constructor\".\r\n\t\t// returns: dojo/_base/declare.__DeclareCreatedObject\r\n\t\t//\t\tNew constructor function.\r\n\t\t// description:\r\n\t\t//\t\tCreate a constructor using a compact notation for inheritance and\r\n\t\t//\t\tprototype extension.\r\n\t\t//\r\n\t\t//\t\tMixin ancestors provide a type of multiple inheritance.\r\n\t\t//\t\tPrototypes of mixin ancestors are copied to the new class:\r\n\t\t//\t\tchanges to mixin prototypes will not affect classes to which\r\n\t\t//\t\tthey have been mixed in.\r\n\t\t//\r\n\t\t//\t\tAncestors can be compound classes created by this version of\r\n\t\t//\t\tdeclare(). In complex cases all base classes are going to be\r\n\t\t//\t\tlinearized according to C3 MRO algorithm\r\n\t\t//\t\t(see http://www.python.org/download/releases/2.3/mro/ for more\r\n\t\t//\t\tdetails).\r\n\t\t//\r\n\t\t//\t\t\"className\" is cached in \"declaredClass\" property of the new class,\r\n\t\t//\t\tif it was supplied. The immediate super class will be cached in\r\n\t\t//\t\t\"superclass\" property of the new class.\r\n\t\t//\r\n\t\t//\t\tMethods in \"props\" will be copied and modified: \"nom\" property\r\n\t\t//\t\t(the declared name of the method) will be added to all copied\r\n\t\t//\t\tfunctions to help identify them for the internal machinery. Be\r\n\t\t//\t\tvery careful, while reusing methods: if you use the same\r\n\t\t//\t\tfunction under different names, it can produce errors in some\r\n\t\t//\t\tcases.\r\n\t\t//\r\n\t\t//\t\tIt is possible to use constructors created \"manually\" (without\r\n\t\t//\t\tdeclare()) as bases. They will be called as usual during the\r\n\t\t//\t\tcreation of an instance, their methods will be chained, and even\r\n\t\t//\t\tcalled by \"this.inherited()\".\r\n\t\t//\r\n\t\t//\t\tSpecial property \"-chains-\" governs how to chain methods. It is\r\n\t\t//\t\ta dictionary, which uses method names as keys, and hint strings\r\n\t\t//\t\tas values. If a hint string is \"after\", this method will be\r\n\t\t//\t\tcalled after methods of its base classes. If a hint string is\r\n\t\t//\t\t\"before\", this method will be called before methods of its base\r\n\t\t//\t\tclasses.\r\n\t\t//\r\n\t\t//\t\tIf \"constructor\" is not mentioned in \"-chains-\" property, it will\r\n\t\t//\t\tbe chained using the legacy mode: using \"after\" chaining,\r\n\t\t//\t\tcalling preamble() method before each constructor, if available,\r\n\t\t//\t\tand calling postscript() after all constructors were executed.\r\n\t\t//\t\tIf the hint is \"after\", it is chained as a regular method, but\r\n\t\t//\t\tpostscript() will be called after the chain of constructors.\r\n\t\t//\t\t\"constructor\" cannot be chained \"before\", but it allows\r\n\t\t//\t\ta special hint string: \"manual\", which means that constructors\r\n\t\t//\t\tare not going to be chained in any way, and programmer will call\r\n\t\t//\t\tthem manually using this.inherited(). In the latter case\r\n\t\t//\t\tpostscript() will be called after the construction.\r\n\t\t//\r\n\t\t//\t\tAll chaining hints are \"inherited\" from base classes and\r\n\t\t//\t\tpotentially can be overridden. Be very careful when overriding\r\n\t\t//\t\thints! Make sure that all chained methods can work in a proposed\r\n\t\t//\t\tmanner of chaining.\r\n\t\t//\r\n\t\t//\t\tOnce a method was chained, it is impossible to unchain it. The\r\n\t\t//\t\tonly exception is \"constructor\". You don't need to define a\r\n\t\t//\t\tmethod in order to supply a chaining hint.\r\n\t\t//\r\n\t\t//\t\tIf a method is chained, it cannot use this.inherited() because\r\n\t\t//\t\tall other methods in the hierarchy will be called automatically.\r\n\t\t//\r\n\t\t//\t\tUsually constructors and initializers of any kind are chained\r\n\t\t//\t\tusing \"after\" and destructors of any kind are chained as\r\n\t\t//\t\t\"before\". Note that chaining assumes that chained methods do not\r\n\t\t//\t\treturn any value: any returned value will be discarded.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tdeclare(\"my.classes.bar\", my.classes.foo, {\r\n\t\t//\t|\t\t// properties to be added to the class prototype\r\n\t\t//\t|\t\tsomeValue: 2,\r\n\t\t//\t|\t\t// initialization function\r\n\t\t//\t|\t\tconstructor: function(){\r\n\t\t//\t|\t\t\tthis.myComplicatedObject = new ReallyComplicatedObject();\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\t// other functions\r\n\t\t//\t|\t\tsomeMethod: function(){\r\n\t\t//\t|\t\t\tdoStuff();\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar MyBase = declare(null, {\r\n\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t//\t|\t\t// ...\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar MyClass1 = declare(MyBase, {\r\n\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t//\t|\t\t// ...\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar MyClass2 = declare(MyBase, {\r\n\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t//\t|\t\t// ...\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar MyDiamond = declare([MyClass1, MyClass2], {\r\n\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t//\t|\t\t// ...\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar F = function(){ console.log(\"raw constructor\"); };\r\n\t\t//\t|\tF.prototype.method = function(){\r\n\t\t//\t|\t\tconsole.log(\"raw method\");\r\n\t\t//\t|\t};\r\n\t\t//\t|\tvar A = declare(F, {\r\n\t\t//\t|\t\tconstructor: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"A.constructor\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tmethod: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"before calling F.method...\");\r\n\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t//\t|\t\t\tconsole.log(\"...back in A\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tnew A().method();\r\n\t\t//\t|\t// will print:\r\n\t\t//\t|\t// raw constructor\r\n\t\t//\t|\t// A.constructor\r\n\t\t//\t|\t// before calling F.method...\r\n\t\t//\t|\t// raw method\r\n\t\t//\t|\t// ...back in A\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar A = declare(null, {\r\n\t\t//\t|\t\t\"-chains-\": {\r\n\t\t//\t|\t\t\tdestroy: \"before\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar B = declare(A, {\r\n\t\t//\t|\t\tconstructor: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"B.constructor\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tdestroy: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"B.destroy\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar C = declare(B, {\r\n\t\t//\t|\t\tconstructor: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"C.constructor\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tdestroy: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"C.destroy\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tnew C().destroy();\r\n\t\t//\t|\t// prints:\r\n\t\t//\t|\t// B.constructor\r\n\t\t//\t|\t// C.constructor\r\n\t\t//\t|\t// C.destroy\r\n\t\t//\t|\t// B.destroy\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar A = declare(null, {\r\n\t\t//\t|\t\t\"-chains-\": {\r\n\t\t//\t|\t\t\tconstructor: \"manual\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar B = declare(A, {\r\n\t\t//\t|\t\tconstructor: function(){\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t\t// call the base constructor with new parameters\r\n\t\t//\t|\t\t\tthis.inherited(arguments, [1, 2, 3]);\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tvar A = declare(null, {\r\n\t\t//\t|\t\t\"-chains-\": {\r\n\t\t//\t|\t\t\tm1: \"before\"\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm1: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm2: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar B = declare(A, {\r\n\t\t//\t|\t\t\"-chains-\": {\r\n\t\t//\t|\t\t\tm2: \"after\"\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm1: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\t\tm2: function(){\r\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\tvar x = new B();\r\n\t\t//\t|\tx.m1();\r\n\t\t//\t|\t// prints:\r\n\t\t//\t|\t// B.m1\r\n\t\t//\t|\t// A.m1\r\n\t\t//\t|\tx.m2();\r\n\t\t//\t|\t// prints:\r\n\t\t//\t|\t// A.m2\r\n\t\t//\t|\t// B.m2\r\n\r\n\t\t// crack parameters\r\n\t\tif(typeof className != \"string\"){\r\n\t\t\tprops = superclass;\r\n\t\t\tsuperclass = className;\r\n\t\t\tclassName = \"\";\r\n\t\t}\r\n\t\tprops = props || {};\r\n\r\n\t\tvar proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;\r\n\r\n\t\t// build a prototype\r\n\t\tif(opts.call(superclass) == \"[object Array]\"){\r\n\t\t\t// C3 MRO\r\n\t\t\tbases = c3mro(superclass, className);\r\n\t\t\tt = bases[0];\r\n\t\t\tmixins = bases.length - t;\r\n\t\t\tsuperclass = bases[mixins];\r\n\t\t}else{\r\n\t\t\tbases = [0];\r\n\t\t\tif(superclass){\r\n\t\t\t\tif(opts.call(superclass) == \"[object Function]\"){\r\n\t\t\t\t\tt = superclass._meta;\r\n\t\t\t\t\tbases = bases.concat(t ? t.bases : superclass);\r\n\t\t\t\t}else{\r\n\t\t\t\t\terr(\"base class is not a callable constructor.\", className);\r\n\t\t\t\t}\r\n\t\t\t}else if(superclass !== null){\r\n\t\t\t\terr(\"unknown base class. Did you use dojo.require to pull it in?\", className);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(superclass){\r\n\t\t\tfor(i = mixins - 1;; --i){\r\n\t\t\t\tproto = forceNew(superclass);\r\n\t\t\t\tif(!i){\r\n\t\t\t\t\t// stop if nothing to add (the last base)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// mix in properties\r\n\t\t\t\tt = bases[i];\r\n\t\t\t\t(t._meta ? mixOwn : mix)(proto, t.prototype);\r\n\t\t\t\t// chain in new constructor\r\n\t\t\t\tctor = new Function;\r\n\t\t\t\tctor.superclass = superclass;\r\n\t\t\t\tctor.prototype = proto;\r\n\t\t\t\tsuperclass = proto.constructor = ctor;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tproto = {};\r\n\t\t}\r\n\t\t// add all properties\r\n\t\tdeclare.safeMixin(proto, props);\r\n\t\t// add constructor\r\n\t\tt = props.constructor;\r\n\t\tif(t !== op.constructor){\r\n\t\t\tt.nom = cname;\r\n\t\t\tproto.constructor = t;\r\n\t\t}\r\n\r\n\t\t// collect chains and flags\r\n\t\tfor(i = mixins - 1; i; --i){ // intentional assignment\r\n\t\t\tt = bases[i]._meta;\r\n\t\t\tif(t && t.chains){\r\n\t\t\t\tchains = mix(chains || {}, t.chains);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(proto[\"-chains-\"]){\r\n\t\t\tchains = mix(chains || {}, proto[\"-chains-\"]);\r\n\t\t}\r\n\r\n\t\t// build ctor\r\n\t\tt = !chains || !chains.hasOwnProperty(cname);\r\n\t\tbases[0] = ctor = (chains && chains.constructor === \"manual\") ? simpleConstructor(bases) :\r\n\t\t\t(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));\r\n\r\n\t\t// add meta information to the constructor\r\n\t\tctor._meta  = {bases: bases, hidden: props, chains: chains,\r\n\t\t\tparents: parents, ctor: props.constructor};\r\n\t\tctor.superclass = superclass && superclass.prototype;\r\n\t\tctor.extend = extend;\r\n\t\tctor.createSubclass = createSubclass;\r\n\t\tctor.prototype = proto;\r\n\t\tproto.constructor = ctor;\r\n\r\n\t\t// add \"standard\" methods to the prototype\r\n\t\tproto.getInherited = getInherited;\r\n\t\tproto.isInstanceOf = isInstanceOf;\r\n\t\tproto.inherited    = inheritedImpl;\r\n\t\tproto.__inherited  = inherited;\r\n\r\n\t\t// add name if specified\r\n\t\tif(className){\r\n\t\t\tproto.declaredClass = className;\r\n\t\t\tlang.setObject(className, ctor);\r\n\t\t}\r\n\r\n\t\t// build chains and add them to the prototype\r\n\t\tif(chains){\r\n\t\t\tfor(name in chains){\r\n\t\t\t\tif(proto[name] && typeof chains[name] == \"string\" && name != cname){\r\n\t\t\t\t\tt = proto[name] = chain(name, bases, chains[name] === \"after\");\r\n\t\t\t\t\tt.nom = name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// chained methods do not return values\r\n\t\t// no need to chain \"invisible\" functions\r\n\r\n\t\treturn ctor;\t// Function\r\n\t}\r\n\r\n\t/*=====\r\n\tdeclare.__DeclareCreatedObject = {\r\n\t\t// summary:\r\n\t\t//\t\tdojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following\r\n\t\t//\t\tmethods, in addition to the methods and properties specified via the arguments passed to declare().\r\n\r\n\t\tinherited: function(name, args, newArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls a super method.\r\n\t\t\t// name: String?\r\n\t\t\t//\t\tThe optional method name. Should be the same as the caller's\r\n\t\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\r\n\t\t\t//\t\tthe calling method was dynamically added, undecorated by\r\n\t\t\t//\t\tdeclare(), and it cannot be determined.\r\n\t\t\t// args: Arguments\r\n\t\t\t//\t\tThe caller supply this argument, which should be the original\r\n\t\t\t//\t\t\"arguments\".\r\n\t\t\t// newArgs: Object?\r\n\t\t\t//\t\tIf \"true\", the found function will be returned without\r\n\t\t\t//\t\texecuting it.\r\n\t\t\t//\t\tIf Array, it will be used to call a super method. Otherwise\r\n\t\t\t//\t\t\"args\" will be used.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tWhatever is returned by a super method, or a super method itself,\r\n\t\t\t//\t\tif \"true\" was specified as newArgs.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method is used inside method of classes produced with\r\n\t\t\t//\t\tdeclare() to call a super method (next in the chain). It is\r\n\t\t\t//\t\tused for manually controlled chaining. Consider using the regular\r\n\t\t\t//\t\tchaining, because it is faster. Use \"this.inherited()\" only in\r\n\t\t\t//\t\tcomplex cases.\r\n\t\t\t//\r\n\t\t\t//\t\tThis method cannot me called from automatically chained\r\n\t\t\t//\t\tconstructors including the case of a special (legacy)\r\n\t\t\t//\t\tconstructor chaining. It cannot be called from chained methods.\r\n\t\t\t//\r\n\t\t\t//\t\tIf \"this.inherited()\" cannot find the next-in-chain method, it\r\n\t\t\t//\t\tdoes nothing and returns \"undefined\". The last method in chain\r\n\t\t\t//\t\tcan be a default method implemented in Object, which will be\r\n\t\t\t//\t\tcalled last.\r\n\t\t\t//\r\n\t\t\t//\t\tIf \"name\" is specified, it is assumed that the method that\r\n\t\t\t//\t\treceived \"args\" is the parent method for this call. It is looked\r\n\t\t\t//\t\tup in the chain list and if it is found the next-in-chain method\r\n\t\t\t//\t\tis called. If it is not found, the first-in-chain method is\r\n\t\t\t//\t\tcalled.\r\n\t\t\t//\r\n\t\t\t//\t\tIf \"name\" is not specified, it will be derived from the calling\r\n\t\t\t//\t\tmethod (using a methoid property \"nom\").\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar B = declare(A, {\r\n\t\t\t//\t|\t\tmethod1: function(a, b, c){\r\n\t\t\t//\t|\t\t\tthis.inherited(arguments);\r\n\t\t\t//\t|\t\t},\r\n\t\t\t//\t|\t\tmethod2: function(a, b){\r\n\t\t\t//\t|\t\t\treturn this.inherited(arguments, [a + b]);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\t// next method is not in the chain list because it is added\r\n\t\t\t//\t|\t// manually after the class was created.\r\n\t\t\t//\t|\tB.prototype.method3 = function(){\r\n\t\t\t//\t|\t\tconsole.log(\"This is a dynamically-added method.\");\r\n\t\t\t//\t|\t\tthis.inherited(\"method3\", arguments);\r\n\t\t\t//\t|\t};\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar B = declare(A, {\r\n\t\t\t//\t|\t\tmethod: function(a, b){\r\n\t\t\t//\t|\t\t\tvar super = this.inherited(arguments, true);\r\n\t\t\t//\t|\t\t\t// ...\r\n\t\t\t//\t|\t\t\tif(!super){\r\n\t\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\r\n\t\t\t//\t|\t\t\t\treturn 0;\r\n\t\t\t//\t|\t\t\t}\r\n\t\t\t//\t|\t\t\treturn super.apply(this, arguments);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\treturn\t{};\t// Object\r\n\t\t},\r\n\r\n\t\tgetInherited: function(name, args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a super method.\r\n\t\t\t// name: String?\r\n\t\t\t//\t\tThe optional method name. Should be the same as the caller's\r\n\t\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\r\n\t\t\t//\t\tthe calling method was dynamically added, undecorated by\r\n\t\t\t//\t\tdeclare(), and it cannot be determined.\r\n\t\t\t// args: Arguments\r\n\t\t\t//\t\tThe caller supply this argument, which should be the original\r\n\t\t\t//\t\t\"arguments\".\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns a super method (Function) or \"undefined\".\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method is a convenience method for \"this.inherited()\".\r\n\t\t\t//\t\tIt uses the same algorithm but instead of executing a super\r\n\t\t\t//\t\tmethod, it returns it, or \"undefined\" if not found.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar B = declare(A, {\r\n\t\t\t//\t|\t\tmethod: function(a, b){\r\n\t\t\t//\t|\t\t\tvar super = this.getInherited(arguments);\r\n\t\t\t//\t|\t\t\t// ...\r\n\t\t\t//\t|\t\t\tif(!super){\r\n\t\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\r\n\t\t\t//\t|\t\t\t\treturn 0;\r\n\t\t\t//\t|\t\t\t}\r\n\t\t\t//\t|\t\t\treturn super.apply(this, arguments);\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\t\t\treturn\t{};\t// Object\r\n\t\t},\r\n\r\n\t\tisInstanceOf: function(cls){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks the inheritance chain to see if it is inherited from this\r\n\t\t\t//\t\tclass.\r\n\t\t\t// cls: Function\r\n\t\t\t//\t\tClass constructor.\r\n\t\t\t// returns:\r\n\t\t\t//\t\t\"true\", if this object is inherited from this class, \"false\"\r\n\t\t\t//\t\totherwise.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method is used with instances of classes produced with\r\n\t\t\t//\t\tdeclare() to determine of they support a certain interface or\r\n\t\t\t//\t\tnot. It models \"instanceof\" operator.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar A = declare(null, {\r\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t\t//\t|\t\t// ...\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar B = declare(null, {\r\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t\t//\t|\t\t// ...\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar C = declare([A, B], {\r\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t\t//\t|\t\t// ...\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar D = declare(A, {\r\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\r\n\t\t\t//\t|\t\t// ...\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\r\n\t\t\t//\t|\tvar a = new A(), b = new B(), c = new C(), d = new D();\r\n\t\t\t//\t|\r\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(A)); // true\r\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(A)); // false\r\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(A)); // true\r\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(A)); // true\r\n\t\t\t//\t|\r\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(B)); // false\r\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(B)); // true\r\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(B)); // true\r\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(B)); // false\r\n\t\t\t//\t|\r\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(C)); // false\r\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(C)); // false\r\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(C)); // true\r\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(C)); // false\r\n\t\t\t//\t|\r\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(D)); // false\r\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(D)); // false\r\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(D)); // false\r\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(D)); // true\r\n\t\t\treturn\t{};\t// Object\r\n\t\t},\r\n\r\n\t\textend: function(source){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds all properties and methods of source to constructor's\r\n\t\t\t//\t\tprototype, making them available to all instances created with\r\n\t\t\t//\t\tconstructor. This method is specific to constructors created with\r\n\t\t\t//\t\tdeclare().\r\n\t\t\t// source: Object\r\n\t\t\t//\t\tSource object which properties are going to be copied to the\r\n\t\t\t//\t\tconstructor's prototype.\r\n\t\t\t// description:\r\n\t\t\t//\t\tAdds source properties to the constructor's prototype. It can\r\n\t\t\t//\t\toverride existing properties.\r\n\t\t\t//\r\n\t\t\t//\t\tThis method is similar to dojo.extend function, but it is specific\r\n\t\t\t//\t\tto constructors produced by declare(). It is implemented\r\n\t\t\t//\t\tusing dojo.safeMixin, and it skips a constructor property,\r\n\t\t\t//\t\tand properly decorates copied functions.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar A = declare(null, {\r\n\t\t\t//\t|\t\tm1: function(){},\r\n\t\t\t//\t|\t\ts1: \"Popokatepetl\"\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tA.extend({\r\n\t\t\t//\t|\t\tm1: function(){},\r\n\t\t\t//\t|\t\tm2: function(){},\r\n\t\t\t//\t|\t\tf1: true,\r\n\t\t\t//\t|\t\td1: 42\r\n\t\t\t//\t|\t});\r\n\t\t},\r\n\r\n\t\tcreateSubclass: function(mixins, props){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate a subclass of the declared class from a list of base classes.\r\n\t\t\t// mixins: Function[]\r\n\t\t\t//\t\tSpecifies a list of bases (the left-most one is the most deepest\r\n\t\t\t//\t\tbase).\r\n\t\t\t// props: Object?\r\n\t\t\t//\t\tAn optional object whose properties are copied to the created prototype.\r\n\t\t\t// returns: dojo/_base/declare.__DeclareCreatedObject\r\n\t\t\t//\t\tNew constructor function.\r\n\t\t\t// description:\r\n\t\t\t//\t\tCreate a constructor using a compact notation for inheritance and\r\n\t\t\t//\t\tprototype extension.\r\n\t\t\t//\r\n\t\t\t//\t\tMixin ancestors provide a type of multiple inheritance.\r\n\t\t\t//\t\tPrototypes of mixin ancestors are copied to the new class:\r\n\t\t\t//\t\tchanges to mixin prototypes will not affect classes to which\r\n\t\t\t//\t\tthey have been mixed in.\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar A = declare(null, {\r\n\t\t\t//\t|\t\tm1: function(){},\r\n\t\t\t//\t|\t\ts1: \"bar\"\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar B = declare(null, {\r\n\t\t\t//\t|\t\tm2: function(){},\r\n\t\t\t//\t|\t\ts2: \"foo\"\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar C = declare(null, {\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar D1 = A.createSubclass([B, C], {\r\n\t\t\t//\t|\t\tm1: function(){},\r\n\t\t\t//\t|\t\td1: 42\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar d1 = new D1();\r\n\t\t\t//\t|\r\n\t\t\t//\t|\t// this is equivalent to:\r\n\t\t\t//\t|\tvar D2 = declare([A, B, C], {\r\n\t\t\t//\t|\t\tm1: function(){},\r\n\t\t\t//\t|\t\td1: 42\r\n\t\t\t//\t|\t});\r\n\t\t\t//\t|\tvar d2 = new D2();\r\n\t\t}\r\n\t};\r\n\t=====*/\r\n\r\n\t// For back-compat, remove for 2.0\r\n\tdojo.safeMixin = declare.safeMixin = safeMixin;\r\n\tdojo.declare = declare;\r\n\r\n\treturn declare;\r\n});\r\n"]}