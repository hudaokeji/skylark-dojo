{"version":3,"sources":["Deferred.js"],"names":["define","has","lang","CancelError","Promise","instrumentation","FULFILLED_ERROR_MESSAGE","freezeObject","Object","freeze","signalWaiting","waiting","type","result","rejection","deferred","Deferred","instrumentRejected","length","i","signalListener","listener","func","newResult","signalDeferred","then","cancel","makeDeferredSignaler","error","promise","value","isCanceled","progress","resolve","reject","canceler","fulfilled","this","canceled","Error","captureStackTrace","isResolved","isRejected","isFulfilled","update","strict","callback","errback","progback","reason","push","returnedReason","prototype","toString"],"mappings":";;;;;;;AAAAA,QACC,QACA,eACA,uBACA,oBACA,kEACE,SAASC,EAAKC,EAAMC,EAAaC,EAASC,GAC5C,aAKA,IAGIC,EAA0B,4CAE1BC,EAAeC,OAAOC,QAAU,aAEhCC,EAAgB,SAASC,EAASC,EAAMC,EAAQC,EAAWC,GAC3Dd,EAAI,mCANK,IAORW,GAAqBI,EAASC,oBAAyC,IAAnBN,EAAQO,QAC9DF,EAASC,mBAAmBJ,GAAQ,EAAOC,EAAWC,GAIxD,IAAI,IAAII,EAAI,EAAGA,EAAIR,EAAQO,OAAQC,IAClCC,EAAeT,EAAQQ,GAAIP,EAAMC,EAAQC,IAIvCM,EAAiB,SAASC,EAAUT,EAAMC,EAAQC,GACrD,IAAIQ,EAAOD,EAAST,GAChBG,EAAWM,EAASN,SACxB,GAAGO,EACF,IACC,IAAIC,EAAYD,EAAKT,GACrB,GAzBY,IAyBTD,OACsB,IAAdW,GACTC,EAAeT,EAAUH,EAAMW,OAE5B,CACJ,GAAGA,GAAuC,mBAAnBA,EAAUE,KAOhC,OANAJ,EAASK,OAASH,EAAUG,YAC5BH,EAAUE,KAERE,EAAqBZ,EAjCf,GAkCNY,EAAqBZ,EAjCf,GAkCNY,EAAqBZ,EApCb,IAuCXS,EAAeT,EAtCN,EAsC0BQ,IAEpC,MAAMK,GACNJ,EAAeT,EAxCL,EAwCyBa,QAGpCJ,EAAeT,EAAUH,EAAMC,GAG7BZ,EAAI,mCA9CK,IA+CRW,GAAqBI,EAASC,oBAChCD,EAASC,mBAAmBJ,IAAUS,EAAMR,EAAWC,EAASc,UAK/DF,EAAuB,SAASZ,EAAUH,GAC7C,OAAO,SAASkB,GACfN,EAAeT,EAAUH,EAAMkB,KAI7BN,EAAiB,SAAST,EAAUH,EAAMC,GAC7C,IAAIE,EAASgB,aACZ,OAAOnB,GACN,KAhEY,EAiEXG,EAASiB,SAASnB,GAClB,MACD,KAlEU,EAmETE,EAASkB,QAAQpB,GACjB,MACD,KApEU,EAqETE,EAASmB,OAAOrB,KAMhBG,EAAW,SAASmB,GAiBvB,IAGIC,EAAWvB,EAAQC,EAHnBe,EAAUQ,KAAKR,QAAU,IAAIzB,EAE7BW,EAAWsB,KAEXC,GAAW,EACX3B,KAEDV,EAAI,mCAAqCsC,MAAMC,oBACjDD,MAAMC,kBAAkBzB,EAAUC,GAClCuB,MAAMC,kBAAkBX,EAASb,IAGlCqB,KAAKI,WAAaZ,EAAQY,WAAa,WAKtC,OA9GW,IA8GJL,GAGRC,KAAKK,WAAab,EAAQa,WAAa,WAKtC,OArHW,IAqHJN,GAGRC,KAAKM,YAAcd,EAAQc,YAAc,WAKxC,QAASP,GAGVC,KAAKN,WAAaF,EAAQE,WAAa,WAKtC,OAAOO,GAGRD,KAAKL,SAAW,SAASY,EAAQC,GAehC,GAAIT,EAGE,CAAA,IAAc,IAAXS,EACR,MAAM,IAAIN,MAAMjC,GAEhB,OAAOuB,EAJP,OADAnB,EAAcC,EA1JF,EA0JqBiC,EAAQ,KAAM7B,GACxCc,GAQTQ,KAAKJ,QAAU,SAASH,EAAOe,GAa9B,GAAIT,EAME,CAAA,IAAc,IAAXS,EACR,MAAM,IAAIN,MAAMjC,GAEhB,OAAOuB,EAJP,OAFAnB,EAAcC,EAASyB,EAlLb,EAkLmCvB,EAASiB,EAAO,KAAMf,GACnEJ,EAAU,KACHkB,GAQT,IAAIK,EAASG,KAAKH,OAAS,SAASN,EAAOiB,GAa1C,GAAIT,EAOE,CAAA,IAAc,IAAXS,EACR,MAAM,IAAIN,MAAMjC,GAEhB,OAAOuB,EAJP,OALG5B,EAAI,mCAAqCsC,MAAMC,mBACjDD,MAAMC,kBAAkB1B,KAAgBoB,GAEzCxB,EAAcC,EAASyB,EA5Mb,EA4MmCvB,EAASe,EAAOd,EAAWC,GACxEJ,EAAU,KACHkB,GAQTQ,KAAKZ,KAAOI,EAAQJ,KAAO,SAASqB,EAAUC,EAASC,GAmBtD,IAAI3B,GAAY2B,EAAUF,EAAUC,GAcpC,OAXA1B,EAASK,OAASG,EAAQH,OAC1BL,EAASN,SAAW,IAAIC,EAAS,SAASiC,GAGzC,OAAO5B,EAASK,QAAUL,EAASK,OAAOuB,KAExCb,IAAczB,EAChBS,EAAeC,EAAUe,EAAWvB,EAAQC,GAE5CH,EAAQuC,KAAK7B,GAEPA,EAASN,SAASc,SAG1BQ,KAAKX,OAASG,EAAQH,OAAS,SAASuB,EAAQJ,GAkB/C,GAAIT,GAiBE,IAAc,IAAXS,EACR,MAAM,IAAIN,MAAMjC,OAlBH,CAEb,GAAG6B,EAAS,CACX,IAAIgB,EAAiBhB,EAASc,GAC9BA,OAAmC,IAAnBE,EAAiCF,EAASE,EAG3D,GADAb,GAAW,GACPF,EAMH,YAJqB,IAAXa,IACTA,EAAS,IAAI9C,GAEd+B,EAAOe,GACAA,EACF,GA1RI,IA0RDb,GAA0BvB,IAAWoC,EAC7C,OAAOA,IAOV1C,EAAasB,IAcd,OAXAb,EAASoC,UAAUC,SAAW,WAI7B,MAAO,qBAGLhD,GACFA,EAAgBW,GAGVA","file":"../Deferred.js","sourcesContent":["define([\r\n\t\"./has\",\r\n\t\"./_base/lang\",\r\n\t\"./errors/CancelError\",\r\n\t\"./promise/Promise\",\r\n\t\"./has!config-deferredInstrumentation?./promise/instrumentation\"\r\n], function(has, lang, CancelError, Promise, instrumentation){\r\n\t\"use strict\";\r\n\r\n\t// module:\r\n\t//\t\tdojo/Deferred\r\n\r\n\tvar PROGRESS = 0,\r\n\t\t\tRESOLVED = 1,\r\n\t\t\tREJECTED = 2;\r\n\tvar FULFILLED_ERROR_MESSAGE = \"This deferred has already been fulfilled.\";\r\n\r\n\tvar freezeObject = Object.freeze || function(){};\r\n\r\n\tvar signalWaiting = function(waiting, type, result, rejection, deferred){\r\n\t\tif(has(\"config-deferredInstrumentation\")){\r\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){\r\n\t\t\t\tDeferred.instrumentRejected(result, false, rejection, deferred);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < waiting.length; i++){\r\n\t\t\tsignalListener(waiting[i], type, result, rejection);\r\n\t\t}\r\n\t};\r\n\r\n\tvar signalListener = function(listener, type, result, rejection){\r\n\t\tvar func = listener[type];\r\n\t\tvar deferred = listener.deferred;\r\n\t\tif(func){\r\n\t\t\ttry{\r\n\t\t\t\tvar newResult = func(result);\r\n\t\t\t\tif(type === PROGRESS){\r\n\t\t\t\t\tif(typeof newResult !== \"undefined\"){\r\n\t\t\t\t\t\tsignalDeferred(deferred, type, newResult);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(newResult && typeof newResult.then === \"function\"){\r\n\t\t\t\t\t\tlistener.cancel = newResult.cancel;\r\n\t\t\t\t\t\tnewResult.then(\r\n\t\t\t\t\t\t\t\t// Only make resolvers if they're actually going to be used\r\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, RESOLVED),\r\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, REJECTED),\r\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, PROGRESS));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsignalDeferred(deferred, RESOLVED, newResult);\r\n\t\t\t\t}\r\n\t\t\t}catch(error){\r\n\t\t\t\tsignalDeferred(deferred, REJECTED, error);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tsignalDeferred(deferred, type, result);\r\n\t\t}\r\n\r\n\t\tif(has(\"config-deferredInstrumentation\")){\r\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected){\r\n\t\t\t\tDeferred.instrumentRejected(result, !!func, rejection, deferred.promise);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar makeDeferredSignaler = function(deferred, type){\r\n\t\treturn function(value){\r\n\t\t\tsignalDeferred(deferred, type, value);\r\n\t\t};\r\n\t};\r\n\r\n\tvar signalDeferred = function(deferred, type, result){\r\n\t\tif(!deferred.isCanceled()){\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase PROGRESS:\r\n\t\t\t\t\tdeferred.progress(result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase RESOLVED:\r\n\t\t\t\t\tdeferred.resolve(result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase REJECTED:\r\n\t\t\t\t\tdeferred.reject(result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar Deferred = function(canceler){\r\n\t\t// summary:\r\n\t\t//\t\tCreates a new deferred. This API is preferred over\r\n\t\t//\t\t`dojo/_base/Deferred`.\r\n\t\t// description:\r\n\t\t//\t\tCreates a new deferred, as an abstraction over (primarily)\r\n\t\t//\t\tasynchronous operations. The deferred is the private interface\r\n\t\t//\t\tthat should not be returned to calling code. That's what the\r\n\t\t//\t\t`promise` is for. See `dojo/promise/Promise`.\r\n\t\t// canceler: Function?\r\n\t\t//\t\tWill be invoked if the deferred is canceled. The canceler\r\n\t\t//\t\treceives the reason the deferred was canceled as its argument.\r\n\t\t//\t\tThe deferred is rejected with its return value, or a new\r\n\t\t//\t\t`dojo/errors/CancelError` instance.\r\n\r\n\t\t// promise: dojo/promise/Promise\r\n\t\t//\t\tThe public promise object that clients can add callbacks to. \r\n\t\tvar promise = this.promise = new Promise();\r\n\r\n\t\tvar deferred = this;\r\n\t\tvar fulfilled, result, rejection;\r\n\t\tvar canceled = false;\r\n\t\tvar waiting = [];\r\n\r\n\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\r\n\t\t\tError.captureStackTrace(deferred, Deferred);\r\n\t\t\tError.captureStackTrace(promise, Deferred);\r\n\t\t}\r\n\r\n\t\tthis.isResolved = promise.isResolved = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been resolved.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn fulfilled === RESOLVED;\r\n\t\t};\r\n\r\n\t\tthis.isRejected = promise.isRejected = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been rejected.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn fulfilled === REJECTED;\r\n\t\t};\r\n\r\n\t\tthis.isFulfilled = promise.isFulfilled = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been resolved or rejected.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn !!fulfilled;\r\n\t\t};\r\n\r\n\t\tthis.isCanceled = promise.isCanceled = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the deferred has been canceled.\r\n\t\t\t// returns: Boolean\r\n\r\n\t\t\treturn canceled;\r\n\t\t};\r\n\r\n\t\tthis.progress = function(update, strict){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEmit a progress update on the deferred.\r\n\t\t\t// description:\r\n\t\t\t//\t\tEmit a progress update on the deferred. Progress updates\r\n\t\t\t//\t\tcan be used to communicate updates about the asynchronous\r\n\t\t\t//\t\toperation before it has finished.\r\n\t\t\t// update: any\r\n\t\t\t//\t\tThe progress update. Passed to progbacks.\r\n\t\t\t// strict: Boolean?\r\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\r\n\t\t\t//\t\tbeen fulfilled and consequently no progress can be emitted.\r\n\t\t\t// returns: dojo/promise/Promise\r\n\t\t\t//\t\tReturns the original promise for the deferred.\r\n\r\n\t\t\tif(!fulfilled){\r\n\t\t\t\tsignalWaiting(waiting, PROGRESS, update, null, deferred);\r\n\t\t\t\treturn promise;\r\n\t\t\t}else if(strict === true){\r\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\r\n\t\t\t}else{\r\n\t\t\t\treturn promise;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.resolve = function(value, strict){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tResolve the deferred.\r\n\t\t\t// description:\r\n\t\t\t//\t\tResolve the deferred, putting it in a success state.\r\n\t\t\t// value: any\r\n\t\t\t//\t\tThe result of the deferred. Passed to callbacks.\r\n\t\t\t// strict: Boolean?\r\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\r\n\t\t\t//\t\tbeen fulfilled and consequently cannot be resolved.\r\n\t\t\t// returns: dojo/promise/Promise\r\n\t\t\t//\t\tReturns the original promise for the deferred.\r\n\r\n\t\t\tif(!fulfilled){\r\n\t\t\t\t// Set fulfilled, store value. After signaling waiting listeners unset\r\n\t\t\t\t// waiting.\r\n\t\t\t\tsignalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);\r\n\t\t\t\twaiting = null;\r\n\t\t\t\treturn promise;\r\n\t\t\t}else if(strict === true){\r\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\r\n\t\t\t}else{\r\n\t\t\t\treturn promise;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar reject = this.reject = function(error, strict){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReject the deferred.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReject the deferred, putting it in an error state.\r\n\t\t\t// error: any\r\n\t\t\t//\t\tThe error result of the deferred. Passed to errbacks.\r\n\t\t\t// strict: Boolean?\r\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\r\n\t\t\t//\t\tbeen fulfilled and consequently cannot be rejected.\r\n\t\t\t// returns: dojo/promise/Promise\r\n\t\t\t//\t\tReturns the original promise for the deferred.\r\n\r\n\t\t\tif(!fulfilled){\r\n\t\t\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\r\n\t\t\t\t\tError.captureStackTrace(rejection = {}, reject);\r\n\t\t\t\t}\r\n\t\t\t\tsignalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);\r\n\t\t\t\twaiting = null;\r\n\t\t\t\treturn promise;\r\n\t\t\t}else if(strict === true){\r\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\r\n\t\t\t}else{\r\n\t\t\t\treturn promise;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.then = promise.then = function(callback, errback, progback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdd new callbacks to the deferred.\r\n\t\t\t// description:\r\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\r\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\r\n\t\t\t// callback: Function?\r\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\r\n\t\t\t//\t\tReceives the resolution value.\r\n\t\t\t// errback: Function?\r\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\r\n\t\t\t//\t\tReceives the rejection error.\r\n\t\t\t// progback: Function?\r\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\r\n\t\t\t//\t\tupdate. Receives the progress update.\r\n\t\t\t// returns: dojo/promise/Promise\r\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\r\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\r\n\r\n\t\t\tvar listener = [progback, callback, errback];\r\n\t\t\t// Ensure we cancel the promise we're waiting for, or if callback/errback\r\n\t\t\t// have returned a promise, cancel that one.\r\n\t\t\tlistener.cancel = promise.cancel;\r\n\t\t\tlistener.deferred = new Deferred(function(reason){\r\n\t\t\t\t// Check whether cancel is really available, returned promises are not\r\n\t\t\t\t// required to expose `cancel`\r\n\t\t\t\treturn listener.cancel && listener.cancel(reason);\r\n\t\t\t});\r\n\t\t\tif(fulfilled && !waiting){\r\n\t\t\t\tsignalListener(listener, fulfilled, result, rejection);\r\n\t\t\t}else{\r\n\t\t\t\twaiting.push(listener);\r\n\t\t\t}\r\n\t\t\treturn listener.deferred.promise;\r\n\t\t};\r\n\r\n\t\tthis.cancel = promise.cancel = function(reason, strict){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\r\n\t\t\t// description:\r\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\r\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\r\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\r\n\t\t\t//\t\tpromises that originate with the same deferred.\r\n\t\t\t// reason: any\r\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\r\n\t\t\t//\t\texplaining why it's being canceled.\r\n\t\t\t// strict: Boolean?\r\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\r\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\r\n\t\t\t// returns: any\r\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\r\n\t\t\t//\t\tnormally.\r\n\r\n\t\t\tif(!fulfilled){\r\n\t\t\t\t// Cancel can be called even after the deferred is fulfilled\r\n\t\t\t\tif(canceler){\r\n\t\t\t\t\tvar returnedReason = canceler(reason);\r\n\t\t\t\t\treason = typeof returnedReason === \"undefined\" ? reason : returnedReason;\r\n\t\t\t\t}\r\n\t\t\t\tcanceled = true;\r\n\t\t\t\tif(!fulfilled){\r\n\t\t\t\t\t// Allow canceler to provide its own reason, but fall back to a CancelError\r\n\t\t\t\t\tif(typeof reason === \"undefined\"){\r\n\t\t\t\t\t\treason = new CancelError();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treject(reason);\r\n\t\t\t\t\treturn reason;\r\n\t\t\t\t}else if(fulfilled === REJECTED && result === reason){\r\n\t\t\t\t\treturn reason;\r\n\t\t\t\t}\r\n\t\t\t}else if(strict === true){\r\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfreezeObject(promise);\r\n\t};\r\n\r\n\tDeferred.prototype.toString = function(){\r\n\t\t// returns: String\r\n\t\t//\t\tReturns `[object Deferred]`.\r\n\r\n\t\treturn \"[object Deferred]\";\r\n\t};\r\n\r\n\tif(instrumentation){\r\n\t\tinstrumentation(Deferred);\r\n\t}\r\n\r\n\treturn Deferred;\r\n});\r\n"]}