{"version":3,"sources":["dom-geometry.js"],"names":["define","has","win","dom","style","geom","boxModel","document","compatMode","getPadExtents","node","computedStyle","byId","s","getComputedStyle","px","toPixelValue","l","paddingLeft","t","paddingTop","r","paddingRight","b","paddingBottom","w","h","none","setBox","u","isNaN","left","top","width","height","isButtonTag","tagName","toLowerCase","getAttribute","usesBorderBox","getBorderExtents","borderLeftStyle","borderLeftWidth","borderTopStyle","borderTopWidth","borderRightStyle","borderRightWidth","borderBottomStyle","borderBottomWidth","getPadBorderExtents","p","getMarginExtents","marginLeft","marginTop","marginRight","marginBottom","getMarginBox","pcs","me","offsetLeft","offsetTop","parentNode","sl","parseFloat","st","overflow","offsetWidth","offsetHeight","getContentBox","clientWidth","pe","be","clientHeight","setContentSize","box","pb","NaN","nilExtents","setMarginBox","mb","ns","Math","max","isBodyLtr","doc","body","dir","documentElement","docScroll","parentWindow","defaultView","x","pageXOffset","y","pageYOffset","fixIeBiDiScrollLeft","scrollLeft","scrollTop","getIeDocumentElementOffset","de","getBoundingClientRect","clientLeft","clientTop","ie","qk","pwin","global","frameElement","scrollHeight","scrollWidth","position","includeScroll","db","ownerDocument","ret","right","bottom","offset","scroll","getMarginSize","size","normalizeEvent","event","layerX","offsetX","layerY","offsetY","se","target","docBody","pageX","clientX","pageY","clientY"],"mappings":"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","file":"../dom-geometry.js","sourcesContent":["define([\"./sniff\", \"./_base/window\",\"./dom\", \"./dom-style\"],\r\n\t\tfunction(has, win, dom, style){\r\n\t// module:\r\n\t//\t\tdojo/dom-geometry\r\n\r\n\t// the result object\r\n\tvar geom = {\r\n\t\t// summary:\r\n\t\t//\t\tThis module defines the core dojo DOM geometry API.\r\n\t};\r\n\r\n\t// Box functions will assume this model.\r\n\t// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.\r\n\t// Can be set to change behavior of box setters.\r\n\r\n\t// can be either:\r\n\t//\t\"border-box\"\r\n\t//\t\"content-box\" (default)\r\n\tgeom.boxModel = \"content-box\";\r\n\r\n\t// We punt per-node box mode testing completely.\r\n\t// If anybody cares, we can provide an additional (optional) unit\r\n\t// that overrides existing code to include per-node box sensitivity.\r\n\r\n\t// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.\r\n\t// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.\r\n\t// IIRC, earlier versions of Opera did in fact use border-box.\r\n\t// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.\r\n\r\n\tif(has(\"ie\") /*|| has(\"opera\")*/){\r\n\t\t// client code may have to adjust if compatMode varies across iframes\r\n\t\tgeom.boxModel = document.compatMode == \"BackCompat\" ? \"border-box\" : \"content-box\";\r\n\t}\r\n\r\n\tgeom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\tReturns object with special values specifically useful for node\r\n\t\t//\t\tfitting.\r\n\t\t// description:\r\n\t\t//\t\tReturns an object with `w`, `h`, `l`, `t` properties:\r\n\t\t//\t|\t\tl/t/r/b = left/top/right/bottom padding (respectively)\r\n\t\t//\t|\t\tw = the total of the left and right padding\r\n\t\t//\t|\t\th = the total of the top and bottom padding\r\n\t\t//\t\tIf 'node' has position, l/t forms the origin for child nodes.\r\n\t\t//\t\tThe w/h are used for calculating boxes.\r\n\t\t//\t\tNormally application code will not need to invoke this\r\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\r\n\t\t\tl = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);\r\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\r\n\t};\r\n\r\n\tvar none = \"none\";\r\n\r\n\tgeom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\treturns an object with properties useful for noting the border\r\n\t\t//\t\tdimensions.\r\n\t\t// description:\r\n\t\t//\t\t- l/t/r/b = the sum of left/top/right/bottom border (respectively)\r\n\t\t//\t\t- w = the sum of the left and right border\r\n\t\t//\t\t- h = the sum of the top and bottom border\r\n\t\t//\r\n\t\t//\t\tThe w/h are used for calculating boxes.\r\n\t\t//\t\tNormally application code will not need to invoke this\r\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),\r\n\t\t\tl = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,\r\n\t\t\tt = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,\r\n\t\t\tr = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,\r\n\t\t\tb = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;\r\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\r\n\t};\r\n\r\n\tgeom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\tReturns object with properties useful for box fitting with\r\n\t\t//\t\tregards to padding.\r\n\t\t// description:\r\n\t\t//\t\t- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)\r\n\t\t//\t\t- w = the sum of the left and right padding and border\r\n\t\t//\t\t- h = the sum of the top and bottom padding and border\r\n\t\t//\r\n\t\t//\t\tThe w/h are used for calculating boxes.\r\n\t\t//\t\tNormally application code will not need to invoke this\r\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node),\r\n\t\t\tp = geom.getPadExtents(node, s),\r\n\t\t\tb = geom.getBorderExtents(node, s);\r\n\t\treturn {\r\n\t\t\tl: p.l + b.l,\r\n\t\t\tt: p.t + b.t,\r\n\t\t\tr: p.r + b.r,\r\n\t\t\tb: p.b + b.b,\r\n\t\t\tw: p.w + b.w,\r\n\t\t\th: p.h + b.h\r\n\t\t};\r\n\t};\r\n\r\n\tgeom.getMarginExtents = function getMarginExtents(node, computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\treturns object with properties useful for box fitting with\r\n\t\t//\t\tregards to box margins (i.e., the outer-box).\r\n\t\t//\r\n\t\t//\t\t- l/t = marginLeft, marginTop, respectively\r\n\t\t//\t\t- w = total width, margin inclusive\r\n\t\t//\t\t- h = total height, margin inclusive\r\n\t\t//\r\n\t\t//\t\tThe w/h are used for calculating boxes.\r\n\t\t//\t\tNormally application code will not need to invoke this\r\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\r\n\t\t\tl = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);\r\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\r\n\t};\r\n\r\n\t// Box getters work in any box context because offsetWidth/clientWidth\r\n\t// are invariant wrt box context\r\n\t//\r\n\t// They do *not* work for display: inline objects that have padding styles\r\n\t// because the user agent ignores padding (it's bogus styling in any case)\r\n\t//\r\n\t// Be careful with IMGs because they are inline or block depending on\r\n\t// browser and browser mode.\r\n\r\n\t// Although it would be easier to read, there are not separate versions of\r\n\t// _getMarginBox for each browser because:\r\n\t// 1. the branching is not expensive\r\n\t// 2. factoring the shared code wastes cycles (function call overhead)\r\n\t// 3. duplicating the shared code wastes bytes\r\n\r\n\tgeom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\treturns an object that encodes the width, height, left and top\r\n\t\t//\t\tpositions of the node's margin box.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),\r\n\t\t\tl = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;\r\n\t\tif(has(\"mozilla\")){\r\n\t\t\t// Mozilla:\r\n\t\t\t// If offsetParent has a computed overflow != visible, the offsetLeft is decreased\r\n\t\t\t// by the parent's border.\r\n\t\t\t// We don't want to compute the parent's style, so instead we examine node's\r\n\t\t\t// computed left/top which is more stable.\r\n\t\t\tvar sl = parseFloat(s.left), st = parseFloat(s.top);\r\n\t\t\tif(!isNaN(sl) && !isNaN(st)){\r\n\t\t\t\tl = sl;\r\n\t\t\t\tt = st;\r\n\t\t\t}else{\r\n\t\t\t\t// If child's computed left/top are not parseable as a number (e.g. \"auto\"), we\r\n\t\t\t\t// have no choice but to examine the parent's computed style.\r\n\t\t\t\tif(p && p.style){\r\n\t\t\t\t\tpcs = style.getComputedStyle(p);\r\n\t\t\t\t\tif(pcs.overflow != \"visible\"){\r\n\t\t\t\t\t\tl += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\r\n\t\t\t\t\t\tt += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else if(has(\"opera\") || (has(\"ie\") == 8 && !has(\"quirks\"))){\r\n\t\t\t// On Opera and IE 8, offsetLeft/Top includes the parent's border\r\n\t\t\tif(p){\r\n\t\t\t\tpcs = style.getComputedStyle(p);\r\n\t\t\t\tl -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\r\n\t\t\t\tt -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};\r\n\t};\r\n\r\n\tgeom.getContentBox = function getContentBox(node, computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\tReturns an object that encodes the width, height, left and top\r\n\t\t//\t\tpositions of the node's content box, irrespective of the\r\n\t\t//\t\tcurrent box model.\r\n\t\t// node: DOMNode\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\t// clientWidth/Height are important since the automatically account for scrollbars\r\n\t\t// fallback to offsetWidth/Height for special cases (see #3378)\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,\r\n\t\t\tpe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);\r\n\t\tif(!w){\r\n\t\t\tw = node.offsetWidth;\r\n\t\t\th = node.offsetHeight;\r\n\t\t}else{\r\n\t\t\th = node.clientHeight;\r\n\t\t\tbe.w = be.h = 0;\r\n\t\t}\r\n\t\t// On Opera, offsetLeft includes the parent's border\r\n\t\tif(has(\"opera\")){\r\n\t\t\tpe.l += be.l;\r\n\t\t\tpe.t += be.t;\r\n\t\t}\r\n\t\treturn {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};\r\n\t};\r\n\r\n\t// Box setters depend on box context because interpretation of width/height styles\r\n\t// vary wrt box context.\r\n\t//\r\n\t// The value of boxModel is used to determine box context.\r\n\t// boxModel can be set directly to change behavior.\r\n\t//\r\n\t// Beware of display: inline objects that have padding styles\r\n\t// because the user agent ignores padding (it's a bogus setup anyway)\r\n\t//\r\n\t// Be careful with IMGs because they are inline or block depending on\r\n\t// browser and browser mode.\r\n\t//\r\n\t// Elements other than DIV may have special quirks, like built-in\r\n\t// margins or padding, or values not detectable via computedStyle.\r\n\t// In particular, margins on TABLE do not seems to appear\r\n\t// at all in computedStyle on Mozilla.\r\n\r\n\tfunction setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){\r\n\t\t// summary:\r\n\t\t//\t\tsets width/height/left/top in the current (native) box-model\r\n\t\t//\t\tdimensions. Uses the unit passed in u.\r\n\t\t// node:\r\n\t\t//\t\tDOM Node reference. Id string not supported for performance\r\n\t\t//\t\treasons.\r\n\t\t// l:\r\n\t\t//\t\tleft offset from parent.\r\n\t\t// t:\r\n\t\t//\t\ttop offset from parent.\r\n\t\t// w:\r\n\t\t//\t\twidth in current box model.\r\n\t\t// h:\r\n\t\t//\t\twidth in current box model.\r\n\t\t// u:\r\n\t\t//\t\tunit measure to use for other measures. Defaults to \"px\".\r\n\t\tu = u || \"px\";\r\n\t\tvar s = node.style;\r\n\t\tif(!isNaN(l)){\r\n\t\t\ts.left = l + u;\r\n\t\t}\r\n\t\tif(!isNaN(t)){\r\n\t\t\ts.top = t + u;\r\n\t\t}\r\n\t\tif(w >= 0){\r\n\t\t\ts.width = w + u;\r\n\t\t}\r\n\t\tif(h >= 0){\r\n\t\t\ts.height = h + u;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isButtonTag(/*DomNode*/ node){\r\n\t\t// summary:\r\n\t\t//\t\tTrue if the node is BUTTON or INPUT.type=\"button\".\r\n\t\treturn node.tagName.toLowerCase() == \"button\" ||\r\n\t\t\tnode.tagName.toLowerCase() == \"input\" && (node.getAttribute(\"type\") || \"\").toLowerCase() == \"button\"; // boolean\r\n\t}\r\n\r\n\tfunction usesBorderBox(/*DomNode*/ node){\r\n\t\t// summary:\r\n\t\t//\t\tTrue if the node uses border-box layout.\r\n\r\n\t\t// We could test the computed style of node to see if a particular box\r\n\t\t// has been specified, but there are details and we choose not to bother.\r\n\r\n\t\t// TABLE and BUTTON (and INPUT type=button) are always border-box by default.\r\n\t\t// If you have assigned a different box to either one via CSS then\r\n\t\t// box functions will break.\r\n\r\n\t\treturn geom.boxModel == \"border-box\" || node.tagName.toLowerCase() == \"table\" || isButtonTag(node); // boolean\r\n\t}\r\n\r\n\tgeom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\tSets the size of the node's contents, irrespective of margins,\r\n\t\t//\t\tpadding, or borders.\r\n\t\t// node: DOMNode\r\n\t\t// box: Object\r\n\t\t//\t\thash with optional \"w\", and \"h\" properties for \"width\", and \"height\"\r\n\t\t//\t\trespectively. All specified properties should have numeric values in whole pixels.\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar w = box.w, h = box.h;\r\n\t\tif(usesBorderBox(node)){\r\n\t\t\tvar pb = geom.getPadBorderExtents(node, computedStyle);\r\n\t\t\tif(w >= 0){\r\n\t\t\t\tw += pb.w;\r\n\t\t\t}\r\n\t\t\tif(h >= 0){\r\n\t\t\t\th += pb.h;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetBox(node, NaN, NaN, w, h);\r\n\t};\r\n\r\n\tvar nilExtents = {l: 0, t: 0, w: 0, h: 0};\r\n\r\n\tgeom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\tsets the size of the node's margin box and placement\r\n\t\t//\t\t(left/top), irrespective of box model. Think of it as a\r\n\t\t//\t\tpassthrough to setBox that handles box-model vagaries for\r\n\t\t//\t\tyou.\r\n\t\t// node: DOMNode\r\n\t\t// box: Object\r\n\t\t//\t\thash with optional \"l\", \"t\", \"w\", and \"h\" properties for \"left\", \"right\", \"width\", and \"height\"\r\n\t\t//\t\trespectively. All specified properties should have numeric values in whole pixels.\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,\r\n\t\t// Some elements have special padding, margin, and box-model settings.\r\n\t\t// To use box functions you may need to set padding, margin explicitly.\r\n\t\t// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.\r\n\t\t\tpb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),\r\n\t\t\tmb = geom.getMarginExtents(node, s);\r\n\t\tif(has(\"webkit\")){\r\n\t\t\t// on Safari (3.1.2), button nodes with no explicit size have a default margin\r\n\t\t\t// setting an explicit size eliminates the margin.\r\n\t\t\t// We have to swizzle the width to get correct margin reading.\r\n\t\t\tif(isButtonTag(node)){\r\n\t\t\t\tvar ns = node.style;\r\n\t\t\t\tif(w >= 0 && !ns.width){\r\n\t\t\t\t\tns.width = \"4px\";\r\n\t\t\t\t}\r\n\t\t\t\tif(h >= 0 && !ns.height){\r\n\t\t\t\t\tns.height = \"4px\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(w >= 0){\r\n\t\t\tw = Math.max(w - pb.w - mb.w, 0);\r\n\t\t}\r\n\t\tif(h >= 0){\r\n\t\t\th = Math.max(h - pb.h - mb.h, 0);\r\n\t\t}\r\n\t\tsetBox(node, box.l, box.t, w, h);\r\n\t};\r\n\r\n\t// =============================\r\n\t// Positioning\r\n\t// =============================\r\n\r\n\tgeom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){\r\n\t\t// summary:\r\n\t\t//\t\tReturns true if the current language is left-to-right, and false otherwise.\r\n\t\t// doc: Document?\r\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\r\n\t\t// returns: Boolean\r\n\r\n\t\tdoc = doc || win.doc;\r\n\t\treturn (win.body(doc).dir || doc.documentElement.dir || \"ltr\").toLowerCase() == \"ltr\"; // Boolean\r\n\t};\r\n\r\n\tgeom.docScroll = function docScroll(/*Document?*/ doc){\r\n\t\t// summary:\r\n\t\t//\t\tReturns an object with {node, x, y} with corresponding offsets.\r\n\t\t// doc: Document?\r\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\r\n\t\t// returns: Object\r\n\r\n\t\tdoc = doc || win.doc;\r\n\t\tvar node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem\r\n\t\treturn \"pageXOffset\" in node ? {x: node.pageXOffset, y: node.pageYOffset } :\r\n\t\t\t(node = has(\"quirks\") ? win.body(doc) : doc.documentElement) &&\r\n\t\t\t\t{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };\r\n\t};\r\n\r\n\tif(has(\"ie\")){\r\n\t\tgeom.getIeDocumentElementOffset = function getIeDocumentElementOffset(/*Document?*/ doc){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the offset in x and y from the document body to the\r\n\t\t\t//\t\tvisual edge of the page for IE\r\n\t\t\t// doc: Document?\r\n\t\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe following values in IE contain an offset:\r\n\t\t\t//\t|\t\tevent.clientX\r\n\t\t\t//\t|\t\tevent.clientY\r\n\t\t\t//\t|\t\tnode.getBoundingClientRect().left\r\n\t\t\t//\t|\t\tnode.getBoundingClientRect().top\r\n\t\t\t//\t\tBut other position related values do not contain this offset,\r\n\t\t\t//\t\tsuch as node.offsetLeft, node.offsetTop, node.style.left and\r\n\t\t\t//\t\tnode.style.top. The offset is always (2, 2) in LTR direction.\r\n\t\t\t//\t\tWhen the body is in RTL direction, the offset counts the width\r\n\t\t\t//\t\tof left scroll bar's width.  This function computes the actual\r\n\t\t\t//\t\toffset.\r\n\r\n\t\t\t//NOTE: assumes we're being called in an IE browser\r\n\r\n\t\t\tdoc = doc || win.doc;\r\n\t\t\tvar de = doc.documentElement; // only deal with HTML element here, position() handles body/quirks\r\n\r\n\t\t\tif(has(\"ie\") < 8){\r\n\t\t\t\tvar r = de.getBoundingClientRect(), // works well for IE6+\r\n\t\t\t\t\tl = r.left, t = r.top;\r\n\t\t\t\tif(has(\"ie\") < 7){\r\n\t\t\t\t\tl += de.clientLeft;\t// scrollbar size in strict/RTL, or,\r\n\t\t\t\t\tt += de.clientTop;\t// HTML border size in strict\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: l < 0 ? 0 : l, // FRAME element border size can lead to inaccurate negative values\r\n\t\t\t\t\ty: t < 0 ? 0 : t\r\n\t\t\t\t};\r\n\t\t\t}else{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: 0,\r\n\t\t\t\t\ty: 0\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tgeom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){\r\n\t\t// summary:\r\n\t\t//\t\tIn RTL direction, scrollLeft should be a negative value, but IE\r\n\t\t//\t\treturns a positive one. All codes using documentElement.scrollLeft\r\n\t\t//\t\tmust call this function to fix this error, otherwise the position\r\n\t\t//\t\twill offset to right when there is a horizontal scrollbar.\r\n\t\t// scrollLeft: Number\r\n\t\t// doc: Document?\r\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\r\n\t\t// returns: Number\r\n\r\n\t\t// In RTL direction, scrollLeft should be a negative value, but IE\r\n\t\t// returns a positive one. All codes using documentElement.scrollLeft\r\n\t\t// must call this function to fix this error, otherwise the position\r\n\t\t// will offset to right when there is a horizontal scrollbar.\r\n\r\n\t\tdoc = doc || win.doc;\r\n\t\tvar ie = has(\"ie\");\r\n\t\tif(ie && !geom.isBodyLtr(doc)){\r\n\t\t\tvar qk = has(\"quirks\"),\r\n\t\t\t\tde = qk ? win.body(doc) : doc.documentElement,\r\n\t\t\t\tpwin = win.global;\t// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js\r\n\t\t\tif(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){\r\n\t\t\t\tscrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels\r\n\t\t\t}\r\n\t\t\treturn (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer\r\n\t\t}\r\n\t\treturn scrollLeft; // Integer\r\n\t};\r\n\r\n\tgeom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){\r\n\t\t// summary:\r\n\t\t//\t\tGets the position and size of the passed element relative to\r\n\t\t//\t\tthe viewport (if includeScroll==false), or relative to the\r\n\t\t//\t\tdocument root (if includeScroll==true).\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tReturns an object of the form:\r\n\t\t//\t\t`{ x: 100, y: 300, w: 20, h: 15 }`.\r\n\t\t//\t\tIf includeScroll==true, the x and y values will include any\r\n\t\t//\t\tdocument offsets that may affect the position relative to the\r\n\t\t//\t\tviewport.\r\n\t\t//\t\tUses the border-box model (inclusive of border and padding but\r\n\t\t//\t\tnot margin).  Does not act as a setter.\r\n\t\t// node: DOMNode|String\r\n\t\t// includeScroll: Boolean?\r\n\t\t// returns: Object\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar\tdb = win.body(node.ownerDocument),\r\n\t\t\tret = node.getBoundingClientRect();\r\n\t\tret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};\r\n\r\n\t\tif(has(\"ie\") < 9){\r\n\t\t\t// On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()\r\n\t\t\tvar offset = geom.getIeDocumentElementOffset(node.ownerDocument);\r\n\r\n\t\t\t// fixes the position in IE, quirks mode\r\n\t\t\tret.x -= offset.x + (has(\"quirks\") ? db.clientLeft + db.offsetLeft : 0);\r\n\t\t\tret.y -= offset.y + (has(\"quirks\") ? db.clientTop + db.offsetTop : 0);\r\n\t\t}\r\n\r\n\t\t// account for document scrolling\r\n\t\t// if offsetParent is used, ret value already includes scroll position\r\n\t\t// so we may have to actually remove that value if !includeScroll\r\n\t\tif(includeScroll){\r\n\t\t\tvar scroll = geom.docScroll(node.ownerDocument);\r\n\t\t\tret.x += scroll.x;\r\n\t\t\tret.y += scroll.y;\r\n\t\t}\r\n\r\n\t\treturn ret; // Object\r\n\t};\r\n\r\n\t// random \"private\" functions wildly used throughout the toolkit\r\n\r\n\tgeom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){\r\n\t\t// summary:\r\n\t\t//\t\treturns an object that encodes the width and height of\r\n\t\t//\t\tthe node's margin box\r\n\t\t// node: DOMNode|String\r\n\t\t// computedStyle: Object?\r\n\t\t//\t\tThis parameter accepts computed styles object.\r\n\t\t//\t\tIf this parameter is omitted, the functions will call\r\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\r\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\r\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\r\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\r\n\r\n\t\tnode = dom.byId(node);\r\n\t\tvar me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));\r\n\t\tvar size = node.getBoundingClientRect();\r\n\t\treturn {\r\n\t\t\tw: (size.right - size.left) + me.w,\r\n\t\t\th: (size.bottom - size.top) + me.h\r\n\t\t};\r\n\t};\r\n\r\n\tgeom.normalizeEvent = function(event){\r\n\t\t// summary:\r\n\t\t//\t\tNormalizes the geometry of a DOM event, normalizing the pageX, pageY,\r\n\t\t//\t\toffsetX, offsetY, layerX, and layerX properties\r\n\t\t// event: Object\r\n\t\tif(!(\"layerX\" in event)){\r\n\t\t\tevent.layerX = event.offsetX;\r\n\t\t\tevent.layerY = event.offsetY;\r\n\t\t}\r\n\t\tif(!has(\"dom-addeventlistener\")){\r\n\t\t\t// old IE version\r\n\t\t\t// FIXME: scroll position query is duped from dojo/_base/html to\r\n\t\t\t// avoid dependency on that entire module. Now that HTML is in\r\n\t\t\t// Base, we should convert back to something similar there.\r\n\t\t\tvar se = event.target;\r\n\t\t\tvar doc = (se && se.ownerDocument) || document;\r\n\t\t\t// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used\r\n\t\t\t// here rather than document.body\r\n\t\t\tvar docBody = has(\"quirks\") ? doc.body : doc.documentElement;\r\n\t\t\tvar offset = geom.getIeDocumentElementOffset(doc);\r\n\t\t\tevent.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;\r\n\t\t\tevent.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;\r\n\t\t}\r\n\t};\r\n\r\n\t// TODO: evaluate separate getters/setters for position and sizes?\r\n\r\n\treturn geom;\r\n});\r\n"]}