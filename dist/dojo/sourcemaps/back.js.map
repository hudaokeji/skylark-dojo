{"version":3,"sources":["back.js"],"names":["define","config","lang","has","dom","domConstruct","baseWindow","require","back","setObject","getHash","h","window","location","hash","charAt","substring","decodeURIComponent","setHash","encodeURIComponent","history","length","initialHref","href","initialHash","initialState","locationTimer","bookmarkAnchor","historyIframe","forwardStack","historyStack","moveForward","changingUrl","handleBackButton","current","pop","last","kwArgs","handle","push","handleForwardButton","forward","forwardButton","createState","url","args","urlHash","getUrlQuery","segments","split","loadIframeHistory","toUrl","Date","getTime","frames","name","checkLocation","hsl","goBack","goForward","init","byId","src","afterOnLoad","console","error","document","write","setInitialState","addToHistory","warn","create","style","display","body","setTimeout","oldCB","tcb","handleName","apply","this","backButton","oldFW","tfw","setInterval","_iframeLoaded","evt","ifrLoc","query"],"mappings":"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","file":"../back.js","sourcesContent":["define([\"./_base/config\", \"./_base/lang\", \"./sniff\", \"./dom\", \"./dom-construct\", \"./_base/window\", \"require\"],\r\n\tfunction(config, lang, has, dom, domConstruct, baseWindow, require){\r\n\t// module:\r\n\t//\t\tdojo/back\r\n\r\n\tvar back = {\r\n\t\t// summary:\r\n\t\t//\t\tBrowser history management resources\r\n\t};\r\n\thas(\"extend-dojo\") && lang.setObject(\"dojo.back\", back);\r\n\r\n\t// everyone deals with encoding the hash slightly differently\r\n\r\n\tvar getHash = back.getHash = function(){\r\n\t\tvar h = window.location.hash;\r\n\t\tif(h.charAt(0) == \"#\"){ h = h.substring(1); }\r\n\t\treturn has(\"mozilla\") ? h : decodeURIComponent(h);\r\n\t},\r\n\r\n\tsetHash = back.setHash = function(h){\r\n\t\tif(!h){ h = \"\"; }\r\n\t\twindow.location.hash = encodeURIComponent(h);\r\n\t\thistoryCounter = history.length;\r\n\t};\r\n\r\n\tvar initialHref = (typeof(window) !== \"undefined\") ? window.location.href : \"\";\r\n\tvar initialHash = (typeof(window) !== \"undefined\") ? getHash() : \"\";\r\n\tvar initialState = null;\r\n\r\n\tvar locationTimer = null;\r\n\tvar bookmarkAnchor = null;\r\n\tvar historyIframe = null;\r\n\tvar forwardStack = [];\r\n\tvar historyStack = [];\r\n\tvar moveForward = false;\r\n\tvar changingUrl = false;\r\n\tvar historyCounter;\r\n\r\n\tfunction handleBackButton(){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\r\n\t\t//The \"current\" page is always at the top of the history stack.\r\n\t\tvar current = historyStack.pop();\r\n\t\tif(!current){ return; }\r\n\t\tvar last = historyStack[historyStack.length-1];\r\n\t\tif(!last && historyStack.length == 0){\r\n\t\t\tlast = initialState;\r\n\t\t}\r\n\t\tif(last){\r\n\t\t\tif(last.kwArgs[\"back\"]){\r\n\t\t\t\tlast.kwArgs[\"back\"]();\r\n\t\t\t}else if(last.kwArgs[\"backButton\"]){\r\n\t\t\t\tlast.kwArgs[\"backButton\"]();\r\n\t\t\t}else if(last.kwArgs[\"handle\"]){\r\n\t\t\t\tlast.kwArgs.handle(\"back\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tforwardStack.push(current);\r\n\t}\r\n\r\n\tback.goBack = handleBackButton;\r\n\r\n\tfunction handleForwardButton(){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\t\tvar last = forwardStack.pop();\r\n\t\tif(!last){ return; }\r\n\t\tif(last.kwArgs[\"forward\"]){\r\n\t\t\tlast.kwArgs.forward();\r\n\t\t}else if(last.kwArgs[\"forwardButton\"]){\r\n\t\t\tlast.kwArgs.forwardButton();\r\n\t\t}else if(last.kwArgs[\"handle\"]){\r\n\t\t\tlast.kwArgs.handle(\"forward\");\r\n\t\t}\r\n\t\thistoryStack.push(last);\r\n\t}\r\n\r\n\tback.goForward = handleForwardButton;\r\n\r\n\tfunction createState(url, args, hash){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\t\treturn {\"url\": url, \"kwArgs\": args, \"urlHash\": hash};\t//Object\r\n\t}\r\n\r\n\tfunction getUrlQuery(url){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\t\tvar segments = url.split(\"?\");\r\n\t\tif(segments.length < 2){\r\n\t\t\treturn null; //null\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn segments[1]; //String\r\n\t\t}\r\n\t}\r\n\r\n\tfunction loadIframeHistory(){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\t\tvar url = (config[\"dojoIframeHistoryUrl\"] || require.toUrl(\"./resources/iframe_history.html\")) + \"?\" + (new Date()).getTime();\r\n\t\tmoveForward = true;\r\n\t\tif(historyIframe){\r\n\t\t\thas(\"webkit\") ? historyIframe.location = url : window.frames[historyIframe.name].location = url;\r\n\t\t}else{\r\n\t\t\t//console.warn(\"dojo/back: Not initialised. You need to call back.init() from a <script> block that lives inside the <body> tag.\");\r\n\t\t}\r\n\t\treturn url; //String\r\n\t}\r\n\r\n\tfunction checkLocation(){\r\n\t\tif(!changingUrl){\r\n\t\t\tvar hsl = historyStack.length;\r\n\r\n\t\t\tvar hash = getHash();\r\n\r\n\t\t\tif((hash === initialHash||window.location.href == initialHref)&&(hsl == 1)){\r\n\t\t\t\t// FIXME: could this ever be a forward button?\r\n\t\t\t\t// we can't clear it because we still need to check for forwards. Ugg.\r\n\t\t\t\t// clearInterval(this.locationTimer);\r\n\t\t\t\thandleBackButton();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// first check to see if we could have gone forward. We always halt on\r\n\t\t\t// a no-hash item.\r\n\t\t\tif(forwardStack.length > 0){\r\n\t\t\t\tif(forwardStack[forwardStack.length-1].urlHash === hash){\r\n\t\t\t\t\thandleForwardButton();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// ok, that didn't work, try someplace back in the history stack\r\n\t\t\tif((hsl >= 2)&&(historyStack[hsl-2])){\r\n\t\t\t\tif(historyStack[hsl-2].urlHash === hash){\r\n\t\t\t\t\thandleBackButton();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tback.init = function(){\r\n\t\t// summary:\r\n\t\t//\t\tInitializes the undo stack. This must be called from a <script>\r\n\t\t//\t\tblock that lives inside the `<body>` tag to prevent bugs on IE.\r\n\t\t//\r\n\t\t//\t\tOnly call this method before the page's DOM is finished loading. Otherwise\r\n\t\t//\t\tit will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,\r\n\t\t//\t\tin order for this method to work, dojo/back will need to be part of a build layer.\r\n\r\n\t\t// prevent reinit\r\n\t\tif(dom.byId(\"dj_history\")){ return; } \r\n\r\n\t\tvar src = config[\"dojoIframeHistoryUrl\"] || require.toUrl(\"./resources/iframe_history.html\");\r\n\t\tif (config.afterOnLoad){\r\n\t\t\tconsole.error(\"dojo/back::init() must be called before the DOM has loaded. \"\r\n\t\t\t\t\t\t+ \"Include dojo/back in a build layer.\");\r\n\t\t}else{\r\n\t\t\tdocument.write('<iframe style=\"border:0;width:1px;height:1px;position:absolute;visibility:hidden;bottom:0;right:0;\" name=\"dj_history\" id=\"dj_history\" src=\"' + src + '\"></iframe>');\r\n\t\t}\r\n\t};\r\n\r\n\tback.setInitialState = function(/*Object*/args){\r\n\t\t// summary:\r\n\t\t//\t\tSets the state object and back callback for the very first page\r\n\t\t//\t\tthat is loaded.\r\n\t\t//\r\n\t\t//\t\tIt is recommended that you call this method as part of an event\r\n\t\t//\t\tlistener that is registered via dojo/ready.\r\n\t\t// args: Object\r\n\t\t//\t\tSee the addToHistory() function for the list of valid args properties.\r\n\t\tinitialState = createState(initialHref, args, initialHash);\r\n\t};\r\n\r\n\t//FIXME: Make these doc comments not be awful. At least they're not wrong.\r\n\t//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.\r\n\t//FIXME: is there a slight race condition in moz using change URL with the timer check and when\r\n\t//\t\t the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.\r\n\r\n\r\n\t/*=====\r\n\tvar __backArgs = {\r\n\t\t// back: Function?\r\n\t\t//\t\tA function to be called when this state is reached via the user\r\n\t\t//\t\tclicking the back button.\r\n\t\t// forward: Function?\r\n\t\t//\t\tUpon return to this state from the \"back, forward\" combination\r\n\t\t//\t\tof navigation steps, this function will be called. Somewhat\r\n\t\t//\t\tanalogous to the semantic of an \"onRedo\" event handler.\r\n\t\t// changeUrl: Boolean|String?\r\n\t\t//\t\tBoolean indicating whether or not to create a unique hash for\r\n\t\t//\t\tthis state. If a string is passed instead, it is used as the\r\n\t\t//\t\thash.\r\n\t};\r\n\t=====*/\r\n\r\n\tback.addToHistory = function(args){\r\n\t\t// summary:\r\n\t\t//\t\tadds a state object (args) to the history list.\r\n\t\t// args: __backArgs\r\n\t\t//\t\tThe state object that will be added to the history list.\r\n\t\t// description:\r\n\t\t//\t\tTo support getting back button notifications, the object\r\n\t\t//\t\targument should implement a function called either \"back\",\r\n\t\t//\t\t\"backButton\", or \"handle\". The string \"back\" will be passed as\r\n\t\t//\t\tthe first and only argument to this callback.\r\n\t\t//\r\n\t\t//\t\tTo support getting forward button notifications, the object\r\n\t\t//\t\targument should implement a function called either \"forward\",\r\n\t\t//\t\t\"forwardButton\", or \"handle\". The string \"forward\" will be\r\n\t\t//\t\tpassed as the first and only argument to this callback.\r\n\t\t//\r\n\t\t//\t\tIf you want the browser location string to change, define \"changeUrl\" on the object. If the\r\n\t\t//\t\tvalue of \"changeUrl\" is true, then a unique number will be appended to the URL as a fragment\r\n\t\t//\t\tidentifier (http://some.domain.com/path#uniquenumber). If it is any other value that does\r\n\t\t//\t\tnot evaluate to false, that value will be used as the fragment identifier. For example,\r\n\t\t//\t\tif changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1\r\n\t\t//\r\n\t\t//\t\tThere are problems with using dojo/back with semantically-named fragment identifiers\r\n\t\t//\t\t(\"hash values\" on an URL). In most browsers it will be hard for dojo/back to know\r\n\t\t//\t\tdistinguish a back from a forward event in those cases. For back/forward support to\r\n\t\t//\t\twork best, the fragment ID should always be a unique value (something using new Date().getTime()\r\n\t\t//\t\tfor example). If you want to detect hash changes using semantic fragment IDs, then\r\n\t\t//\t\tconsider using dojo/hash instead (in Dojo 1.4+).\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\t|\tback.addToHistory({\r\n\t\t//\t\t|\t\tback: function(){ console.log('back pressed'); },\r\n\t\t//\t\t|\t\tforward: function(){ console.log('forward pressed'); },\r\n\t\t//\t\t|\t\tchangeUrl: true\r\n\t\t//\t\t|\t});\r\n\r\n\t\t//\tBROWSER NOTES:\r\n\t\t//\tSafari 1.2:\r\n\t\t//\tback button \"works\" fine, however it's not possible to actually\r\n\t\t//\tDETECT that you've moved backwards by inspecting window.location.\r\n\t\t//\tUnless there is some other means of locating.\r\n\t\t//\tFIXME: perhaps we can poll on history.length?\r\n\t\t//\tSafari 2.0.3+ (and probably 1.3.2+):\r\n\t\t//\tworks fine, except when changeUrl is used. When changeUrl is used,\r\n\t\t//\tSafari jumps all the way back to whatever page was shown before\r\n\t\t//\tthe page that uses dojo.undo.browser support.\r\n\t\t//\tIE 5.5 SP2:\r\n\t\t//\tback button behavior is macro. It does not move back to the\r\n\t\t//\tprevious hash value, but to the last full page load. This suggests\r\n\t\t//\tthat the iframe is the correct way to capture the back button in\r\n\t\t//\tthese cases.\r\n\t\t//\tDon't test this page using local disk for MSIE. MSIE will not create\r\n\t\t//\ta history list for iframe_history.html if served from a file: URL.\r\n\t\t//\tThe XML served back from the XHR tests will also not be properly\r\n\t\t//\tcreated if served from local disk. Serve the test pages from a web\r\n\t\t//\tserver to test in that browser.\r\n\t\t//\tIE 6.0:\r\n\t\t//\tsame behavior as IE 5.5 SP2\r\n\t\t//\tFirefox 1.0+:\r\n\t\t//\tthe back button will return us to the previous hash on the same\r\n\t\t//\tpage, thereby not requiring an iframe hack, although we do then\r\n\t\t//\tneed to run a timer to detect inter-page movement.\r\n\r\n\t\t//If addToHistory is called, then that means we prune the\r\n\t\t//forward stack -- the user went back, then wanted to\r\n\t\t//start a new forward path.\r\n\t\tforwardStack = [];\r\n\r\n\t\tvar hash = null;\r\n\t\tvar url = null;\r\n\t\tif(!historyIframe){\r\n\t\t\tif(config[\"useXDomain\"] && !config[\"dojoIframeHistoryUrl\"]){\r\n\t\t\t\tconsole.warn(\"dojo/back: When using cross-domain Dojo builds,\"\r\n\t\t\t\t\t+ \" please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl\"\r\n\t\t\t\t\t+ \" to the path on your domain to iframe_history.html\");\r\n\t\t\t}\r\n\t\t\thistoryIframe = window.frames[\"dj_history\"];\r\n\t\t}\r\n\t\tif(!bookmarkAnchor){\r\n\t\t\tbookmarkAnchor = domConstruct.create(\"a\", {style: {display: \"none\"}}, baseWindow.body());\r\n\t\t}\r\n\t\tif(args[\"changeUrl\"]){\r\n\t\t\thash = \"\"+ ((args[\"changeUrl\"]!==true) ? args[\"changeUrl\"] : (new Date()).getTime());\r\n\r\n\t\t\t//If the current hash matches the new one, just replace the history object with\r\n\t\t\t//this new one. It doesn't make sense to track different state objects for the same\r\n\t\t\t//logical URL. This matches the browser behavior of only putting in one history\r\n\t\t\t//item no matter how many times you click on the same #hash link, at least in Firefox\r\n\t\t\t//and Safari, and there is no reliable way in those browsers to know if a #hash link\r\n\t\t\t//has been clicked on multiple times. So making this the standard behavior in all browsers\r\n\t\t\t//so that dojo/back's behavior is the same in all browsers.\r\n\t\t\tif(historyStack.length == 0 && initialState.urlHash == hash){\r\n\t\t\t\tinitialState = createState(url, args, hash);\r\n\t\t\t\treturn;\r\n\t\t\t}else if(historyStack.length > 0 && historyStack[historyStack.length - 1].urlHash == hash){\r\n\t\t\t\thistoryStack[historyStack.length - 1] = createState(url, args, hash);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tchangingUrl = true;\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\t\tsetHash(hash);\r\n\t\t\t\t\tchangingUrl = false;\r\n\t\t\t\t}, 1);\r\n\t\t\tbookmarkAnchor.href = hash;\r\n\r\n\t\t\tif(has(\"ie\")){\r\n\t\t\t\turl = loadIframeHistory();\r\n\r\n\t\t\t\tvar oldCB = args[\"back\"]||args[\"backButton\"]||args[\"handle\"];\r\n\r\n\t\t\t\t//The function takes handleName as a parameter, in case the\r\n\t\t\t\t//callback we are overriding was \"handle\". In that case,\r\n\t\t\t\t//we will need to pass the handle name to handle.\r\n\t\t\t\tvar tcb = function(handleName){\r\n\t\t\t\t\tif(getHash() != \"\"){\r\n\t\t\t\t\t\tsetTimeout(function(){ setHash(hash); }, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Use apply to set \"this\" to args, and to try to avoid memory leaks.\r\n\t\t\t\t\toldCB.apply(this, [handleName]);\r\n\t\t\t\t};\r\n\r\n\t\t\t\t//Set interceptor function in the right place.\r\n\t\t\t\tif(args[\"back\"]){\r\n\t\t\t\t\targs.back = tcb;\r\n\t\t\t\t}else if(args[\"backButton\"]){\r\n\t\t\t\t\targs.backButton = tcb;\r\n\t\t\t\t}else if(args[\"handle\"]){\r\n\t\t\t\t\targs.handle = tcb;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar oldFW = args[\"forward\"]||args[\"forwardButton\"]||args[\"handle\"];\r\n\r\n\t\t\t\t//The function takes handleName as a parameter, in case the\r\n\t\t\t\t//callback we are overriding was \"handle\". In that case,\r\n\t\t\t\t//we will need to pass the handle name to handle.\r\n\t\t\t\tvar tfw = function(handleName){\r\n\t\t\t\t\tif(getHash() != \"\"){\r\n\t\t\t\t\t\tsetHash(hash);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(oldFW){ // we might not actually have one\r\n\t\t\t\t\t\t//Use apply to set \"this\" to args, and to try to avoid memory leaks.\r\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t//Set interceptor function in the right place.\r\n\t\t\t\tif(args[\"forward\"]){\r\n\t\t\t\t\targs.forward = tfw;\r\n\t\t\t\t}else if(args[\"forwardButton\"]){\r\n\t\t\t\t\targs.forwardButton = tfw;\r\n\t\t\t\t}else if(args[\"handle\"]){\r\n\t\t\t\t\targs.handle = tfw;\r\n\t\t\t\t}\r\n\r\n\t\t\t}else if(!has(\"ie\")){\r\n\t\t\t\t// start the timer\r\n\t\t\t\tif(!locationTimer){\r\n\t\t\t\t\tlocationTimer = setInterval(checkLocation, 200);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\turl = loadIframeHistory();\r\n\t\t}\r\n\r\n\t\thistoryStack.push(createState(url, args, hash));\r\n\t};\r\n\r\n\tback._iframeLoaded = function(evt, ifrLoc){\r\n\t\t// summary:\r\n\t\t//\t\tprivate method. Do not call this directly.\r\n\t\tvar query = getUrlQuery(ifrLoc.href);\r\n\t\tif(query == null){\r\n\t\t\t// alert(\"iframeLoaded\");\r\n\t\t\t// we hit the end of the history, so we should go back\r\n\t\t\tif(historyStack.length == 1){\r\n\t\t\t\thandleBackButton();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(moveForward){\r\n\t\t\t// we were expecting it, so it's not either a forward or backward movement\r\n\t\t\tmoveForward = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//Check the back stack first, since it is more likely.\r\n\t\t//Note that only one step back or forward is supported.\r\n\t\tif(historyStack.length >= 2 && query == getUrlQuery(historyStack[historyStack.length-2].url)){\r\n\t\t\thandleBackButton();\r\n\t\t}else if(forwardStack.length > 0 && query == getUrlQuery(forwardStack[forwardStack.length-1].url)){\r\n\t\t\thandleForwardButton();\r\n\t\t}\r\n\t};\r\n\r\n\treturn back;\r\n\t\r\n});\r\n"]}