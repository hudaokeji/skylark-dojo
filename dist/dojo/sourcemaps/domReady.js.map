{"version":3,"sources":["domReady.js"],"names":["define","has","recursiveGuard","global","this","doc","document","readyStates","loaded","complete","fixReadyState","readyState","ready","readyQ","domReady","callback","push","processQ","length","shift","err","console","error","stack","_onQEmpty","load","id","req","_Q","tests","detectReady","evt","event","type","on","node","addEventListener","removeEventListener","attachEvent","detachEvent","div","createElement","doScroll","frameElement","e","poller","i","setTimeout"],"mappings":";;;;;;;AAAAA,QAAQ,SAAU,SAASC,GAC1B,IAMCC,EANGC,EAAS,WAAe,OAAOC,KAAtB,GACZC,EAAMC,SACNC,GAAgBC,OAAU,EAAGC,SAAY,GACzCC,EAAyC,iBAAlBL,EAAIM,WAC3BC,IAAUL,EAAYF,EAAIM,YAC1BE,KAGD,SAASC,EAASC,GAGjBF,EAAOG,KAAKD,GACTH,GAAQK,IAkBZ,SAASA,IAGR,IAAGf,EAAH,CAGA,IAFAA,GAAiB,EAEXW,EAAOK,QACZ,IACEL,EAAOM,OAAR,CAAiBd,GACjB,MAAMe,GACNC,QAAQC,MAAMF,EAAK,uBAAwBA,EAAIG,OAIjDrB,GAAiB,EAIjBY,EAASU,aAGV,GArCAV,EAASW,KAAO,SAASC,EAAIC,EAAKF,GACjCX,EAASW,IAIVX,EAASc,GAAKf,EACdC,EAASU,UAAY,aAQlBd,IAAgBL,EAAIM,WAAa,YAuBhCC,EAAM,CACT,IAAIiB,KACHC,EAAc,SAASC,GACtBA,EAAMA,GAAO5B,EAAO6B,MACjBpB,GAAsB,oBAAZmB,EAAIE,OAA+B1B,EAAYF,EAAIM,cAG7DD,IAAgBL,EAAIM,WAAa,YAEpCC,EAAQ,EACRK,MAEDiB,EAAK,SAASC,EAAMH,GACnBG,EAAKC,iBAAiBJ,EAAOF,GAAa,GAC1CjB,EAAOG,KAAK,WAAYmB,EAAKE,oBAAoBL,EAAOF,GAAa,MAGvE,IAAI7B,EAAI,wBAAwB,CAC/BiC,EAAK,SAASC,EAAMH,GACnBA,EAAQ,KAAOA,EACfG,EAAKG,YAAYN,EAAOF,GACxBjB,EAAOG,KAAK,WAAYmB,EAAKI,YAAYP,EAAOF,MAGjD,IAAIU,EAAMnC,EAAIoC,cAAc,OAC5B,IACID,EAAIE,UAAoC,OAAxBvC,EAAOwC,cAEzBd,EAAMb,KAAK,WAGV,IAEC,OADAwB,EAAIE,SAAS,QACN,EACP,MAAME,OAGT,MAAMA,KAiBR,GAdAV,EAAG7B,EAAK,oBACR6B,EAAG/B,EAAQ,QAER,uBAAwBE,EAC1B6B,EAAG7B,EAAK,oBACCK,GAITmB,EAAMb,KAAK,WACV,OAAOT,EAAYF,EAAIM,cAItBkB,EAAMX,OAAO,CACf,IAAI2B,EAAS,WACZ,IAAGjC,EAAH,CAEA,IADA,IAAIkC,EAAIjB,EAAMX,OACR4B,KACL,GAAGjB,EAAMiB,KAER,YADAhB,EAAY,UAIdiB,WAAWF,EAAQ,MAEpBA,KAIF,OAAO/B","file":"../domReady.js","sourcesContent":["define(['./has'], function(has){\r\n\tvar global = (function () { return this; })(),\r\n\t\tdoc = document,\r\n\t\treadyStates = { 'loaded': 1, 'complete': 1 },\r\n\t\tfixReadyState = typeof doc.readyState != \"string\",\r\n\t\tready = !!readyStates[doc.readyState],\r\n\t\treadyQ = [],\r\n\t\trecursiveGuard;\r\n\r\n\tfunction domReady(callback){\r\n\t\t// summary:\r\n\t\t//\t\tPlugin to delay require()/define() callback from firing until the DOM has finished loading.\r\n\t\treadyQ.push(callback);\r\n\t\tif(ready){ processQ(); }\r\n\t}\r\n\tdomReady.load = function(id, req, load){\r\n\t\tdomReady(load);\r\n\t};\r\n\r\n\t// Export queue so that ready() can check if it's empty or not.\r\n\tdomReady._Q = readyQ;\r\n\tdomReady._onQEmpty = function(){\r\n\t\t// summary:\r\n\t\t//\t\tPrivate method overridden by dojo/ready, to notify when everything in the\r\n\t\t//\t\tdomReady queue has been processed.  Do not use directly.\r\n\t\t//\t\tWill be removed in 2.0, along with domReady._Q.\r\n\t};\r\n\r\n\t// For FF <= 3.5\r\n\tif(fixReadyState){ doc.readyState = \"loading\"; }\r\n\r\n\tfunction processQ(){\r\n\t\t// Calls all functions in the queue in order, unless processQ() is already running, in which case just return\r\n\r\n\t\tif(recursiveGuard){ return; }\r\n\t\trecursiveGuard = true;\r\n\r\n\t\twhile(readyQ.length){\r\n\t\t\ttry{\r\n\t\t\t\t(readyQ.shift())(doc);\r\n\t\t\t}catch(err){\r\n\t\t\t\tconsole.error(err, \"in domReady callback\", err.stack);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trecursiveGuard = false;\r\n\r\n\t\t// Notification for dojo/ready.  Remove for 2.0.\r\n\t\t// Note that this could add more tasks to the ready queue.\r\n\t\tdomReady._onQEmpty();\r\n\t}\r\n\r\n\tif(!ready){\r\n\t\tvar tests = [],\r\n\t\t\tdetectReady = function(evt){\r\n\t\t\t\tevt = evt || global.event;\r\n\t\t\t\tif(ready || (evt.type == \"readystatechange\" && !readyStates[doc.readyState])){ return; }\r\n\r\n\t\t\t\t// For FF <= 3.5\r\n\t\t\t\tif(fixReadyState){ doc.readyState = \"complete\"; }\r\n\r\n\t\t\t\tready = 1;\r\n\t\t\t\tprocessQ();\r\n\t\t\t},\r\n\t\t\ton = function(node, event){\r\n\t\t\t\tnode.addEventListener(event, detectReady, false);\r\n\t\t\t\treadyQ.push(function(){ node.removeEventListener(event, detectReady, false); });\r\n\t\t\t};\r\n\r\n\t\tif(!has(\"dom-addeventlistener\")){\r\n\t\t\ton = function(node, event){\r\n\t\t\t\tevent = \"on\" + event;\r\n\t\t\t\tnode.attachEvent(event, detectReady);\r\n\t\t\t\treadyQ.push(function(){ node.detachEvent(event, detectReady); });\r\n\t\t\t};\r\n\r\n\t\t\tvar div = doc.createElement(\"div\");\r\n\t\t\ttry{\r\n\t\t\t\tif(div.doScroll && global.frameElement === null){\r\n\t\t\t\t\t// the doScroll test is only useful if we're in the top-most frame\r\n\t\t\t\t\ttests.push(function(){\r\n\t\t\t\t\t\t// Derived with permission from Diego Perini's IEContentLoaded\r\n\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tdiv.doScroll(\"left\");\r\n\t\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t\t}catch(e){}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\r\n\t\ton(doc, \"DOMContentLoaded\");\r\n\t\ton(global, \"load\");\r\n\r\n\t\tif(\"onreadystatechange\" in doc){\r\n\t\t\ton(doc, \"readystatechange\");\r\n\t\t}else if(!fixReadyState){\r\n\t\t\t// if the ready state property exists and there's\r\n\t\t\t// no readystatechange event, poll for the state\r\n\t\t\t// to change\r\n\t\t\ttests.push(function(){\r\n\t\t\t\treturn readyStates[doc.readyState];\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(tests.length){\r\n\t\t\tvar poller = function(){\r\n\t\t\t\tif(ready){ return; }\r\n\t\t\t\tvar i = tests.length;\r\n\t\t\t\twhile(i--){\r\n\t\t\t\t\tif(tests[i]()){\r\n\t\t\t\t\t\tdetectReady(\"poller\");\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsetTimeout(poller, 30);\r\n\t\t\t};\r\n\t\t\tpoller();\r\n\t\t}\r\n\t}\r\n\r\n\treturn domReady;\r\n});\r\n"]}