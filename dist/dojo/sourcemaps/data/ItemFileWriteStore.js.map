{"version":3,"sources":["data/ItemFileWriteStore.js"],"names":["define","lang","declare","arrayUtil","jsonUtil","kernel","ItemFileReadStore","dateStamp","constructor","keywordParameters","this","_features","_pending","_newItems","_modifiedItems","_deletedItems","_datatypeMap","serialize","obj","toISOString","zulu","referenceIntegrity","_saveInProgress","_assert","condition","Error","_getIdentifierAttribute","getFeatures","newItem","keywordArgs","parentInfo","_loadFinished","_forceLoad","newIdentity","identifierAttribute","Number","_arrayOfAllItems","length","isArray","_itemsByIdentity","_storeRefPropName","_itemNumPropName","push","pInfo","parent","attribute","item","oldValue","undefined","values","getValues","tempValues","slice","_setValueOrValues","newValue","_rootItemPropName","_arrayOfTopLevelItems","key","value","i","val","isItem","_addReferenceToMap","onNew","_removeArrayElement","array","element","index","indexOf","splice","deleteItem","_assertIsItem","indexInArrayOfAllItems","identity","getIdentity","attributes","getAttributes","_reverseRefMap","clone","forEach","id","attr","_removeReferenceFromMap","references","itemId","containingItem","oldValues","newValues","filter","possibleItem","onDelete","setValue","setValues","unsetAttribute","newValueOrValues","callOnSet","isString","oldValueOrValues","_getValueOrValues","copyOfItemState","success","newValueArray","map","rId","toString","removedItem","onSet","refItem","parentItem","parentId","itemRef","_isEmpty","_dumpReferenceMap","console","log","toJson","valueOrValues","hasAttribute","valueArray","_flatten","_reference","type","typeMap","isObject","isFunction","_type","_value","_getNewFileContentString","serializableStructure","identifier","_labelAttr","label","items","serializableItem","serializableArray","j","something","empty","save","self","saveCompleteCallback","onComplete","scope","global","call","saveFailedCallback","err","onError","_saveEverything","newFileContentString","_saveCustom","revert","deletedItem","modifiedItem","mixin","reference","isDirty","Boolean","valueOf","close","request","clearOnClose","inherited","arguments"],"mappings":"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","file":"../../data/ItemFileWriteStore.js","sourcesContent":["define([\"../_base/lang\", \"../_base/declare\", \"../_base/array\", \"../_base/json\", \"../_base/kernel\",\r\n\t\"./ItemFileReadStore\", \"../date/stamp\"\r\n], function(lang, declare, arrayUtil, jsonUtil, kernel, ItemFileReadStore, dateStamp){\r\n\r\n// module:\r\n//\t\tdojo/data/ItemFileWriteStore\r\n\r\nreturn declare(\"dojo.data.ItemFileWriteStore\", ItemFileReadStore, {\r\n\t// summary:\r\n\t//\t\tTODOC\r\n\r\n\tconstructor: function(/* object */ keywordParameters){\r\n\t\t// keywordParameters:\r\n\t\t//\t\tThe structure of the typeMap object is as follows:\r\n\t\t// |\t{\r\n\t\t// |\t\ttype0: function || object,\r\n\t\t// |\t\ttype1: function || object,\r\n\t\t// |\t\t...\r\n\t\t// |\t\ttypeN: function || object\r\n\t\t// |\t}\r\n\t\t//\t\tWhere if it is a function, it is assumed to be an object constructor that takes the\r\n\t\t//\t\tvalue of _value as the initialization parameters.  It is serialized assuming object.toString()\r\n\t\t//\t\tserialization.  If it is an object, then it is assumed\r\n\t\t//\t\tto be an object of general form:\r\n\t\t// |\t{\r\n\t\t// |\t\ttype: function, //constructor.\r\n\t\t// |\t\tdeserialize:\tfunction(value) //The function that parses the value and constructs the object defined by type appropriately.\r\n\t\t// |\t\tserialize:\tfunction(object) //The function that converts the object back into the proper file format form.\r\n\t\t// |\t}\r\n\r\n\t\t// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs\r\n\t\tthis._features['dojo.data.api.Write'] = true;\r\n\t\tthis._features['dojo.data.api.Notification'] = true;\r\n\r\n\t\t// For keeping track of changes so that we can implement isDirty and revert\r\n\t\tthis._pending = {\r\n\t\t\t_newItems:{},\r\n\t\t\t_modifiedItems:{},\r\n\t\t\t_deletedItems:{}\r\n\t\t};\r\n\r\n\t\tif(!this._datatypeMap['Date'].serialize){\r\n\t\t\tthis._datatypeMap['Date'].serialize = function(obj){\r\n\t\t\t\treturn dateStamp.toISOString(obj, {zulu:true});\r\n\t\t\t};\r\n\t\t}\r\n\t\t//Disable only if explicitly set to false.\r\n\t\tif(keywordParameters && (keywordParameters.referenceIntegrity === false)){\r\n\t\t\tthis.referenceIntegrity = false;\r\n\t\t}\r\n\r\n\t\t// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes\r\n\t\tthis._saveInProgress = false;\r\n\t},\r\n\r\n\treferenceIntegrity: true, //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.\r\n\r\n\t_assert: function(/* boolean */ condition){\r\n\t\tif(!condition){\r\n\t\t\tthrow new Error(\"assertion failed in ItemFileWriteStore\");\r\n\t\t}\r\n\t},\r\n\r\n\t_getIdentifierAttribute: function(){\r\n\t\t// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));\r\n\t\treturn this.getFeatures()['dojo.data.api.Identity'];\r\n\t},\r\n\r\n\r\n/* dojo/data/api/Write */\r\n\r\n\tnewItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.newItem()\r\n\r\n\t\tthis._assert(!this._saveInProgress);\r\n\r\n\t\tif(!this._loadFinished){\r\n\t\t\t// We need to do this here so that we'll be able to find out what\r\n\t\t\t// identifierAttribute was specified in the data file.\r\n\t\t\tthis._forceLoad();\r\n\t\t}\r\n\r\n\t\tif(typeof keywordArgs != \"object\" && typeof keywordArgs != \"undefined\"){\r\n\t\t\tthrow new Error(\"newItem() was passed something other than an object\");\r\n\t\t}\r\n\t\tvar newIdentity = null;\r\n\t\tvar identifierAttribute = this._getIdentifierAttribute();\r\n\t\tif(identifierAttribute === Number){\r\n\t\t\tnewIdentity = this._arrayOfAllItems.length;\r\n\t\t}else{\r\n\t\t\tnewIdentity = keywordArgs[identifierAttribute];\r\n\t\t\tif(typeof newIdentity === \"undefined\"){\r\n\t\t\t\tthrow new Error(\"newItem() was not passed an identity for the new item\");\r\n\t\t\t}\r\n\t\t\tif(lang.isArray(newIdentity)){\r\n\t\t\t\tthrow new Error(\"newItem() was not passed an single-valued identity\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// make sure this identity is not already in use by another item, if identifiers were\r\n\t\t// defined in the file.  Otherwise it would be the item count,\r\n\t\t// which should always be unique in this case.\r\n\t\tif(this._itemsByIdentity){\r\n\t\t\tthis._assert(typeof this._itemsByIdentity[newIdentity] === \"undefined\");\r\n\t\t}\r\n\t\tthis._assert(typeof this._pending._newItems[newIdentity] === \"undefined\");\r\n\t\tthis._assert(typeof this._pending._deletedItems[newIdentity] === \"undefined\");\r\n\r\n\t\tvar newItem = {};\r\n\t\tnewItem[this._storeRefPropName] = this;\r\n\t\tnewItem[this._itemNumPropName] = this._arrayOfAllItems.length;\r\n\t\tif(this._itemsByIdentity){\r\n\t\t\tthis._itemsByIdentity[newIdentity] = newItem;\r\n\t\t\t//We have to set the identifier now, otherwise we can't look it\r\n\t\t\t//up at calls to setValueorValues in parentInfo handling.\r\n\t\t\tnewItem[identifierAttribute] = [newIdentity];\r\n\t\t}\r\n\t\tthis._arrayOfAllItems.push(newItem);\r\n\r\n\t\t//We need to construct some data for the onNew call too...\r\n\t\tvar pInfo = null;\r\n\r\n\t\t// Now we need to check to see where we want to assign this thingm if any.\r\n\t\tif(parentInfo && parentInfo.parent && parentInfo.attribute){\r\n\t\t\tpInfo = {\r\n\t\t\t\titem: parentInfo.parent,\r\n\t\t\t\tattribute: parentInfo.attribute,\r\n\t\t\t\toldValue: undefined\r\n\t\t\t};\r\n\r\n\t\t\t//See if it is multi-valued or not and handle appropriately\r\n\t\t\t//Generally, all attributes are multi-valued for this store\r\n\t\t\t//So, we only need to append if there are already values present.\r\n\t\t\tvar values = this.getValues(parentInfo.parent, parentInfo.attribute);\r\n\t\t\tif(values && values.length > 0){\r\n\t\t\t\tvar tempValues = values.slice(0, values.length);\r\n\t\t\t\tif(values.length === 1){\r\n\t\t\t\t\tpInfo.oldValue = values[0];\r\n\t\t\t\t}else{\r\n\t\t\t\t\tpInfo.oldValue = values.slice(0, values.length);\r\n\t\t\t\t}\r\n\t\t\t\ttempValues.push(newItem);\r\n\t\t\t\tthis._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);\r\n\t\t\t\tpInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);\r\n\t\t\t}else{\r\n\t\t\t\tthis._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);\r\n\t\t\t\tpInfo.newValue = newItem;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//Toplevel item, add to both top list as well as all list.\r\n\t\t\tnewItem[this._rootItemPropName]=true;\r\n\t\t\tthis._arrayOfTopLevelItems.push(newItem);\r\n\t\t}\r\n\r\n\t\tthis._pending._newItems[newIdentity] = newItem;\r\n\r\n\t\t//Clone over the properties to the new item\r\n\t\tfor(var key in keywordArgs){\r\n\t\t\tif(key === this._storeRefPropName || key === this._itemNumPropName){\r\n\t\t\t\t// Bummer, the user is trying to do something like\r\n\t\t\t\t// newItem({_S:\"foo\"}).  Unfortunately, our superclass,\r\n\t\t\t\t// ItemFileReadStore, is already using _S in each of our items\r\n\t\t\t\t// to hold private info.  To avoid a naming collision, we\r\n\t\t\t\t// need to move all our private info to some other property\r\n\t\t\t\t// of all the items/objects.  So, we need to iterate over all\r\n\t\t\t\t// the items and do something like:\r\n\t\t\t\t//\t  item.__S = item._S;\r\n\t\t\t\t//\t  item._S = undefined;\r\n\t\t\t\t// But first we have to make sure the new \"__S\" variable is\r\n\t\t\t\t// not in use, which means we have to iterate over all the\r\n\t\t\t\t// items checking for that.\r\n\t\t\t\tthrow new Error(\"encountered bug in ItemFileWriteStore.newItem\");\r\n\t\t\t}\r\n\t\t\tvar value = keywordArgs[key];\r\n\t\t\tif(!lang.isArray(value)){\r\n\t\t\t\tvalue = [value];\r\n\t\t\t}\r\n\t\t\tnewItem[key] = value;\r\n\t\t\tif(this.referenceIntegrity){\r\n\t\t\t\tfor(var i = 0; i < value.length; i++){\r\n\t\t\t\t\tvar val = value[i];\r\n\t\t\t\t\tif(this.isItem(val)){\r\n\t\t\t\t\t\tthis._addReferenceToMap(val, newItem, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.onNew(newItem, pInfo); // dojo/data/api/Notification call\r\n\t\treturn newItem; // item\r\n\t},\r\n\r\n\t_removeArrayElement: function(/* Array */ array, /* anything */ element){\r\n\t\tvar index = arrayUtil.indexOf(array, element);\r\n\t\tif(index != -1){\r\n\t\t\tarray.splice(index, 1);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tdeleteItem: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.deleteItem()\r\n\t\tthis._assert(!this._saveInProgress);\r\n\t\tthis._assertIsItem(item);\r\n\r\n\t\t// Remove this item from the _arrayOfAllItems, but leave a null value in place\r\n\t\t// of the item, so as not to change the length of the array, so that in newItem()\r\n\t\t// we can still safely do: newIdentity = this._arrayOfAllItems.length;\r\n\t\tvar indexInArrayOfAllItems = item[this._itemNumPropName];\r\n\t\tvar identity = this.getIdentity(item);\r\n\r\n\t\t//If we have reference integrity on, we need to do reference cleanup for the deleted item\r\n\t\tif(this.referenceIntegrity){\r\n\t\t\t//First scan all the attributes of this items for references and clean them up in the map\r\n\t\t\t//As this item is going away, no need to track its references anymore.\r\n\r\n\t\t\t//Get the attributes list before we generate the backup so it\r\n\t\t\t//doesn't pollute the attributes list.\r\n\t\t\tvar attributes = this.getAttributes(item);\r\n\r\n\t\t\t//Backup the map, we'll have to restore it potentially, in a revert.\r\n\t\t\tif(item[this._reverseRefMap]){\r\n\t\t\t\titem[\"backup_\" + this._reverseRefMap] = lang.clone(item[this._reverseRefMap]);\r\n\t\t\t}\r\n\r\n\t\t\t//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is\r\n\t\t\t//attached to the 'value'. item, not ours.  Need to back tese up somehow too.\r\n\t\t\t//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored\r\n\t\t\t//later.  Or just record them and call _addReferenceToMap on them in revert.\r\n\t\t\tarrayUtil.forEach(attributes, function(attribute){\r\n\t\t\t\tarrayUtil.forEach(this.getValues(item, attribute), function(value){\r\n\t\t\t\t\tif(this.isItem(value)){\r\n\t\t\t\t\t\t//We have to back up all the references we had to others so they can be restored on a revert.\r\n\t\t\t\t\t\tif(!item[\"backupRefs_\" + this._reverseRefMap]){\r\n\t\t\t\t\t\t\titem[\"backupRefs_\" + this._reverseRefMap] = [];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\titem[\"backupRefs_\" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});\r\n\t\t\t\t\t\tthis._removeReferenceFromMap(value, item, attribute);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t}, this);\r\n\r\n\t\t\t//Next, see if we have references to this item, if we do, we have to clean them up too.\r\n\t\t\tvar references = item[this._reverseRefMap];\r\n\t\t\tif(references){\r\n\t\t\t\t//Look through all the items noted as references to clean them up.\r\n\t\t\t\tfor(var itemId in references){\r\n\t\t\t\t\tvar containingItem = null;\r\n\t\t\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\t\t\tcontainingItem = this._itemsByIdentity[itemId];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcontainingItem = this._arrayOfAllItems[itemId];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//We have a reference to a containing item, now we have to process the\r\n\t\t\t\t\t//attributes and clear all references to the item being deleted.\r\n\t\t\t\t\tif(containingItem){\r\n\t\t\t\t\t\tfor(var attribute in references[itemId]){\r\n\t\t\t\t\t\t\tvar oldValues = this.getValues(containingItem, attribute) || [];\r\n\t\t\t\t\t\t\tvar newValues = arrayUtil.filter(oldValues, function(possibleItem){\r\n\t\t\t\t\t\t\t\treturn !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);\r\n\t\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\t\t//Remove the note of the reference to the item and set the values on the modified attribute.\r\n\t\t\t\t\t\t\tthis._removeReferenceFromMap(item, containingItem, attribute);\r\n\t\t\t\t\t\t\tif(newValues.length < oldValues.length){\r\n\t\t\t\t\t\t\t\tthis._setValueOrValues(containingItem, attribute, newValues, true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._arrayOfAllItems[indexInArrayOfAllItems] = null;\r\n\r\n\t\titem[this._storeRefPropName] = null;\r\n\t\tif(this._itemsByIdentity){\r\n\t\t\tdelete this._itemsByIdentity[identity];\r\n\t\t}\r\n\t\tthis._pending._deletedItems[identity] = item;\r\n\r\n\t\t//Remove from the toplevel items, if necessary...\r\n\t\tif(item[this._rootItemPropName]){\r\n\t\t\tthis._removeArrayElement(this._arrayOfTopLevelItems, item);\r\n\t\t}\r\n\t\tthis.onDelete(item); // dojo/data/api/Notification call\r\n\t\treturn true;\r\n\t},\r\n\r\n\tsetValue: function(/* dojo/data/api/Item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.set()\r\n\t\treturn this._setValueOrValues(item, attribute, value, true); // boolean\r\n\t},\r\n\r\n\tsetValues: function(/* dojo/data/api/Item */ item, /* attribute-name-string */ attribute, /* array */ values){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.setValues()\r\n\t\treturn this._setValueOrValues(item, attribute, values, true); // boolean\r\n\t},\r\n\r\n\tunsetAttribute: function(/* dojo/data/api/Item */ item, /* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.unsetAttribute()\r\n\t\treturn this._setValueOrValues(item, attribute, [], true);\r\n\t},\r\n\r\n\t_setValueOrValues: function(/* dojo/data/api/Item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){\r\n\t\tthis._assert(!this._saveInProgress);\r\n\r\n\t\t// Check for valid arguments\r\n\t\tthis._assertIsItem(item);\r\n\t\tthis._assert(lang.isString(attribute));\r\n\t\tthis._assert(typeof newValueOrValues !== \"undefined\");\r\n\r\n\t\t// Make sure the user isn't trying to change the item's identity\r\n\t\tvar identifierAttribute = this._getIdentifierAttribute();\r\n\t\tif(attribute == identifierAttribute){\r\n\t\t\tthrow new Error(\"ItemFileWriteStore does not have support for changing the value of an item's identifier.\");\r\n\t\t}\r\n\r\n\t\t// To implement the Notification API, we need to make a note of what\r\n\t\t// the old attribute value was, so that we can pass that info when\r\n\t\t// we call the onSet method.\r\n\t\tvar oldValueOrValues = this._getValueOrValues(item, attribute);\r\n\r\n\t\tvar identity = this.getIdentity(item);\r\n\t\tif(!this._pending._modifiedItems[identity]){\r\n\t\t\t// Before we actually change the item, we make a copy of it to\r\n\t\t\t// record the original state, so that we'll be able to revert if\r\n\t\t\t// the revert method gets called.  If the item has already been\r\n\t\t\t// modified then there's no need to do this now, since we already\r\n\t\t\t// have a record of the original state.\r\n\t\t\tvar copyOfItemState = {};\r\n\t\t\tfor(var key in item){\r\n\t\t\t\tif((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){\r\n\t\t\t\t\tcopyOfItemState[key] = item[key];\r\n\t\t\t\t}else if(key === this._reverseRefMap){\r\n\t\t\t\t\tcopyOfItemState[key] = lang.clone(item[key]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcopyOfItemState[key] = item[key].slice(0, item[key].length);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Now mark the item as dirty, and save the copy of the original state\r\n\t\t\tthis._pending._modifiedItems[identity] = copyOfItemState;\r\n\t\t}\r\n\r\n\t\t// Okay, now we can actually change this attribute on the item\r\n\t\tvar success = false;\r\n\r\n\t\tif(lang.isArray(newValueOrValues) && newValueOrValues.length === 0){\r\n\r\n\t\t\t// If we were passed an empty array as the value, that counts\r\n\t\t\t// as \"unsetting\" the attribute, so we need to remove this\r\n\t\t\t// attribute from the item.\r\n\t\t\tsuccess = delete item[attribute];\r\n\t\t\tnewValueOrValues = undefined; // used in the onSet Notification call below\r\n\r\n\t\t\tif(this.referenceIntegrity && oldValueOrValues){\r\n\t\t\t\tvar oldValues = oldValueOrValues;\r\n\t\t\t\tif(!lang.isArray(oldValues)){\r\n\t\t\t\t\toldValues = [oldValues];\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0; i < oldValues.length; i++){\r\n\t\t\t\t\tvar value = oldValues[i];\r\n\t\t\t\t\tif(this.isItem(value)){\r\n\t\t\t\t\t\tthis._removeReferenceFromMap(value, item, attribute);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tvar newValueArray;\r\n\t\t\tif(lang.isArray(newValueOrValues)){\r\n\t\t\t\t// Unfortunately, it's not safe to just do this:\r\n\t\t\t\t//\t  newValueArray = newValueOrValues;\r\n\t\t\t\t// Instead, we need to copy the array, which slice() does very nicely.\r\n\t\t\t\t// This is so that our internal data structure won't\r\n\t\t\t\t// get corrupted if the user mucks with the values array *after*\r\n\t\t\t\t// calling setValues().\r\n\t\t\t\tnewValueArray = newValueOrValues.slice(0, newValueOrValues.length);\r\n\t\t\t}else{\r\n\t\t\t\tnewValueArray = [newValueOrValues];\r\n\t\t\t}\r\n\r\n\t\t\t//We need to handle reference integrity if this is on.\r\n\t\t\t//In the case of set, we need to see if references were added or removed\r\n\t\t\t//and update the reference tracking map accordingly.\r\n\t\t\tif(this.referenceIntegrity){\r\n\t\t\t\tif(oldValueOrValues){\r\n\t\t\t\t\tvar oldValues = oldValueOrValues;\r\n\t\t\t\t\tif(!lang.isArray(oldValues)){\r\n\t\t\t\t\t\toldValues = [oldValues];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Use an associative map to determine what was added/removed from the list.\r\n\t\t\t\t\t//Should be O(n) performant.  First look at all the old values and make a list of them\r\n\t\t\t\t\t//Then for any item not in the old list, we add it.  If it was already present, we remove it.\r\n\t\t\t\t\t//Then we pass over the map and any references left it it need to be removed (IE, no match in\r\n\t\t\t\t\t//the new values list).\r\n\t\t\t\t\tvar map = {};\r\n\t\t\t\t\tarrayUtil.forEach(oldValues, function(possibleItem){\r\n\t\t\t\t\t\tif(this.isItem(possibleItem)){\r\n\t\t\t\t\t\t\tvar id = this.getIdentity(possibleItem);\r\n\t\t\t\t\t\t\tmap[id.toString()] = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t\tarrayUtil.forEach(newValueArray, function(possibleItem){\r\n\t\t\t\t\t\tif(this.isItem(possibleItem)){\r\n\t\t\t\t\t\t\tvar id = this.getIdentity(possibleItem);\r\n\t\t\t\t\t\t\tif(map[id.toString()]){\r\n\t\t\t\t\t\t\t\tdelete map[id.toString()];\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tthis._addReferenceToMap(possibleItem, item, attribute);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t\tfor(var rId in map){\r\n\t\t\t\t\t\tvar removedItem;\r\n\t\t\t\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\t\t\t\tremovedItem = this._itemsByIdentity[rId];\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tremovedItem = this._arrayOfAllItems[rId];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis._removeReferenceFromMap(removedItem, item, attribute);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//Everything is new (no old values) so we have to just\r\n\t\t\t\t\t//insert all the references, if any.\r\n\t\t\t\t\tfor(var i = 0; i < newValueArray.length; i++){\r\n\t\t\t\t\t\tvar value = newValueArray[i];\r\n\t\t\t\t\t\tif(this.isItem(value)){\r\n\t\t\t\t\t\t\tthis._addReferenceToMap(value, item, attribute);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\titem[attribute] = newValueArray;\r\n\t\t\tsuccess = true;\r\n\t\t}\r\n\r\n\t\t// Now we make the dojo/data/api/Notification call\r\n\t\tif(callOnSet){\r\n\t\t\tthis.onSet(item, attribute, oldValueOrValues, newValueOrValues);\r\n\t\t}\r\n\t\treturn success; // boolean\r\n\t},\r\n\r\n\t_addReferenceToMap: function(/* dojo/data/api/Item */ refItem, /* dojo/data/api/Item */ parentItem, /* string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tMethod to add an reference map entry for an item and attribute.\r\n\t\t// description:\r\n\t\t//\t\tMethod to add an reference map entry for an item and attribute.\r\n\t\t// refItem:\r\n\t\t//\t\tThe item that is referenced.\r\n\t\t// parentItem:\r\n\t\t//\t\tThe item that holds the new reference to refItem.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute on parentItem that contains the new reference.\r\n\r\n\t\tvar parentId = this.getIdentity(parentItem);\r\n\t\tvar references = refItem[this._reverseRefMap];\r\n\r\n\t\tif(!references){\r\n\t\t\treferences = refItem[this._reverseRefMap] = {};\r\n\t\t}\r\n\t\tvar itemRef = references[parentId];\r\n\t\tif(!itemRef){\r\n\t\t\titemRef = references[parentId] = {};\r\n\t\t}\r\n\t\titemRef[attribute] = true;\r\n\t},\r\n\r\n\t_removeReferenceFromMap: function(/* dojo/data/api/Item */ refItem, /* dojo/data/api/Item */ parentItem, /* string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tMethod to remove an reference map entry for an item and attribute.\r\n\t\t// description:\r\n\t\t//\t\tMethod to remove an reference map entry for an item and attribute.  This will\r\n\t\t//\t\talso perform cleanup on the map such that if there are no more references at all to\r\n\t\t//\t\tthe item, its reference object and entry are removed.\r\n\t\t// refItem:\r\n\t\t//\t\tThe item that is referenced.\r\n\t\t// parentItem:\r\n\t\t//\t\tThe item holding a reference to refItem.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute on parentItem that contains the reference.\r\n\t\tvar identity = this.getIdentity(parentItem);\r\n\t\tvar references = refItem[this._reverseRefMap];\r\n\t\tvar itemId;\r\n\t\tif(references){\r\n\t\t\tfor(itemId in references){\r\n\t\t\t\tif(itemId == identity){\r\n\t\t\t\t\tdelete references[itemId][attribute];\r\n\t\t\t\t\tif(this._isEmpty(references[itemId])){\r\n\t\t\t\t\t\tdelete references[itemId];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(this._isEmpty(references)){\r\n\t\t\t\tdelete refItem[this._reverseRefMap];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_dumpReferenceMap: function(){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to dump the reverse reference map of all items in the store for debug purposes.\r\n\t\t// description:\r\n\t\t//\t\tFunction to dump the reverse reference map of all items in the store for debug purposes.\r\n\t\tvar i;\r\n\t\tfor(i = 0; i < this._arrayOfAllItems.length; i++){\r\n\t\t\tvar item = this._arrayOfAllItems[i];\r\n\t\t\tif(item && item[this._reverseRefMap]){\r\n\t\t\t\tconsole.log(\"Item: [\" + this.getIdentity(item) + \"] is referenced by: \" + jsonUtil.toJson(item[this._reverseRefMap]));\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getValueOrValues: function(/* dojo/data/api/Item */ item, /* attribute-name-string */ attribute){\r\n\t\tvar valueOrValues = undefined;\r\n\t\tif(this.hasAttribute(item, attribute)){\r\n\t\t\tvar valueArray = this.getValues(item, attribute);\r\n\t\t\tif(valueArray.length == 1){\r\n\t\t\t\tvalueOrValues = valueArray[0];\r\n\t\t\t}else{\r\n\t\t\t\tvalueOrValues = valueArray;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn valueOrValues;\r\n\t},\r\n\r\n\t_flatten: function(/* anything */ value){\r\n\t\tif(this.isItem(value)){\r\n\t\t\t// Given an item, return an serializable object that provides a\r\n\t\t\t// reference to the item.\r\n\t\t\t// For example, given kermit:\r\n\t\t\t//\t  var kermit = store.newItem({id:2, name:\"Kermit\"});\r\n\t\t\t// we want to return\r\n\t\t\t//\t  {_reference:2}\r\n\t\t\treturn {_reference: this.getIdentity(value)};\r\n\t\t}else{\r\n\t\t\tif(typeof value === \"object\"){\r\n\t\t\t\tfor(var type in this._datatypeMap){\r\n\t\t\t\t\tvar typeMap = this._datatypeMap[type];\r\n\t\t\t\t\tif(lang.isObject(typeMap) && !lang.isFunction(typeMap)){\r\n\t\t\t\t\t\tif(value instanceof typeMap.type){\r\n\t\t\t\t\t\t\tif(!typeMap.serialize){\r\n\t\t\t\t\t\t\t\tthrow new Error(\"ItemFileWriteStore:  No serializer defined for type mapping: [\" + type + \"]\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn {_type: type, _value: typeMap.serialize(value)};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(value instanceof typeMap){\r\n\t\t\t\t\t\t//SImple mapping, therefore, return as a toString serialization.\r\n\t\t\t\t\t\treturn {_type: type, _value: value.toString()};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\t},\r\n\r\n\t_getNewFileContentString: function(){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a string that can be saved to a file.\r\n\t\t//\t\tThe result should look similar to:\r\n\t\t//\t\thttp://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json\r\n\t\tvar serializableStructure = {};\r\n\r\n\t\tvar identifierAttribute = this._getIdentifierAttribute();\r\n\t\tif(identifierAttribute !== Number){\r\n\t\t\tserializableStructure.identifier = identifierAttribute;\r\n\t\t}\r\n\t\tif(this._labelAttr){\r\n\t\t\tserializableStructure.label = this._labelAttr;\r\n\t\t}\r\n\t\tserializableStructure.items = [];\r\n\t\tfor(var i = 0; i < this._arrayOfAllItems.length; ++i){\r\n\t\t\tvar item = this._arrayOfAllItems[i];\r\n\t\t\tif(item !== null){\r\n\t\t\t\tvar serializableItem = {};\r\n\t\t\t\tfor(var key in item){\r\n\t\t\t\t\tif(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){\r\n\t\t\t\t\t\tvar valueArray = this.getValues(item, key);\r\n\t\t\t\t\t\tif(valueArray.length == 1){\r\n\t\t\t\t\t\t\tserializableItem[key] = this._flatten(valueArray[0]);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tvar serializableArray = [];\r\n\t\t\t\t\t\t\tfor(var j = 0; j < valueArray.length; ++j){\r\n\t\t\t\t\t\t\t\tserializableArray.push(this._flatten(valueArray[j]));\r\n\t\t\t\t\t\t\t\tserializableItem[key] = serializableArray;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tserializableStructure.items.push(serializableItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prettyPrint = true;\r\n\t\treturn jsonUtil.toJson(serializableStructure, prettyPrint);\r\n\t},\r\n\r\n\t_isEmpty: function(something){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to determine if an array or object has no properties or values.\r\n\t\t// something:\r\n\t\t//\t\tThe array or object to examine.\r\n\t\tvar empty = true;\r\n\t\tif(lang.isObject(something)){\r\n\t\t\tvar i;\r\n\t\t\tfor(i in something){\r\n\t\t\t\tempty = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}else if(lang.isArray(something)){\r\n\t\t\tif(something.length > 0){\r\n\t\t\t\tempty = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn empty; //boolean\r\n\t},\r\n\r\n\tsave: function(/* object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.save()\r\n\t\tthis._assert(!this._saveInProgress);\r\n\r\n\t\t// this._saveInProgress is set to true, briefly, from when save is first called to when it completes\r\n\t\tthis._saveInProgress = true;\r\n\r\n\t\tvar self = this;\r\n\t\tvar saveCompleteCallback = function(){\r\n\t\t\tself._pending = {\r\n\t\t\t\t_newItems:{},\r\n\t\t\t\t_modifiedItems:{},\r\n\t\t\t\t_deletedItems:{}\r\n\t\t\t};\r\n\r\n\t\t\tself._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks\r\n\t\t\tif(keywordArgs && keywordArgs.onComplete){\r\n\t\t\t\tvar scope = keywordArgs.scope || kernel.global;\r\n\t\t\t\tkeywordArgs.onComplete.call(scope);\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar saveFailedCallback = function(err){\r\n\t\t\tself._saveInProgress = false;\r\n\t\t\tif(keywordArgs && keywordArgs.onError){\r\n\t\t\t\tvar scope = keywordArgs.scope || kernel.global;\r\n\t\t\t\tkeywordArgs.onError.call(scope, err);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this._saveEverything){\r\n\t\t\tvar newFileContentString = this._getNewFileContentString();\r\n\t\t\tthis._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);\r\n\t\t}\r\n\t\tif(this._saveCustom){\r\n\t\t\tthis._saveCustom(saveCompleteCallback, saveFailedCallback);\r\n\t\t}\r\n\t\tif(!this._saveEverything && !this._saveCustom){\r\n\t\t\t// Looks like there is no user-defined save-handler function.\r\n\t\t\t// That's fine, it just means the datastore is acting as a \"mock-write\"\r\n\t\t\t// store -- changes get saved in memory but don't get saved to disk.\r\n\t\t\tsaveCompleteCallback();\r\n\t\t}\r\n\t},\r\n\r\n\trevert: function(){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.revert()\r\n\t\tthis._assert(!this._saveInProgress);\r\n\r\n\t\tvar identity;\r\n\t\tfor(identity in this._pending._modifiedItems){\r\n\t\t\t// find the original item and the modified item that replaced it\r\n\t\t\tvar copyOfItemState = this._pending._modifiedItems[identity];\r\n\t\t\tvar modifiedItem = null;\r\n\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\tmodifiedItem = this._itemsByIdentity[identity];\r\n\t\t\t}else{\r\n\t\t\t\tmodifiedItem = this._arrayOfAllItems[identity];\r\n\t\t\t}\r\n\r\n\t\t\t// Restore the original item into a full-fledged item again, we want to try to\r\n\t\t\t// keep the same object instance as if we don't it, causes bugs like #9022.\r\n\t\t\tcopyOfItemState[this._storeRefPropName] = this;\r\n\t\t\tfor(var key in modifiedItem){\r\n\t\t\t\tdelete modifiedItem[key];\r\n\t\t\t}\r\n\t\t\tlang.mixin(modifiedItem, copyOfItemState);\r\n\t\t}\r\n\t\tvar deletedItem;\r\n\t\tfor(identity in this._pending._deletedItems){\r\n\t\t\tdeletedItem = this._pending._deletedItems[identity];\r\n\t\t\tdeletedItem[this._storeRefPropName] = this;\r\n\t\t\tvar index = deletedItem[this._itemNumPropName];\r\n\r\n\t\t\t//Restore the reverse refererence map, if any.\r\n\t\t\tif(deletedItem[\"backup_\" + this._reverseRefMap]){\r\n\t\t\t\tdeletedItem[this._reverseRefMap] = deletedItem[\"backup_\" + this._reverseRefMap];\r\n\t\t\t\tdelete deletedItem[\"backup_\" + this._reverseRefMap];\r\n\t\t\t}\r\n\t\t\tthis._arrayOfAllItems[index] = deletedItem;\r\n\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\tthis._itemsByIdentity[identity] = deletedItem;\r\n\t\t\t}\r\n\t\t\tif(deletedItem[this._rootItemPropName]){\r\n\t\t\t\tthis._arrayOfTopLevelItems.push(deletedItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//We have to pass through it again and restore the reference maps after all the\r\n\t\t//undeletes have occurred.\r\n\t\tfor(identity in this._pending._deletedItems){\r\n\t\t\tdeletedItem = this._pending._deletedItems[identity];\r\n\t\t\tif(deletedItem[\"backupRefs_\" + this._reverseRefMap]){\r\n\t\t\t\tarrayUtil.forEach(deletedItem[\"backupRefs_\" + this._reverseRefMap], function(reference){\r\n\t\t\t\t\tvar refItem;\r\n\t\t\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\t\t\trefItem = this._itemsByIdentity[reference.id];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\trefItem = this._arrayOfAllItems[reference.id];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._addReferenceToMap(refItem, deletedItem, reference.attr);\r\n\t\t\t\t}, this);\r\n\t\t\t\tdelete deletedItem[\"backupRefs_\" + this._reverseRefMap];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(identity in this._pending._newItems){\r\n\t\t\tvar newItem = this._pending._newItems[identity];\r\n\t\t\tnewItem[this._storeRefPropName] = null;\r\n\t\t\t// null out the new item, but don't change the array index so\r\n\t\t\t// so we can keep using _arrayOfAllItems.length.\r\n\t\t\tthis._arrayOfAllItems[newItem[this._itemNumPropName]] = null;\r\n\t\t\tif(newItem[this._rootItemPropName]){\r\n\t\t\t\tthis._removeArrayElement(this._arrayOfTopLevelItems, newItem);\r\n\t\t\t}\r\n\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\tdelete this._itemsByIdentity[identity];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._pending = {\r\n\t\t\t_newItems:{},\r\n\t\t\t_modifiedItems:{},\r\n\t\t\t_deletedItems:{}\r\n\t\t};\r\n\t\treturn true; // boolean\r\n\t},\r\n\r\n\tisDirty: function(/* item? */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Write.isDirty()\r\n\t\tif(item){\r\n\t\t\t// return true if the item is dirty\r\n\t\t\tvar identity = this.getIdentity(item);\r\n\t\t\treturn new Boolean(this._pending._newItems[identity] ||\r\n\t\t\t\tthis._pending._modifiedItems[identity] ||\r\n\t\t\t\tthis._pending._deletedItems[identity]).valueOf(); // boolean\r\n\t\t}else{\r\n\t\t\t// return true if the store is dirty -- which means return true\r\n\t\t\t// if there are any new items, dirty items, or modified items\r\n\t\t\treturn !this._isEmpty(this._pending._newItems) ||\r\n\t\t\t\t!this._isEmpty(this._pending._modifiedItems) ||\r\n\t\t\t\t!this._isEmpty(this._pending._deletedItems); // boolean\r\n\t\t}\r\n\t},\r\n\r\n/* dojo/data/api/Notification */\r\n\r\n\tonSet: function(/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t/*attribute-name-string*/ attribute,\r\n\t\t\t\t\t/*object|array*/ oldValue,\r\n\t\t\t\t\t/*object|array*/ newValue){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Notification.onSet()\r\n\r\n\t\t// No need to do anything. This method is here just so that the\r\n\t\t// client code can connect observers to it.\r\n\t},\r\n\r\n\tonNew: function(/* dojo/data/api/Item */ newItem, /*object?*/ parentInfo){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Notification.onNew()\r\n\r\n\t\t// No need to do anything. This method is here just so that the\r\n\t\t// client code can connect observers to it.\r\n\t},\r\n\r\n\tonDelete: function(/* dojo/data/api/Item */ deletedItem){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Notification.onDelete()\r\n\r\n\t\t// No need to do anything. This method is here just so that the\r\n\t\t// client code can connect observers to it.\r\n\t},\r\n\r\n\tclose: function(/* object? */ request){\r\n\t\t // summary:\r\n\t\t //\t\tOver-ride of base close function of ItemFileReadStore to add in check for store state.\r\n\t\t // description:\r\n\t\t //\t\tOver-ride of base close function of ItemFileReadStore to add in check for store state.\r\n\t\t //\t\tIf the store is still dirty (unsaved changes), then an error will be thrown instead of\r\n\t\t //\t\tclearing the internal state for reload from the url.\r\n\r\n\t\t //Clear if not dirty ... or throw an error\r\n\t\t if(this.clearOnClose){\r\n\t\t\t if(!this.isDirty()){\r\n\t\t\t\t this.inherited(arguments);\r\n\t\t\t }else{\r\n\t\t\t\t //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).\r\n\t\t\t\t throw new Error(\"dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.\");\r\n\t\t\t }\r\n\t\t }\r\n\t}\r\n});\r\n\r\n});\r\n"]}