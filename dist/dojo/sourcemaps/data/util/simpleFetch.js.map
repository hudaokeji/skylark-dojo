{"version":3,"sources":["data/util/simpleFetch.js"],"names":["define","lang","kernel","sorter","simpleFetch","setObject","errorHandler","errorData","requestObject","onError","scope","global","call","fetchHandler","items","oldAbortFunction","abort","aborted","startIndex","start","endIndex","count","Infinity","length","store","this","onBegin","sort","createSortFunction","onItem","i","item","onComplete","subset","slice","fetch","request","_fetchItems","hitch"],"mappings":";;;;;;;AAAAA,QAAQ,mBAAoB,qBAAsB,YAChD,SAASC,EAAMC,EAAQC,GAOzB,IAAIC,KAsOJ,OArOAH,EAAKI,UAAU,6BAA8BD,GAE7CA,EAAYE,aAAe,SAAoBC,EAAsBC,GAIpE,GAAGA,EAAcC,QAAQ,CACxB,IAAIC,EAAQF,EAAcE,OAASR,EAAOS,OAC1CH,EAAcC,QAAQG,KAAKF,EAAOH,EAAWC,KAI/CJ,EAAYS,aAAe,SAAmBC,EAAkBN,GAI/D,IAAIO,EAAmBP,EAAcQ,OAAS,KAC7CC,GAAU,EAEVC,EAAaV,EAAcW,MAAMX,EAAcW,MAAO,EACtDC,EAAYZ,EAAca,OAAUb,EAAca,QAAUC,EAAAA,EAAYJ,EAAaV,EAAca,MAAOP,EAAMS,OAEjHf,EAAcQ,MAAQ,WACrBC,GAAU,EACPF,GACFA,EAAiBH,KAAKJ,IAIxB,IAAIE,EAAQF,EAAcE,OAASR,EAAOS,OAU1C,GATIH,EAAcgB,QACjBhB,EAAcgB,MAAQC,MAEpBjB,EAAckB,SAChBlB,EAAckB,QAAQd,KAAKF,EAAOI,EAAMS,OAAQf,GAE9CA,EAAcmB,MAChBb,EAAMa,KAAKxB,EAAOyB,mBAAmBpB,EAAcmB,KAAMF,OAEvDjB,EAAcqB,OAChB,IAAI,IAAIC,EAAIZ,EAAaY,EAAIhB,EAAMS,QAAYO,EAAIV,IAAaU,EAAE,CACjE,IAAIC,EAAOjB,EAAMgB,GACbb,GACHT,EAAcqB,OAAOjB,KAAKF,EAAOqB,EAAMvB,GAI1C,GAAGA,EAAcwB,aAAef,EAAQ,CACvC,IAAIgB,EAAS,KACTzB,EAAcqB,SACjBI,EAASnB,EAAMoB,MAAMhB,EAAYE,IAElCZ,EAAcwB,WAAWpB,KAAKF,EAAOuB,EAAQzB,KAI/CJ,EAAY+B,MAAQ,SAAuBC,GA0K1C,OANAA,EAAUA,OACEZ,QACXY,EAAQZ,MAAQC,MAGjBA,KAAKY,YAAYD,EAASnC,EAAKqC,MAAMb,KAAM,gBAAiBxB,EAAKqC,MAAMb,KAAM,iBACtEW,GAGDhC","file":"../../../data/util/simpleFetch.js","sourcesContent":["define([\"../../_base/lang\", \"../../_base/kernel\", \"./sorter\"],\r\n  function(lang, kernel, sorter){\r\n\t// module:\r\n\t//\t\tdojo/data/util/simpleFetch\r\n\t// summary:\r\n\t//\t\tThe simpleFetch mixin is designed to serve as a set of function(s) that can\r\n\t//\t\tbe mixed into other datastore implementations to accelerate their development.\r\n\r\nvar simpleFetch = {};\r\nlang.setObject(\"dojo.data.util.simpleFetch\", simpleFetch);\r\n\r\nsimpleFetch.errorHandler = function(/*Object*/ errorData, /*Object*/ requestObject){\r\n\t// summary:\r\n\t//\t\tThe error handler when there is an error fetching items.  This function should not be called\r\n\t//\t\tdirectly and is used by simpleFetch.fetch().\r\n\tif(requestObject.onError){\r\n\t\tvar scope = requestObject.scope || kernel.global;\r\n\t\trequestObject.onError.call(scope, errorData, requestObject);\r\n\t}\r\n};\r\n\r\nsimpleFetch.fetchHandler = function(/*Array*/ items, /*Object*/ requestObject){\r\n\t// summary:\r\n\t//\t\tThe handler when items are successfully fetched.  This function should not be called directly\r\n\t//\t\tand is used by simpleFetch.fetch().\r\n\tvar oldAbortFunction = requestObject.abort || null,\r\n\t\taborted = false,\r\n\r\n\t\tstartIndex = requestObject.start?requestObject.start: 0,\r\n\t\tendIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;\r\n\r\n\trequestObject.abort = function(){\r\n\t\taborted = true;\r\n\t\tif(oldAbortFunction){\r\n\t\t\toldAbortFunction.call(requestObject);\r\n\t\t}\r\n\t};\r\n\r\n\tvar scope = requestObject.scope || kernel.global;\r\n\tif(!requestObject.store){\r\n\t\trequestObject.store = this;\r\n\t}\r\n\tif(requestObject.onBegin){\r\n\t\trequestObject.onBegin.call(scope, items.length, requestObject);\r\n\t}\r\n\tif(requestObject.sort){\r\n\t\titems.sort(sorter.createSortFunction(requestObject.sort, this));\r\n\t}\r\n\tif(requestObject.onItem){\r\n\t\tfor(var i = startIndex; (i < items.length) && (i < endIndex); ++i){\r\n\t\t\tvar item = items[i];\r\n\t\t\tif(!aborted){\r\n\t\t\t\trequestObject.onItem.call(scope, item, requestObject);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(requestObject.onComplete && !aborted){\r\n\t\tvar subset = null;\r\n\t\tif(!requestObject.onItem){\r\n\t\t\tsubset = items.slice(startIndex, endIndex);\r\n\t\t}\r\n\t\trequestObject.onComplete.call(scope, subset, requestObject);\r\n\t}\r\n};\r\n\r\nsimpleFetch.fetch = function(/* Object? */ request){\r\n\t// summary:\r\n\t//\t\tThe simpleFetch mixin is designed to serve as a set of function(s) that can\r\n\t//\t\tbe mixed into other datastore implementations to accelerate their development.\r\n\t// description:\r\n\t//\t\tThe simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()\r\n\t//\t\tcall by returning an array of all the found items that matched the query.  The simpleFetch mixin\r\n\t//\t\tis not designed to work for datastores that respond to a fetch() call by incrementally\r\n\t//\t\tloading items, or sequentially loading partial batches of the result\r\n\t//\t\tset.  For datastores that mixin simpleFetch, simpleFetch\r\n\t//\t\timplements a fetch method that automatically handles eight of the fetch()\r\n\t//\t\targuments -- onBegin, onItem, onComplete, onError, start, count, sort and scope\r\n\t//\t\tThe class mixing in simpleFetch should not implement fetch(),\r\n\t//\t\tbut should instead implement a _fetchItems() method.  The _fetchItems()\r\n\t//\t\tmethod takes three arguments, the keywordArgs object that was passed\r\n\t//\t\tto fetch(), a callback function to be called when the result array is\r\n\t//\t\tavailable, and an error callback to be called if something goes wrong.\r\n\t//\t\tThe _fetchItems() method should ignore any keywordArgs parameters for\r\n\t//\t\tstart, count, onBegin, onItem, onComplete, onError, sort, and scope.\r\n\t//\t\tThe _fetchItems() method needs to correctly handle any other keywordArgs\r\n\t//\t\tparameters, including the query parameter and any optional parameters\r\n\t//\t\t(such as includeChildren).  The _fetchItems() method should create an array of\r\n\t//\t\tresult items and pass it to the fetchHandler along with the original request object --\r\n\t//\t\tor, the _fetchItems() method may, if it wants to, create an new request object\r\n\t//\t\twith other specifics about the request that are specific to the datastore and pass\r\n\t//\t\tthat as the request object to the handler.\r\n\t//\r\n\t//\t\tFor more information on this specific function, see dojo/data/api/Read.fetch()\r\n\t//\r\n\t// request:\r\n\t//\t\tThe keywordArgs parameter may either be an instance of\r\n\t//\t\tconforming to dojo/data/api/Request or may be a simple anonymous object\r\n\t//\t\tthat may contain any of the following:\r\n\t// |\t{\r\n\t// |\t\tquery: query-object or query-string,\r\n\t// |\t\tqueryOptions: object,\r\n\t// |\t\tonBegin: Function,\r\n\t// |\t\tonItem: Function,\r\n\t// |\t\tonComplete: Function,\r\n\t// |\t\tonError: Function,\r\n\t// |\t\tscope: object,\r\n\t// |\t\tstart: int\r\n\t// |\t\tcount: int\r\n\t// |\t\tsort: array\r\n\t// |\t}\r\n\t//\t\tAll implementations should accept keywordArgs objects with any of\r\n\t//\t\tthe 9 standard properties: query, onBegin, onItem, onComplete, onError\r\n\t//\t\tscope, sort, start, and count.  Some implementations may accept additional\r\n\t//\t\tproperties in the keywordArgs object as valid parameters, such as\r\n\t//\t\t{includeOutliers:true}.\r\n\t//\r\n\t//\t\t####The *query* parameter\r\n\t//\r\n\t//\t\tThe query may be optional in some data store implementations.\r\n\t//\t\tThe dojo/data/api/Read API does not specify the syntax or semantics\r\n\t//\t\tof the query itself -- each different data store implementation\r\n\t//\t\tmay have its own notion of what a query should look like.\r\n\t//\t\tHowever, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data\r\n\t//\t\tand dojox.data support an object structure query, where the object is a set of\r\n\t//\t\tname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the\r\n\t//\t\tdijit widgets, such as ComboBox assume this to be the case when working with a datastore\r\n\t//\t\twhen they dynamically update the query.  Therefore, for maximum compatibility with dijit\r\n\t//\t\twidgets the recommended query parameter is a key/value object.  That does not mean that the\r\n\t//\t\tthe datastore may not take alternative query forms, such as a simple string, a Date, a number,\r\n\t//\t\tor a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query\r\n\t//\t\tformat.\r\n\t//\r\n\t//\t\tFurther note:  In general for query objects that accept strings as attribute\r\n\t//\t\tvalue matches, the store should also support basic filtering capability, such as *\r\n\t//\t\t(match any character) and ? (match single character).  An example query that is a query object\r\n\t//\t\twould be like: { attrFoo: \"value*\"}.  Which generally means match all items where they have\r\n\t//\t\tan attribute named attrFoo, with a value that starts with 'value'.\r\n\t//\r\n\t//\t\t####The *queryOptions* parameter\r\n\t//\r\n\t//\t\tThe queryOptions parameter is an optional parameter used to specify options that may modify\r\n\t//\t\tthe query in some fashion, such as doing a case insensitive search, or doing a deep search\r\n\t//\t\twhere all items in a hierarchical representation of data are scanned instead of just the root\r\n\t//\t\titems.  It currently defines two options that all datastores should attempt to honor if possible:\r\n\t// |\t{\r\n\t// |\t\tignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.\r\n\t// |\t\tdeep: boolean\t// Whether or not a fetch should do a deep search of items and all child\r\n\t// |\t\t\t\t\t\t// items instead of just root-level items in a datastore.  Default is false.\r\n\t// |\t}\r\n\t//\r\n\t//\t\t####The *onBegin* parameter.\r\n\t//\r\n\t//\t\tfunction(size, request);\r\n\t//\t\tIf an onBegin callback function is provided, the callback function\r\n\t//\t\twill be called just once, before the first onItem callback is called.\r\n\t//\t\tThe onBegin callback function will be passed two arguments, the\r\n\t//\t\tthe total number of items identified and the Request object.  If the total number is\r\n\t//\t\tunknown, then size will be -1.  Note that size is not necessarily the size of the\r\n\t//\t\tcollection of items returned from the query, as the request may have specified to return only a\r\n\t//\t\tsubset of the total set of items through the use of the start and count parameters.\r\n\t//\r\n\t//\t\t####The *onItem* parameter.\r\n\t//\r\n\t//\t\tfunction(item, request);\r\n\t//\r\n\t//\t\tIf an onItem callback function is provided, the callback function\r\n\t//\t\twill be called as each item in the result is received. The callback\r\n\t//\t\tfunction will be passed two arguments: the item itself, and the\r\n\t//\t\tRequest object.\r\n\t//\r\n\t//\t\t####The *onComplete* parameter.\r\n\t//\r\n\t//\t\tfunction(items, request);\r\n\t//\r\n\t//\t\tIf an onComplete callback function is provided, the callback function\r\n\t//\t\twill be called just once, after the last onItem callback is called.\r\n\t//\t\tNote that if the onItem callback is not present, then onComplete will be passed\r\n\t//\t\tan array containing all items which matched the query and the request object.\r\n\t//\t\tIf the onItem callback is present, then onComplete is called as:\r\n\t//\t\tonComplete(null, request).\r\n\t//\r\n\t//\t\t####The *onError* parameter.\r\n\t//\r\n\t//\t\tfunction(errorData, request);\r\n\t//\r\n\t//\t\tIf an onError callback function is provided, the callback function\r\n\t//\t\twill be called if there is any sort of error while attempting to\r\n\t//\t\texecute the query.\r\n\t//\t\tThe onError callback function will be passed two arguments:\r\n\t//\t\tan Error object and the Request object.\r\n\t//\r\n\t//\t\t####The *scope* parameter.\r\n\t//\r\n\t//\t\tIf a scope object is provided, all of the callback functions (onItem,\r\n\t//\t\tonComplete, onError, etc) will be invoked in the context of the scope\r\n\t//\t\tobject.  In the body of the callback function, the value of the \"this\"\r\n\t//\t\tkeyword will be the scope object.   If no scope object is provided,\r\n\t//\t\tthe callback functions will be called in the context of dojo.global().\r\n\t//\t\tFor example, onItem.call(scope, item, request) vs.\r\n\t//\t\tonItem.call(dojo.global(), item, request)\r\n\t//\r\n\t//\t\t####The *start* parameter.\r\n\t//\r\n\t//\t\tIf a start parameter is specified, this is a indication to the datastore to\r\n\t//\t\tonly start returning items once the start number of items have been located and\r\n\t//\t\tskipped.  When this parameter is paired with 'count', the store should be able\r\n\t//\t\tto page across queries with millions of hits by only returning subsets of the\r\n\t//\t\thits for each query\r\n\t//\r\n\t//\t\t####The *count* parameter.\r\n\t//\r\n\t//\t\tIf a count parameter is specified, this is a indication to the datastore to\r\n\t//\t\tonly return up to that many items.  This allows a fetch call that may have\r\n\t//\t\tmillions of item matches to be paired down to something reasonable.\r\n\t//\r\n\t//\t\t####The *sort* parameter.\r\n\t//\r\n\t//\t\tIf a sort parameter is specified, this is a indication to the datastore to\r\n\t//\t\tsort the items in some manner before returning the items.  The array is an array of\r\n\t//\t\tjavascript objects that must conform to the following format to be applied to the\r\n\t//\t\tfetching of items:\r\n\t// |\t{\r\n\t// |\t\tattribute: attribute || attribute-name-string,\r\n\t// |\t\tdescending: true|false;   // Optional.  Default is false.\r\n\t// |\t}\r\n\t//\t\tNote that when comparing attributes, if an item contains no value for the attribute\r\n\t//\t\t(undefined), then it the default ascending sort logic should push it to the bottom\r\n\t//\t\tof the list.  In the descending order case, it such items should appear at the top of the list.\r\n\r\n\trequest = request || {};\r\n\tif(!request.store){\r\n\t\trequest.store = this;\r\n\t}\r\n\r\n\tthis._fetchItems(request, lang.hitch(this, \"fetchHandler\"), lang.hitch(this, \"errorHandler\"));\r\n\treturn request;\t// Object\r\n};\r\n\r\nreturn simpleFetch;\r\n});\r\n"]}