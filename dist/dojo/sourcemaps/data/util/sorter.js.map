{"version":3,"sources":["data/util/sorter.js"],"names":["define","lang","sorter","setObject","basicComparator","a","b","r","undefined","createSortFunction","sortSpec","store","sortAttribute","sortFunctions","attr","dir","comp","s","itemA","itemB","getValue","map","comparatorMap","bc","i","length","attribute","toString","push","rowA","rowB","ret"],"mappings":";;;;;;;AAAAA,QAAQ,oBAAqB,SAASC,GAMtC,IAAIC,KA2FJ,OA1FAD,EAAKE,UAAU,wBAAyBD,GAExCA,EAAOE,gBAAkB,SAAuBC,EACtBC,GAYzB,IAAIC,GAAK,EAYT,OAXS,OAANF,IACFA,OAAIG,GAEI,OAANF,IACFA,OAAIE,GAEFH,GAAKC,EACPC,EAAI,GACIF,EAAIC,GAAU,MAALD,KACjBE,EAAI,GAEEA,GAGRL,EAAOO,mBAAqB,SAA4BC,EAAiCC,GAkBxF,IAWIC,EAXAC,KAEJ,SAASJ,EAAmBK,EAAMC,EAAKC,EAAMC,GAG5C,OAAO,SAASC,EAAOC,GACtB,IAAId,EAAIY,EAAEG,SAASF,EAAOJ,GACtBR,EAAIW,EAAEG,SAASD,EAAOL,GAC1B,OAAOC,EAAMC,EAAKX,EAAEC,IAMtB,IAFA,IAAIe,EAAMV,EAAMW,cACZC,EAAKrB,EAAOE,gBACRoB,EAAI,EAAGA,EAAId,EAASe,OAAQD,IAAI,CAEvC,IAAIV,GADJF,EAAgBF,EAASc,IACAE,UACzB,GAAGZ,EAAK,CACP,IAAIC,EAAOH,EAAwB,YAAK,EAAI,EACxCI,EAAOO,EACRF,IACiB,iBAATP,GAAsB,aAAcA,IAC5CA,EAAOA,EAAKa,YAEdX,EAAOK,EAAIP,IAASS,GAErBV,EAAce,KAAKnB,EAAmBK,EACrCC,EAAKC,EAAML,KAGd,OAAO,SAASkB,EAAMC,GAErB,IADA,IAAIN,EAAE,EACAA,EAAIX,EAAcY,QAAO,CAC9B,IAAIM,EAAMlB,EAAcW,KAAKK,EAAMC,GACnC,GAAW,IAARC,EACF,OAAOA,EAGT,OAAO,IAIF7B","file":"../../../data/util/sorter.js","sourcesContent":["define([\"../../_base/lang\"], function(lang){\r\n\t// module:\r\n\t//\t\tdojo/data/util/sorter\r\n\t// summary:\r\n\t//\t\tTODOC\r\n\r\nvar sorter = {};\r\nlang.setObject(\"dojo.data.util.sorter\", sorter);\r\n\r\nsorter.basicComparator = function(\t/*anything*/ a,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t/*anything*/ b){\r\n\t// summary:\r\n\t//\t\tBasic comparison function that compares if an item is greater or less than another item\r\n\t// description:\r\n\t//\t\treturns 1 if a > b, -1 if a < b, 0 if equal.\r\n\t//\t\t'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.\r\n\t//\t\tAnd compared to each other, null is equivalent to undefined.\r\n\r\n\t//null is a problematic compare, so if null, we set to undefined.\r\n\t//Makes the check logic simple, compact, and consistent\r\n\t//And (null == undefined) === true, so the check later against null\r\n\t//works for undefined and is less bytes.\r\n\tvar r = -1;\r\n\tif(a === null){\r\n\t\ta = undefined;\r\n\t}\r\n\tif(b === null){\r\n\t\tb = undefined;\r\n\t}\r\n\tif(a == b){\r\n\t\tr = 0;\r\n\t}else if(a > b || a == null){\r\n\t\tr = 1;\r\n\t}\r\n\treturn r; //int {-1,0,1}\r\n};\r\n\r\nsorter.createSortFunction = function(\t/* attributes[] */sortSpec, /*dojo/data/api/Read*/ store){\r\n\t// summary:\r\n\t//\t\tHelper function to generate the sorting function based off the list of sort attributes.\r\n\t// description:\r\n\t//\t\tThe sort function creation will look for a property on the store called 'comparatorMap'.  If it exists\r\n\t//\t\tit will look in the mapping for comparisons function for the attributes.  If one is found, it will\r\n\t//\t\tuse it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.\r\n\t//\t\tReturns the sorting function for this particular list of attributes and sorting directions.\r\n\t// sortSpec:\r\n\t//\t\tA JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.\r\n\t//\t\tThe objects should be formatted as follows:\r\n\t// |\t{\r\n\t// |\t\tattribute: \"attributeName-string\" || attribute,\r\n\t// |\t\tdescending: true|false;   // Default is false.\r\n\t// |\t}\r\n\t// store:\r\n\t//\t\tThe datastore object to look up item values from.\r\n\r\n\tvar sortFunctions=[];\r\n\r\n\tfunction createSortFunction(attr, dir, comp, s){\r\n\t\t//Passing in comp and s (comparator and store), makes this\r\n\t\t//function much faster.\r\n\t\treturn function(itemA, itemB){\r\n\t\t\tvar a = s.getValue(itemA, attr);\r\n\t\t\tvar b = s.getValue(itemB, attr);\r\n\t\t\treturn dir * comp(a,b); //int\r\n\t\t};\r\n\t}\r\n\tvar sortAttribute;\r\n\tvar map = store.comparatorMap;\r\n\tvar bc = sorter.basicComparator;\r\n\tfor(var i = 0; i < sortSpec.length; i++){\r\n\t\tsortAttribute = sortSpec[i];\r\n\t\tvar attr = sortAttribute.attribute;\r\n\t\tif(attr){\r\n\t\t\tvar dir = (sortAttribute.descending) ? -1 : 1;\r\n\t\t\tvar comp = bc;\r\n\t\t\tif(map){\r\n\t\t\t\tif(typeof attr !== \"string\" && (\"toString\" in attr)){\r\n\t\t\t\t\t attr = attr.toString();\r\n\t\t\t\t}\r\n\t\t\t\tcomp = map[attr] || bc;\r\n\t\t\t}\r\n\t\t\tsortFunctions.push(createSortFunction(attr,\r\n\t\t\t\tdir, comp, store));\r\n\t\t}\r\n\t}\r\n\treturn function(rowA, rowB){\r\n\t\tvar i=0;\r\n\t\twhile(i < sortFunctions.length){\r\n\t\t\tvar ret = sortFunctions[i++](rowA, rowB);\r\n\t\t\tif(ret !== 0){\r\n\t\t\t\treturn ret;//int\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0; //int\r\n\t}; // Function\r\n};\r\n\r\nreturn sorter;\r\n});\r\n"]}