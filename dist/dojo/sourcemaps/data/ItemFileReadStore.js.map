{"version":3,"sources":["data/ItemFileReadStore.js"],"names":["define","kernel","lang","declare","array","xhr","Evented","filterUtil","simpleFetch","dateStamp","ItemFileReadStore","constructor","keywordParameters","this","_arrayOfAllItems","_arrayOfTopLevelItems","_loadFinished","_jsonFileUrl","url","_ccUrl","_jsonData","data","_datatypeMap","typeMap","type","Date","deserialize","value","fromISOString","_features","dojo.data.api.Read","dojo.data.api.Identity","_itemsByIdentity","_storeRefPropName","_itemNumPropName","_rootItemPropName","_reverseRefMap","_loadInProgress","_queuedFetches","undefined","urlPreventCache","hierarchical","clearOnClose","failOk","_assertIsItem","item","isItem","Error","declaredClass","_assertIsAttribute","attribute","getValue","defaultValue","values","getValues","length","slice","getAttributes","attributes","key","push","hasAttribute","containsValue","regexp","patternToRegExp","_containsValue","some","possibleValue","isObject","toString","match","something","isItemLoaded","loadItem","keywordArgs","getFeatures","getLabel","_labelAttr","getLabelAttributes","filter","requestArgs","arrayOfItems","findCallback","i","items","query","ignoreCase","queryOptions","regexpList","RegExp","candidateItem","_fetchItems","errorCallback","self","_getItemsArray","deprecated","args","hitch","getArgs","handleAs","preventCache","getHandler","get","addCallback","_getItemsFromLoadedData","_handleQueuedFetches","e","addErrback","error","oldAbort","abort","df","fired","cancel","call","fData","delayedQuery","delayedFilter","delayedFindCallback","fetchItemByIdentity","deep","close","request","console","debug","dataObject","addingArrays","valueIsAnItem","aValue","isArray","isFunction","Object","_reference","_type","_value","addItemAndSubItemsToArrayOfAllItems","anItem","valueForAttribute","valueArray","k","singleValue","label","arrayOfValues","allAttributeNames","identifier","identity","hasOwnProperty","Number","j","mappingObj","referenceDescription","found","refKey","_getItemByIdentity","referenceIntegrity","refItem","_addReferenceToMap","parentItem","getIdentity","scope","onItem","global","onError","getIdentityAttributes","_forceLoad","sync","log","extend"],"mappings":"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","file":"../../data/ItemFileReadStore.js","sourcesContent":["define([\"../_base/kernel\", \"../_base/lang\", \"../_base/declare\", \"../_base/array\", \"../_base/xhr\",\r\n\t\"../Evented\", \"./util/filter\", \"./util/simpleFetch\", \"../date/stamp\"\r\n], function(kernel, lang, declare, array, xhr, Evented, filterUtil, simpleFetch, dateStamp){\r\n\r\n// module:\r\n//\t\tdojo/data/ItemFileReadStore\r\n\r\nvar ItemFileReadStore = declare(\"dojo.data.ItemFileReadStore\", [Evented],{\r\n\t// summary:\r\n\t//\t\tThe ItemFileReadStore implements the dojo/data/api/Read API and reads\r\n\t//\t\tdata from JSON files that have contents in this format --\r\n\t// |\t{ items: [\r\n\t// |\t\t{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},\r\n\t// |\t\t{ name:'Fozzie Bear', wears:['hat', 'tie']},\r\n\t// |\t\t{ name:'Miss Piggy', pets:'Foo-Foo'}\r\n\t// |\t]}\r\n\t//\t\tNote that it can also contain an 'identifier' property that specified which attribute on the items\r\n\t//\t\tin the array of items that acts as the unique identifier for that item.\r\n\r\n\tconstructor: function(/* Object */ keywordParameters){\r\n\t\t// summary:\r\n\t\t//\t\tconstructor\r\n\t\t// keywordParameters:\r\n\t\t//\t\t{url: String} {data: jsonObject} {typeMap: object}\r\n\t\t//\t\tThe structure of the typeMap object is as follows:\r\n\t\t// |\t{\r\n\t\t// |\t\ttype0: function || object,\r\n\t\t// |\t\ttype1: function || object,\r\n\t\t// |\t\t...\r\n\t\t// |\t\ttypeN: function || object\r\n\t\t// |\t}\r\n\t\t//\t\tWhere if it is a function, it is assumed to be an object constructor that takes the\r\n\t\t//\t\tvalue of _value as the initialization parameters.  If it is an object, then it is assumed\r\n\t\t//\t\tto be an object of general form:\r\n\t\t// |\t{\r\n\t\t// |\t\ttype: function, //constructor.\r\n\t\t// |\t\tdeserialize:\tfunction(value) //The function that parses the value and constructs the object defined by type appropriately.\r\n\t\t// |\t}\r\n\r\n\t\tthis._arrayOfAllItems = [];\r\n\t\tthis._arrayOfTopLevelItems = [];\r\n\t\tthis._loadFinished = false;\r\n\t\tthis._jsonFileUrl = keywordParameters.url;\r\n\t\tthis._ccUrl = keywordParameters.url;\r\n\t\tthis.url = keywordParameters.url;\r\n\t\tthis._jsonData = keywordParameters.data;\r\n\t\tthis.data = null;\r\n\t\tthis._datatypeMap = keywordParameters.typeMap || {};\r\n\t\tif(!this._datatypeMap['Date']){\r\n\t\t\t//If no default mapping for dates, then set this as default.\r\n\t\t\t//We use the dojo/date/stamp here because the ISO format is the 'dojo way'\r\n\t\t\t//of generically representing dates.\r\n\t\t\tthis._datatypeMap['Date'] = {\r\n\t\t\t\ttype: Date,\r\n\t\t\t\tdeserialize: function(value){\r\n\t\t\t\t\treturn dateStamp.fromISOString(value);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\tthis._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};\r\n\t\tthis._itemsByIdentity = null;\r\n\t\tthis._storeRefPropName = \"_S\"; // Default name for the store reference to attach to every item.\r\n\t\tthis._itemNumPropName = \"_0\"; // Default Item Id for isItem to attach to every item.\r\n\t\tthis._rootItemPropName = \"_RI\"; // Default Item Id for isItem to attach to every item.\r\n\t\tthis._reverseRefMap = \"_RRM\"; // Default attribute for constructing a reverse reference map for use with reference integrity\r\n\t\tthis._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.\r\n\t\tthis._queuedFetches = [];\r\n\t\tif(keywordParameters.urlPreventCache !== undefined){\r\n\t\t\tthis.urlPreventCache = keywordParameters.urlPreventCache?true:false;\r\n\t\t}\r\n\t\tif(keywordParameters.hierarchical !== undefined){\r\n\t\t\tthis.hierarchical = keywordParameters.hierarchical?true:false;\r\n\t\t}\r\n\t\tif(keywordParameters.clearOnClose){\r\n\t\t\tthis.clearOnClose = true;\r\n\t\t}\r\n\t\tif(\"failOk\" in keywordParameters){\r\n\t\t\tthis.failOk = keywordParameters.failOk?true:false;\r\n\t\t}\r\n\t},\r\n\r\n\turl: \"\",\t// use \"\" rather than undefined for the benefit of the parser (#3539)\r\n\r\n\t//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload\r\n\t//when clearOnClose and close is used.\r\n\t_ccUrl: \"\",\r\n\r\n\tdata: null,\t// define this so that the parser can populate it\r\n\r\n\ttypeMap: null, //Define so parser can populate.\r\n\r\n\t// clearOnClose: Boolean\r\n\t//\t\tParameter to allow users to specify if a close call should force a reload or not.\r\n\t//\t\tBy default, it retains the old behavior of not clearing if close is called.  But\r\n\t//\t\tif set true, the store will be reset to default state.  Note that by doing this,\r\n\t//\t\tall item handles will become invalid and a new fetch must be issued.\r\n\tclearOnClose: false,\r\n\r\n\t// urlPreventCache: Boolean\r\n\t//\t\tParameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.\r\n\t//\t\tNote this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.\r\n\t//\t\tAdded for tracker: #6072\r\n\turlPreventCache: false,\r\n\r\n\t// failOk: Boolean\r\n\t//\t\tParameter for specifying that it is OK for the xhrGet call to fail silently.\r\n\tfailOk: false,\r\n\r\n\t// hierarchical: Boolean\r\n\t//\t\tParameter to indicate to process data from the url as hierarchical\r\n\t//\t\t(data items can contain other data items in js form).  Default is true\r\n\t//\t\tfor backwards compatibility.  False means only root items are processed\r\n\t//\t\tas items, all child objects outside of type-mapped objects and those in\r\n\t//\t\tspecific reference format, are left straight JS data objects.\r\n\thierarchical: true,\r\n\r\n\t_assertIsItem: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tThis function tests whether the item passed in is indeed an item in the store.\r\n\t\t// item:\r\n\t\t//\t\tThe item to test for being contained by the store.\r\n\t\tif(!this.isItem(item)){\r\n\t\t\tthrow new Error(this.declaredClass + \": Invalid item argument.\");\r\n\t\t}\r\n\t},\r\n\r\n\t_assertIsAttribute: function(/* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tThis function tests whether the item passed in is indeed a valid 'attribute' like type for the store.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to test for being contained by the store.\r\n\t\tif(typeof attribute !== \"string\"){\r\n\t\t\tthrow new Error(this.declaredClass + \": Invalid attribute argument.\");\r\n\t\t}\r\n\t},\r\n\r\n\tgetValue: function(\t/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t   /* attribute-name-string */ attribute,\r\n\t\t\t\t\t\t   /* value? */ defaultValue){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValue()\r\n\t\tvar values = this.getValues(item, attribute);\r\n\t\treturn (values.length > 0)?values[0]:defaultValue; // mixed\r\n\t},\r\n\r\n\tgetValues: function(/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t/* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValues()\r\n\r\n\t\tthis._assertIsItem(item);\r\n\t\tthis._assertIsAttribute(attribute);\r\n\t\t// Clone it before returning.  refs: #10474\r\n\t\treturn (item[attribute] || []).slice(0); // Array\r\n\t},\r\n\r\n\tgetAttributes: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getAttributes()\r\n\t\tthis._assertIsItem(item);\r\n\t\tvar attributes = [];\r\n\t\tfor(var key in item){\r\n\t\t\t// Save off only the real item attributes, not the special id marks for O(1) isItem.\r\n\t\t\tif((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){\r\n\t\t\t\tattributes.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn attributes; // Array\r\n\t},\r\n\r\n\thasAttribute: function(\t/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t\t   /* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.hasAttribute()\r\n\t\tthis._assertIsItem(item);\r\n\t\tthis._assertIsAttribute(attribute);\r\n\t\treturn (attribute in item);\r\n\t},\r\n\r\n\tcontainsValue: function(/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t\t/* attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t/* anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.containsValue()\r\n\t\tvar regexp = undefined;\r\n\t\tif(typeof value === \"string\"){\r\n\t\t\tregexp = filterUtil.patternToRegExp(value, false);\r\n\t\t}\r\n\t\treturn this._containsValue(item, attribute, value, regexp); //boolean.\r\n\t},\r\n\r\n\t_containsValue: function(\t/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t\t\t /* attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t\t /* anything */ value,\r\n\t\t\t\t\t\t\t\t /* RegExp?*/ regexp){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.\r\n\t\t// description:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.  This\r\n\t\t//\t\tfunction allows for denoting if the comparison should be case sensitive for\r\n\t\t//\t\tstrings or not (for handling filtering cases where string case should not matter)\r\n\t\t// item:\r\n\t\t//\t\tThe data item to examine for attribute values.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to inspect.\r\n\t\t// value:\r\n\t\t//\t\tThe value to match.\r\n\t\t// regexp:\r\n\t\t//\t\tOptional regular expression generated off value if value was of string type to handle wildcarding.\r\n\t\t//\t\tIf present and attribute values are string, then it can be used for comparison instead of 'value'\r\n\t\treturn array.some(this.getValues(item, attribute), function(possibleValue){\r\n\t\t\tif(possibleValue !== null && !lang.isObject(possibleValue) && regexp){\r\n\t\t\t\tif(possibleValue.toString().match(regexp)){\r\n\t\t\t\t\treturn true; // Boolean\r\n\t\t\t\t}\r\n\t\t\t}else if(value === possibleValue){\r\n\t\t\t\treturn true; // Boolean\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tisItem: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItem()\r\n\t\tif(something && something[this._storeRefPropName] === this){\r\n\t\t\tif(this._arrayOfAllItems[something[this._itemNumPropName]] === something){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; // Boolean\r\n\t},\r\n\r\n\tisItemLoaded: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItemLoaded()\r\n\t\treturn this.isItem(something); //boolean\r\n\t},\r\n\r\n\tloadItem: function(/* object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.loadItem()\r\n\t\tthis._assertIsItem(keywordArgs.item);\r\n\t},\r\n\r\n\tgetFeatures: function(){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getFeatures()\r\n\t\treturn this._features; //Object\r\n\t},\r\n\r\n\tgetLabel: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabel()\r\n\t\tif(this._labelAttr && this.isItem(item)){\r\n\t\t\treturn this.getValue(item,this._labelAttr); //String\r\n\t\t}\r\n\t\treturn undefined; //undefined\r\n\t},\r\n\r\n\tgetLabelAttributes: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabelAttributes()\r\n\t\tif(this._labelAttr){\r\n\t\t\treturn [this._labelAttr]; //array\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\tfilter: function(/* Object */ requestArgs, /* item[] */ arrayOfItems, /* Function */ findCallback){\r\n\t\t// summary:\r\n\t\t//\t\tThis method handles the basic filtering needs for ItemFile* based stores.\r\n\t\tvar items = [],\r\n\t\t\ti, key;\r\n\r\n\t\tif(requestArgs.query){\r\n\t\t\tvar value,\r\n\t\t\t\tignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;\r\n\r\n\t\t\t//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the\r\n\t\t\t//same value for each item examined.  Much more efficient.\r\n\t\t\tvar regexpList = {};\r\n\t\t\tfor(key in requestArgs.query){\r\n\t\t\t\tvalue = requestArgs.query[key];\r\n\t\t\t\tif(typeof value === \"string\"){\r\n\t\t\t\t\tregexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t}else if(value instanceof RegExp){\r\n\t\t\t\t\tregexpList[key] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < arrayOfItems.length; ++i){\r\n\t\t\t\tvar match = true;\r\n\t\t\t\tvar candidateItem = arrayOfItems[i];\r\n\t\t\t\tif(candidateItem === null){\r\n\t\t\t\t\tmatch = false;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(key in requestArgs.query){\r\n\t\t\t\t\t\tvalue = requestArgs.query[key];\r\n\t\t\t\t\t\tif(!this._containsValue(candidateItem, key, value, regexpList[key])){\r\n\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(match){\r\n\t\t\t\t\titems.push(candidateItem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfindCallback(items, requestArgs);\r\n\t\t}else{\r\n\t\t\t// We want a copy to pass back in case the parent wishes to sort the array.\r\n\t\t\t// We shouldn't allow resort of the internal list, so that multiple callers\r\n\t\t\t// can get lists and sort without affecting each other.  We also need to\r\n\t\t\t// filter out any null values that have been left as a result of deleteItem()\r\n\t\t\t// calls in ItemFileWriteStore.\r\n\t\t\tfor(i = 0; i < arrayOfItems.length; ++i){\r\n\t\t\t\tvar item = arrayOfItems[i];\r\n\t\t\t\tif(item !== null){\r\n\t\t\t\t\titems.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfindCallback(items, requestArgs);\r\n\t\t}\r\n\t},\r\n\r\n\t_fetchItems: function(\t/* Object */ keywordArgs,\r\n\t\t\t\t\t\t\t  /* Function */ findCallback,\r\n\t\t\t\t\t\t\t  /* Function */ errorCallback){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/util.simpleFetch.fetch()\r\n\t\tvar self = this;\r\n\r\n\t\tif(this._loadFinished){\r\n\t\t\tthis.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);\r\n\t\t}else{\r\n\t\t\t//Do a check on the JsonFileUrl and crosscheck it.\r\n\t\t\t//If it doesn't match the cross-check, it needs to be updated\r\n\t\t\t//This allows for either url or _jsonFileUrl to he changed to\r\n\t\t\t//reset the store load location.  Done this way for backwards\r\n\t\t\t//compatibility.  People use _jsonFileUrl (even though officially\r\n\t\t\t//private.\r\n\t\t\tif(this._jsonFileUrl !== this._ccUrl){\r\n\t\t\t\tkernel.deprecated(this.declaredClass + \": \",\r\n\t\t\t\t\t\"To change the url, set the url property of the store,\" +\r\n\t\t\t\t\t\t\" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0\");\r\n\t\t\t\tthis._ccUrl = this._jsonFileUrl;\r\n\t\t\t\tthis.url = this._jsonFileUrl;\r\n\t\t\t}else if(this.url !== this._ccUrl){\r\n\t\t\t\tthis._jsonFileUrl = this.url;\r\n\t\t\t\tthis._ccUrl = this.url;\r\n\t\t\t}\r\n\r\n\t\t\t//See if there was any forced reset of data.\r\n\t\t\tif(this.data != null){\r\n\t\t\t\tthis._jsonData = this.data;\r\n\t\t\t\tthis.data = null;\r\n\t\t\t}\r\n\r\n\t\t\tif(this._jsonFileUrl){\r\n\t\t\t\t//If fetches come in before the loading has finished, but while\r\n\t\t\t\t//a load is in progress, we have to defer the fetching to be\r\n\t\t\t\t//invoked in the callback.\r\n\t\t\t\tif(this._loadInProgress){\r\n\t\t\t\t\tthis._queuedFetches.push({args: keywordArgs, filter: lang.hitch(self, \"filter\"), findCallback: lang.hitch(self, findCallback)});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\turl: self._jsonFileUrl,\r\n\t\t\t\t\t\thandleAs: \"json-comment-optional\",\r\n\t\t\t\t\t\tpreventCache: this.urlPreventCache,\r\n\t\t\t\t\t\tfailOk: this.failOk\r\n\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tself._getItemsFromLoadedData(data);\r\n\t\t\t\t\t\t\tself._loadFinished = true;\r\n\t\t\t\t\t\t\tself._loadInProgress = false;\r\n\r\n\t\t\t\t\t\t\tself.filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions), findCallback);\r\n\t\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\t\tself._loadFinished = true;\r\n\t\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\t\terrorCallback(e, keywordArgs);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\terrorCallback(error, keywordArgs);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t//Wire up the cancel to abort of the request\r\n\t\t\t\t\t//This call cancel on the deferred if it hasn't been called\r\n\t\t\t\t\t//yet and then will chain to the simple abort of the\r\n\t\t\t\t\t//simpleFetch keywordArgs\r\n\t\t\t\t\tvar oldAbort = null;\r\n\t\t\t\t\tif(keywordArgs.abort){\r\n\t\t\t\t\t\toldAbort = keywordArgs.abort;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tkeywordArgs.abort = function(){\r\n\t\t\t\t\t\tvar df = getHandler;\r\n\t\t\t\t\t\tif(df && df.fired === -1){\r\n\t\t\t\t\t\t\tdf.cancel();\r\n\t\t\t\t\t\t\tdf = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(oldAbort){\r\n\t\t\t\t\t\t\toldAbort.call(keywordArgs);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}else if(this._jsonData){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis._loadFinished = true;\r\n\t\t\t\t\tthis._getItemsFromLoadedData(this._jsonData);\r\n\t\t\t\t\tthis._jsonData = null;\r\n\t\t\t\t\tself.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\terrorCallback(e, keywordArgs);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\terrorCallback(new Error(this.declaredClass + \": No JSON source data was provided as either URL or a nested Javascript object.\"), keywordArgs);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_handleQueuedFetches: function(){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to execute delayed request in the store.\r\n\t\t\r\n\t\t//Execute any deferred fetches now.\r\n\t\tif(this._queuedFetches.length > 0){\r\n\t\t\tfor(var i = 0; i < this._queuedFetches.length; i++){\r\n\t\t\t\tvar fData = this._queuedFetches[i],\r\n\t\t\t\t\tdelayedQuery = fData.args,\r\n\t\t\t\t\tdelayedFilter = fData.filter,\r\n\t\t\t\t\tdelayedFindCallback = fData.findCallback;\r\n\t\t\t\tif(delayedFilter){\r\n\t\t\t\t\tdelayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions), delayedFindCallback);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.fetchItemByIdentity(delayedQuery);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._queuedFetches = [];\r\n\t\t}\r\n\t},\r\n\r\n\t_getItemsArray: function(/*object?*/queryOptions){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to determine which list of items to search over.\r\n\t\t// queryOptions: The query options parameter, if any.\r\n\t\tif(queryOptions && queryOptions.deep){\r\n\t\t\treturn this._arrayOfAllItems;\r\n\t\t}\r\n\t\treturn this._arrayOfTopLevelItems;\r\n\t},\r\n\r\n\tclose: function(/*dojo/data/api/Request|Object?*/ request){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.close()\r\n\t\tif(this.clearOnClose &&\r\n\t\t\tthis._loadFinished &&\r\n\t\t\t!this._loadInProgress){\r\n\t\t\t//Reset all internalsback to default state.  This will force a reload\r\n\t\t\t//on next fetch.  This also checks that the data or url param was set\r\n\t\t\t//so that the store knows it can get data.  Without one of those being set,\r\n\t\t\t//the next fetch will trigger an error.\r\n\r\n\t\t\tif(((this._jsonFileUrl == \"\" || this._jsonFileUrl == null) &&\r\n\t\t\t\t(this.url == \"\" || this.url == null)\r\n\t\t\t\t) && this.data == null){\r\n\t\t\t\tconsole.debug(this.declaredClass + \": WARNING!  Data reload \" +\r\n\t\t\t\t\t\" information has not been provided.\" +\r\n\t\t\t\t\t\"  Please set 'url' or 'data' to the appropriate value before\" +\r\n\t\t\t\t\t\" the next fetch\");\r\n\t\t\t}\r\n\t\t\tthis._arrayOfAllItems = [];\r\n\t\t\tthis._arrayOfTopLevelItems = [];\r\n\t\t\tthis._loadFinished = false;\r\n\t\t\tthis._itemsByIdentity = null;\r\n\t\t\tthis._loadInProgress = false;\r\n\t\t\tthis._queuedFetches = [];\r\n\t\t}\r\n\t},\r\n\r\n\t_getItemsFromLoadedData: function(/* Object */ dataObject){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to parse the loaded data into item format and build the internal items array.\r\n\t\t// description:\r\n\t\t//\t\tFunction to parse the loaded data into item format and build the internal items array.\r\n\t\t// dataObject:\r\n\t\t//\t\tThe JS data object containing the raw data to convery into item format.\r\n\t\t// returns: Array\r\n\t\t//\t\tArray of items in store item format.\r\n\r\n\t\t// First, we define a couple little utility functions...\r\n\t\tvar addingArrays = false,\r\n\t\t\tself = this;\r\n\r\n\t\tfunction valueIsAnItem(/* anything */ aValue){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGiven any sort of value that could be in the raw json data,\r\n\t\t\t//\t\treturn true if we should interpret the value as being an\r\n\t\t\t//\t\titem itself, rather than a literal value or a reference.\r\n\t\t\t// example:\r\n\t\t\t// \t|\tfalse == valueIsAnItem(\"Kermit\");\r\n\t\t\t// \t|\tfalse == valueIsAnItem(42);\r\n\t\t\t// \t|\tfalse == valueIsAnItem(new Date());\r\n\t\t\t// \t|\tfalse == valueIsAnItem({_type:'Date', _value:'1802-05-14'});\r\n\t\t\t// \t|\tfalse == valueIsAnItem({_reference:'Kermit'});\r\n\t\t\t// \t|\ttrue == valueIsAnItem({name:'Kermit', color:'green'});\r\n\t\t\t// \t|\ttrue == valueIsAnItem({iggy:'pop'});\r\n\t\t\t// \t|\ttrue == valueIsAnItem({foo:42});\r\n\t\t\treturn (aValue !== null) &&\r\n\t\t\t\t(typeof aValue === \"object\") &&\r\n\t\t\t\t(!lang.isArray(aValue) || addingArrays) &&\r\n\t\t\t\t(!lang.isFunction(aValue)) &&\r\n\t\t\t\t(aValue.constructor == Object || lang.isArray(aValue)) &&\r\n\t\t\t\t(typeof aValue._reference === \"undefined\") &&\r\n\t\t\t\t(typeof aValue._type === \"undefined\") &&\r\n\t\t\t\t(typeof aValue._value === \"undefined\") &&\r\n\t\t\t\tself.hierarchical;\r\n\t\t}\r\n\r\n\t\tfunction addItemAndSubItemsToArrayOfAllItems(/* dojo/data/api/Item */ anItem){\r\n\t\t\tself._arrayOfAllItems.push(anItem);\r\n\t\t\tfor(var attribute in anItem){\r\n\t\t\t\tvar valueForAttribute = anItem[attribute];\r\n\t\t\t\tif(valueForAttribute){\r\n\t\t\t\t\tif(lang.isArray(valueForAttribute)){\r\n\t\t\t\t\t\tvar valueArray = valueForAttribute;\r\n\t\t\t\t\t\tfor(var k = 0; k < valueArray.length; ++k){\r\n\t\t\t\t\t\t\tvar singleValue = valueArray[k];\r\n\t\t\t\t\t\t\tif(valueIsAnItem(singleValue)){\r\n\t\t\t\t\t\t\t\taddItemAndSubItemsToArrayOfAllItems(singleValue);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(valueIsAnItem(valueForAttribute)){\r\n\t\t\t\t\t\t\taddItemAndSubItemsToArrayOfAllItems(valueForAttribute);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._labelAttr = dataObject.label;\r\n\r\n\t\t// We need to do some transformations to convert the data structure\r\n\t\t// that we read from the file into a format that will be convenient\r\n\t\t// to work with in memory.\r\n\r\n\t\t// Step 1: Walk through the object hierarchy and build a list of all items\r\n\t\tvar i,\r\n\t\t\titem;\r\n\t\tthis._arrayOfAllItems = [];\r\n\t\tthis._arrayOfTopLevelItems = dataObject.items;\r\n\r\n\t\tfor(i = 0; i < this._arrayOfTopLevelItems.length; ++i){\r\n\t\t\titem = this._arrayOfTopLevelItems[i];\r\n\t\t\tif(lang.isArray(item)){\r\n\t\t\t\taddingArrays = true;\r\n\t\t\t}\r\n\t\t\taddItemAndSubItemsToArrayOfAllItems(item);\r\n\t\t\titem[this._rootItemPropName]=true;\r\n\t\t}\r\n\r\n\t\t// Step 2: Walk through all the attribute values of all the items,\r\n\t\t// and replace single values with arrays.  For example, we change this:\r\n\t\t//\t\t{ name:'Miss Piggy', pets:'Foo-Foo'}\r\n\t\t// into this:\r\n\t\t//\t\t{ name:['Miss Piggy'], pets:['Foo-Foo']}\r\n\t\t//\r\n\t\t// We also store the attribute names so we can validate our store\r\n\t\t// reference and item id special properties for the O(1) isItem\r\n\t\tvar allAttributeNames = {},\r\n\t\t\tkey;\r\n\r\n\t\tfor(i = 0; i < this._arrayOfAllItems.length; ++i){\r\n\t\t\titem = this._arrayOfAllItems[i];\r\n\t\t\tfor(key in item){\r\n\t\t\t\tif(key !== this._rootItemPropName){\r\n\t\t\t\t\tvar value = item[key];\r\n\t\t\t\t\tif(value !== null){\r\n\t\t\t\t\t\tif(!lang.isArray(value)){\r\n\t\t\t\t\t\t\titem[key] = [value];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\titem[key] = [null];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tallAttributeNames[key]=key;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName\r\n\t\t// This should go really fast, it will generally never even run the loop.\r\n\t\twhile(allAttributeNames[this._storeRefPropName]){\r\n\t\t\tthis._storeRefPropName += \"_\";\r\n\t\t}\r\n\t\twhile(allAttributeNames[this._itemNumPropName]){\r\n\t\t\tthis._itemNumPropName += \"_\";\r\n\t\t}\r\n\t\twhile(allAttributeNames[this._reverseRefMap]){\r\n\t\t\tthis._reverseRefMap += \"_\";\r\n\t\t}\r\n\r\n\t\t// Step 4: Some data files specify an optional 'identifier', which is\r\n\t\t// the name of an attribute that holds the identity of each item.\r\n\t\t// If this data file specified an identifier attribute, then build a\r\n\t\t// hash table of items keyed by the identity of the items.\r\n\t\tvar arrayOfValues;\r\n\r\n\t\tvar identifier = dataObject.identifier;\r\n\t\tif(identifier){\r\n\t\t\tthis._itemsByIdentity = {};\r\n\t\t\tthis._features['dojo.data.api.Identity'] = identifier;\r\n\t\t\tfor(i = 0; i < this._arrayOfAllItems.length; ++i){\r\n\t\t\t\titem = this._arrayOfAllItems[i];\r\n\t\t\t\tarrayOfValues = item[identifier];\r\n\t\t\t\tvar identity = arrayOfValues[0];\r\n\t\t\t\tif(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){\r\n\t\t\t\t\tthis._itemsByIdentity[identity] = item;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(this._jsonFileUrl){\r\n\t\t\t\t\t\tthrow new Error(this.declaredClass + \":  The json data as specified by: [\" + this._jsonFileUrl + \"] is malformed.  Items within the list have identifier: [\" + identifier + \"].  Value collided: [\" + identity + \"]\");\r\n\t\t\t\t\t}else if(this._jsonData){\r\n\t\t\t\t\t\tthrow new Error(this.declaredClass + \":  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [\" + identifier + \"].  Value collided: [\" + identity + \"]\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tthis._features['dojo.data.api.Identity'] = Number;\r\n\t\t}\r\n\r\n\t\t// Step 5: Walk through all the items, and set each item's properties\r\n\t\t// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.\r\n\t\tfor(i = 0; i < this._arrayOfAllItems.length; ++i){\r\n\t\t\titem = this._arrayOfAllItems[i];\r\n\t\t\titem[this._storeRefPropName] = this;\r\n\t\t\titem[this._itemNumPropName] = i;\r\n\t\t}\r\n\r\n\t\t// Step 6: We walk through all the attribute values of all the items,\r\n\t\t// looking for type/value literals and item-references.\r\n\t\t//\r\n\t\t// We replace item-references with pointers to items.  For example, we change:\r\n\t\t//\t\t{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }\r\n\t\t// into this:\r\n\t\t//\t\t{ name:['Kermit'], friends:[miss_piggy] }\r\n\t\t// (where miss_piggy is the object representing the 'Miss Piggy' item).\r\n\t\t//\r\n\t\t// We replace type/value pairs with typed-literals.  For example, we change:\r\n\t\t//\t\t{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }\r\n\t\t// into this:\r\n\t\t//\t\t{ name:['Kermit'], born:(new Date(1918, 6, 18)) }\r\n\t\t//\r\n\t\t// We also generate the associate map for all items for the O(1) isItem function.\r\n\t\tfor(i = 0; i < this._arrayOfAllItems.length; ++i){\r\n\t\t\titem = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }\r\n\t\t\tfor(key in item){\r\n\t\t\t\tarrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]\r\n\t\t\t\tfor(var j = 0; j < arrayOfValues.length; ++j){\r\n\t\t\t\t\tvalue = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}\r\n\t\t\t\t\tif(value !== null && typeof value == \"object\"){\r\n\t\t\t\t\t\tif((\"_type\" in value) && (\"_value\" in value)){\r\n\t\t\t\t\t\t\tvar type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'\r\n\t\t\t\t\t\t\tvar mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}\r\n\t\t\t\t\t\t\tif(!mappingObj){\r\n\t\t\t\t\t\t\t\tthrow new Error(\"dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '\" + type + \"'\");\r\n\t\t\t\t\t\t\t}else if(lang.isFunction(mappingObj)){\r\n\t\t\t\t\t\t\t\tarrayOfValues[j] = new mappingObj(value._value);\r\n\t\t\t\t\t\t\t}else if(lang.isFunction(mappingObj.deserialize)){\r\n\t\t\t\t\t\t\t\tarrayOfValues[j] = mappingObj.deserialize(value._value);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tthrow new Error(\"dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(value._reference){\r\n\t\t\t\t\t\t\tvar referenceDescription = value._reference; // example: {name:'Miss Piggy'}\r\n\t\t\t\t\t\t\tif(!lang.isObject(referenceDescription)){\r\n\t\t\t\t\t\t\t\t// example: 'Miss Piggy'\r\n\t\t\t\t\t\t\t\t// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}\r\n\t\t\t\t\t\t\t\tarrayOfValues[j] = this._getItemByIdentity(referenceDescription);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t// example: {name:'Miss Piggy'}\r\n\t\t\t\t\t\t\t\t// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }\r\n\t\t\t\t\t\t\t\tfor(var k = 0; k < this._arrayOfAllItems.length; ++k){\r\n\t\t\t\t\t\t\t\t\tvar candidateItem = this._arrayOfAllItems[k],\r\n\t\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t\tfor(var refKey in referenceDescription){\r\n\t\t\t\t\t\t\t\t\t\tif(candidateItem[refKey] != referenceDescription[refKey]){\r\n\t\t\t\t\t\t\t\t\t\t\tfound = false;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif(found){\r\n\t\t\t\t\t\t\t\t\t\tarrayOfValues[j] = candidateItem;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(this.referenceIntegrity){\r\n\t\t\t\t\t\t\t\tvar refItem = arrayOfValues[j];\r\n\t\t\t\t\t\t\t\tif(this.isItem(refItem)){\r\n\t\t\t\t\t\t\t\t\tthis._addReferenceToMap(refItem, item, key);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(this.isItem(value)){\r\n\t\t\t\t\t\t\t//It's a child item (not one referenced through _reference).\r\n\t\t\t\t\t\t\t//We need to treat this as a referenced item, so it can be cleaned up\r\n\t\t\t\t\t\t\t//in a write store easily.\r\n\t\t\t\t\t\t\tif(this.referenceIntegrity){\r\n\t\t\t\t\t\t\t\tthis._addReferenceToMap(value, item, key);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tMethod to add an reference map entry for an item and attribute.\r\n\t\t// description:\r\n\t\t//\t\tMethod to add an reference map entry for an item and attribute.\r\n\t\t// refItem:\r\n\t\t//\t\tThe item that is referenced.\r\n\t\t// parentItem:\r\n\t\t//\t\tThe item that holds the new reference to refItem.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute on parentItem that contains the new reference.\r\n\r\n\t\t//Stub function, does nothing.  Real processing is in ItemFileWriteStore.\r\n\t},\r\n\r\n\tgetIdentity: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentity()\r\n\t\tvar identifier = this._features['dojo.data.api.Identity'];\r\n\t\tif(identifier === Number){\r\n\t\t\treturn item[this._itemNumPropName]; // Number\r\n\t\t}else{\r\n\t\t\tvar arrayOfValues = item[identifier];\r\n\t\t\tif(arrayOfValues){\r\n\t\t\t\treturn arrayOfValues[0]; // Object|String\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null; // null\r\n\t},\r\n\r\n\tfetchItemByIdentity: function(/* Object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.fetchItemByIdentity()\r\n\r\n\t\t// Hasn't loaded yet, we have to trigger the load.\r\n\t\tvar item,\r\n\t\t\tscope;\r\n\t\tif(!this._loadFinished){\r\n\t\t\tvar self = this;\r\n\t\t\t//Do a check on the JsonFileUrl and crosscheck it.\r\n\t\t\t//If it doesn't match the cross-check, it needs to be updated\r\n\t\t\t//This allows for either url or _jsonFileUrl to he changed to\r\n\t\t\t//reset the store load location.  Done this way for backwards\r\n\t\t\t//compatibility.  People use _jsonFileUrl (even though officially\r\n\t\t\t//private.\r\n\t\t\tif(this._jsonFileUrl !== this._ccUrl){\r\n\t\t\t\tkernel.deprecated(this.declaredClass + \": \",\r\n\t\t\t\t\t\"To change the url, set the url property of the store,\" +\r\n\t\t\t\t\t\t\" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0\");\r\n\t\t\t\tthis._ccUrl = this._jsonFileUrl;\r\n\t\t\t\tthis.url = this._jsonFileUrl;\r\n\t\t\t}else if(this.url !== this._ccUrl){\r\n\t\t\t\tthis._jsonFileUrl = this.url;\r\n\t\t\t\tthis._ccUrl = this.url;\r\n\t\t\t}\r\n\r\n\t\t\t//See if there was any forced reset of data.\r\n\t\t\tif(this.data != null && this._jsonData == null){\r\n\t\t\t\tthis._jsonData = this.data;\r\n\t\t\t\tthis.data = null;\r\n\t\t\t}\r\n\r\n\t\t\tif(this._jsonFileUrl){\r\n\r\n\t\t\t\tif(this._loadInProgress){\r\n\t\t\t\t\tthis._queuedFetches.push({args: keywordArgs});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\turl: self._jsonFileUrl,\r\n\t\t\t\t\t\thandleAs: \"json-comment-optional\",\r\n\t\t\t\t\t\tpreventCache: this.urlPreventCache,\r\n\t\t\t\t\t\tfailOk: this.failOk\r\n\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\tvar scope = keywordArgs.scope?keywordArgs.scope:kernel.global;\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tself._getItemsFromLoadedData(data);\r\n\t\t\t\t\t\t\tself._loadFinished = true;\r\n\t\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\t\titem = self._getItemByIdentity(keywordArgs.identity);\r\n\t\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t\t}catch(error){\r\n\t\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\tvar scope = keywordArgs.scope?keywordArgs.scope:kernel.global;\r\n\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t}else if(this._jsonData){\r\n\t\t\t\t// Passed in data, no need to xhr.\r\n\t\t\t\tself._getItemsFromLoadedData(self._jsonData);\r\n\t\t\t\tself._jsonData = null;\r\n\t\t\t\tself._loadFinished = true;\r\n\t\t\t\titem = self._getItemByIdentity(keywordArgs.identity);\r\n\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\tscope = keywordArgs.scope?keywordArgs.scope:kernel.global;\r\n\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// Already loaded.  We can just look it up and call back.\r\n\t\t\titem = this._getItemByIdentity(keywordArgs.identity);\r\n\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\tscope = keywordArgs.scope?keywordArgs.scope:kernel.global;\r\n\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getItemByIdentity: function(/* Object */ identity){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to look an item up by its identity map.\r\n\t\tvar item = null;\r\n\t\tif(this._itemsByIdentity){\r\n\t\t\t// If this map is defined, we need to just try to get it.  If it fails\r\n\t\t\t// the item does not exist.\r\n\t\t\tif(Object.hasOwnProperty.call(this._itemsByIdentity, identity)){\r\n\t\t\t\titem = this._itemsByIdentity[identity];\r\n\t\t\t}\r\n\t\t}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){\r\n\t\t\titem = this._arrayOfAllItems[identity];\r\n\t\t}\r\n\t\tif(item === undefined){\r\n\t\t\titem = null;\r\n\t\t}\r\n\t\treturn item; // Object\r\n\t},\r\n\r\n\tgetIdentityAttributes: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentityAttributes()\r\n\r\n\t\tvar identifier = this._features['dojo.data.api.Identity'];\r\n\t\tif(identifier === Number){\r\n\t\t\t// If (identifier === Number) it means getIdentity() just returns\r\n\t\t\t// an integer item-number for each item.  The dojo/data/api/Identity\r\n\t\t\t// spec says we need to return null if the identity is not composed\r\n\t\t\t// of attributes\r\n\t\t\treturn null; // null\r\n\t\t}else{\r\n\t\t\treturn [identifier]; // Array\r\n\t\t}\r\n\t},\r\n\r\n\t_forceLoad: function(){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to force a load of the store if it hasn't occurred yet.  This is required\r\n\t\t//\t\tfor specific functions to work properly.\r\n\t\tvar self = this;\r\n\t\t//Do a check on the JsonFileUrl and crosscheck it.\r\n\t\t//If it doesn't match the cross-check, it needs to be updated\r\n\t\t//This allows for either url or _jsonFileUrl to he changed to\r\n\t\t//reset the store load location.  Done this way for backwards\r\n\t\t//compatibility.  People use _jsonFileUrl (even though officially\r\n\t\t//private.\r\n\t\tif(this._jsonFileUrl !== this._ccUrl){\r\n\t\t\tkernel.deprecated(this.declaredClass + \": \",\r\n\t\t\t\t\"To change the url, set the url property of the store,\" +\r\n\t\t\t\t\t\" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0\");\r\n\t\t\tthis._ccUrl = this._jsonFileUrl;\r\n\t\t\tthis.url = this._jsonFileUrl;\r\n\t\t}else if(this.url !== this._ccUrl){\r\n\t\t\tthis._jsonFileUrl = this.url;\r\n\t\t\tthis._ccUrl = this.url;\r\n\t\t}\r\n\r\n\t\t//See if there was any forced reset of data.\r\n\t\tif(this.data != null){\r\n\t\t\tthis._jsonData = this.data;\r\n\t\t\tthis.data = null;\r\n\t\t}\r\n\r\n\t\tif(this._jsonFileUrl){\r\n\t\t\tvar getArgs = {\r\n\t\t\t\turl: this._jsonFileUrl,\r\n\t\t\t\thandleAs: \"json-comment-optional\",\r\n\t\t\t\tpreventCache: this.urlPreventCache,\r\n\t\t\t\tfailOk: this.failOk,\r\n\t\t\t\tsync: true\r\n\t\t\t};\r\n\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\ttry{\r\n\t\t\t\t\t//Check to be sure there wasn't another load going on concurrently\r\n\t\t\t\t\t//So we don't clobber data that comes in on it.  If there is a load going on\r\n\t\t\t\t\t//then do not save this data.  It will potentially clobber current data.\r\n\t\t\t\t\t//We mainly wanted to sync/wait here.\r\n\t\t\t\t\t//TODO:  Revisit the loading scheme of this store to improve multi-initial\r\n\t\t\t\t\t//request handling.\r\n\t\t\t\t\tif(self._loadInProgress !== true && !self._loadFinished){\r\n\t\t\t\t\t\tself._getItemsFromLoadedData(data);\r\n\t\t\t\t\t\tself._loadFinished = true;\r\n\t\t\t\t\t}else if(self._loadInProgress){\r\n\t\t\t\t\t\t//Okay, we hit an error state we can't recover from.  A forced load occurred\r\n\t\t\t\t\t\t//while an async load was occurring.  Since we cannot block at this point, the best\r\n\t\t\t\t\t\t//that can be managed is to throw an error.\r\n\t\t\t\t\t\tthrow new Error(this.declaredClass + \":  Unable to perform a synchronous load, an async load is in progress.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\tconsole.log(e);\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t\t}else if(this._jsonData){\r\n\t\t\tself._getItemsFromLoadedData(self._jsonData);\r\n\t\t\tself._jsonData = null;\r\n\t\t\tself._loadFinished = true;\r\n\t\t}\r\n\t}\r\n});\r\n//Mix in the simple fetch implementation to this class.\r\nlang.extend(ItemFileReadStore,simpleFetch);\r\n\r\nreturn ItemFileReadStore;\r\n\r\n});\r\n"]}