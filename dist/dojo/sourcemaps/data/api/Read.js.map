{"version":3,"sources":["data/api/Read.js"],"names":["define","declare","getValue","item","attribute","defaultValue","Error","getValues","getAttributes","hasAttribute","containsValue","value","isItem","something","isItemLoaded","loadItem","keywordArgs","this","fetch","getFeatures","dojo.data.api.Read","close","request","getLabel","getLabelAttributes"],"mappings":";;;;;;;AAAAA,QAAQ,uBAAwB,SAASC,GAKzC,OAAOA,EAAQ,qBAAsB,MAOpCC,SAAU,SAAmCC,EACZC,EACfC,GA0BjB,MAAM,IAAIC,MAAM,mDAGjBC,UAAW,SAAkCJ,EACZC,GAmBhC,MAAM,IAAIE,MAAM,oDAGjBE,cAAe,SAAkCL,GAWhD,MAAM,IAAIG,MAAM,wDAGjBG,aAAc,SAAmCN,EACfC,GAWjC,MAAM,IAAIE,MAAM,uDAGjBI,cAAe,SAAkCP,EACfC,EACbO,GAcpB,MAAM,IAAIL,MAAM,wDAGjBM,OAAQ,SAAwBC,GAU/B,MAAM,IAAIP,MAAM,iDAGjBQ,aAAc,SAAwBD,GAWrC,MAAM,IAAIP,MAAM,uDAGjBS,SAAU,SAAsBC,GA4C/B,IAAIC,KAAKH,aAAaE,EAAYb,MACjC,MAAM,IAAIG,MAAM,mDAIlBY,MAAO,SAAsBF,GAkN5B,MAAM,IAAIV,MAAM,gDAGjBa,YAAa,WAWZ,OACCC,sBAAsB,IAIxBC,MAAO,SAA2CC,GAqBjD,MAAM,IAAIhB,MAAM,gDAGjBiB,SAAU,SAAkCpB,GAoB3C,MAAM,IAAIG,MAAM,mDAGjBkB,mBAAoB,SAAkCrB,GAerD,MAAM,IAAIG,MAAM","file":"../../../data/api/Read.js","sourcesContent":["define([\"../../_base/declare\"], function(declare){\r\n\r\n// module:\r\n//\t\tdojo/data/api/Read\r\n\r\nreturn declare(\"dojo.data.api.Read\", null, {\r\n\t// summary:\r\n\t//\t\tThis is an abstract API that data provider implementations conform to.\r\n\t//\t\tThis file defines methods signatures and intentionally leaves all the\r\n\t//\t\tmethods unimplemented.  For more information on the dojo.data APIs,\r\n\t//\t\tplease visit: http://www.dojotoolkit.org/node/98\r\n\r\n\tgetValue: function(\t/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t/* attribute-name-string */ attribute,\r\n\t\t\t\t\t\t/* value? */ defaultValue){\r\n\t\t// summary:\r\n\t\t//\t\tReturns a single attribute value.\r\n\t\t//\t\tReturns defaultValue if and only if *item* does not have a value for *attribute*.\r\n\t\t//\t\tReturns null if and only if null was explicitly set as the attribute value.\r\n\t\t//\t\tReturns undefined if and only if the item does not have a value for the\r\n\t\t//\t\tgiven attribute (which is the same as saying the item does not have the attribute).\r\n\t\t// description:\r\n\t\t//\t\tSaying that an \"item x does not have a value for an attribute y\"\r\n\t\t//\t\tis identical to saying that an \"item x does not have attribute y\".\r\n\t\t//\t\tIt is an oxymoron to say \"that attribute is present but has no values\"\r\n\t\t//\t\tor \"the item has that attribute but does not have any attribute values\".\r\n\t\t//\t\tIf store.hasAttribute(item, attribute) returns false, then\r\n\t\t//\t\tstore.getValue(item, attribute) will return undefined.\r\n\t\t// item:\r\n\t\t//\t\tThe item to access values on.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to access represented as a string.\r\n\t\t// defaultValue:\r\n\t\t//\t\tOptional.  A default value to use for the getValue return in the attribute does not exist or has no value.\r\n\t\t// returns:\r\n\t\t//\t\ta literal, an item, null, or undefined (never an array)\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if *item* is not an item, or *attribute* is not a string\r\n\t\t// example:\r\n\t\t//\t|\tvar darthVader = store.getValue(lukeSkywalker, \"father\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.getValue');\r\n\t},\r\n\r\n\tgetValues: function(/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t/* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tThis getValues() method works just like the getValue() method, but getValues()\r\n\t\t//\t\talways returns an array rather than a single attribute value.  The array\r\n\t\t//\t\tmay be empty, may contain a single attribute value, or may contain\r\n\t\t//\t\tmany attribute values.\r\n\t\t//\t\tIf the item does not have a value for the given attribute, then getValues()\r\n\t\t//\t\twill return an empty array: [].  (So, if store.hasAttribute(item, attribute)\r\n\t\t//\t\thas a return of false, then store.getValues(item, attribute) will return [].)\r\n\t\t// item:\r\n\t\t//\t\tThe item to access values on.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to access represented as a string.\r\n\t\t// returns:\r\n\t\t//\t\tan array that may contain literals and items\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if *item* is not an item, or *attribute* is not a string\r\n\t\t// example:\r\n\t\t//\t|\tvar friendsOfLuke = store.getValues(lukeSkywalker, \"friends\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.getValues');\r\n\t},\r\n\r\n\tgetAttributes: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tReturns an array with all the attributes that this item has.  This\r\n\t\t//\t\tmethod will always return an array; if the item has no attributes\r\n\t\t//\t\tat all, getAttributes() will return an empty array: [].\r\n\t\t// item:\r\n\t\t//\t\tThe item to access attributes on.\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if *item* is not an item, or *attribute* is not a string\r\n\t\t// example:\r\n\t\t//\t|\tvar array = store.getAttributes(kermit);\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.getAttributes');\r\n\t},\r\n\r\n\thasAttribute: function(\t/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t\t/* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tReturns true if the given *item* has a value for the given *attribute*.\r\n\t\t// item:\r\n\t\t//\t\tThe item to access attributes on.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to access represented as a string.\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if *item* is not an item, or *attribute* is not a string\r\n\t\t// example:\r\n\t\t//\t|\tvar trueOrFalse = store.hasAttribute(kermit, \"color\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.hasAttribute');\r\n\t},\r\n\r\n\tcontainsValue: function(/* dojo/data/api/Item */ item,\r\n\t\t\t\t\t\t\t/* attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t/* anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tReturns true if the given *value* is one of the values that getValues()\r\n\t\t//\t\twould return.\r\n\t\t// item:\r\n\t\t//\t\tThe item to access values on.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to access represented as a string.\r\n\t\t// value:\r\n\t\t//\t\tThe value to match as a value for the attribute.\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if *item* is not an item, or *attribute* is not a string\r\n\t\t// example:\r\n\t\t//\t|\tvar trueOrFalse = store.containsValue(kermit, \"color\", \"green\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.containsValue');\r\n\t},\r\n\r\n\tisItem: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tReturns true if *something* is an item and came from the store instance.\r\n\t\t//\t\tReturns false if *something* is a literal, an item from another store instance,\r\n\t\t//\t\tor is any object other than an item.\r\n\t\t// something:\r\n\t\t//\t\tCan be anything.\r\n\t\t// example:\r\n\t\t//\t|\tvar yes = store.isItem(store.newItem());\r\n\t\t//\t|\tvar no  = store.isItem(\"green\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.isItem');\r\n\t},\r\n\r\n\tisItemLoaded: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tReturns false if isItem(something) is false.  Returns false if\r\n\t\t//\t\tif isItem(something) is true but the the item is not yet loaded\r\n\t\t//\t\tin local memory (for example, if the item has not yet been read\r\n\t\t//\t\tfrom the server).\r\n\t\t// something:\r\n\t\t//\t\tCan be anything.\r\n\t\t// example:\r\n\t\t//\t|\tvar yes = store.isItemLoaded(store.newItem());\r\n\t\t//\t|\tvar no  = store.isItemLoaded(\"green\");\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.isItemLoaded');\r\n\t},\r\n\r\n\tloadItem: function(/* Object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tGiven an item, this method loads the item so that a subsequent call\r\n\t\t//\t\tto store.isItemLoaded(item) will return true.  If a call to\r\n\t\t//\t\tisItemLoaded() returns true before loadItem() is even called,\r\n\t\t//\t\tthen loadItem() need not do any work at all and will not even invoke\r\n\t\t//\t\tthe callback handlers.  So, before invoking this method, check that\r\n\t\t//\t\tthe item has not already been loaded.\r\n\t\t// keywordArgs:\r\n\t\t//\t\tAn anonymous object that defines the item to load and callbacks to invoke when the\r\n\t\t//\t\tload has completed.  The format of the object is as follows:\r\n\t\t// |\t{\r\n\t\t// |\t\titem: object,\r\n\t\t// |\t\tonItem: Function,\r\n\t\t// |\t\tonError: Function,\r\n\t\t// |\t\tscope: object\r\n\t\t// |\t}\r\n\t\t//\r\n\t\t//\t\t####The *item* parameter\r\n\t\t//\r\n\t\t//\t\tThe item parameter is an object that represents the item in question that should be\r\n\t\t//\t\tcontained by the store.  This attribute is required.\r\n\t\t//\r\n\t\t//\t\t####The *onItem* parameter\r\n\t\t//\r\n\t\t//\t\tFunction(item)\r\n\t\t//\t\tThe onItem parameter is the callback to invoke when the item has been loaded.  It takes only one\r\n\t\t//\t\tparameter, the fully loaded item.\r\n\t\t//\r\n\t\t//\t\t####The *onError* parameter\r\n\t\t//\r\n\t\t//\t\tFunction(error)\r\n\t\t//\t\tThe onError parameter is the callback to invoke when the item load encountered an error.  It takes only one\r\n\t\t//\t\tparameter, the error object\r\n\t\t//\r\n\t\t//\t\t####The *scope* parameter\r\n\t\t//\r\n\t\t//\t\tIf a scope object is provided, all of the callback functions (onItem,\r\n\t\t//\t\tonError, etc) will be invoked in the context of the scope object.\r\n\t\t//\t\tIn the body of the callback function, the value of the \"this\"\r\n\t\t//\t\tkeyword will be the scope object.   If no scope object is provided,\r\n\t\t//\t\tthe callback functions will be called in the context of dojo.global().\r\n\t\t//\t\tFor example, onItem.call(scope, item, request) vs.\r\n\t\t//\t\tonItem.call(dojo.global(), item, request)\r\n\t\tif(!this.isItemLoaded(keywordArgs.item)){\r\n\t\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.loadItem');\r\n\t\t}\r\n\t},\r\n\r\n\tfetch: function(/* Object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tGiven a query and set of defined options, such as a start and count of items to return,\r\n\t\t//\t\tthis method executes the query and makes the results available as data items.\r\n\t\t//\t\tThe format and expectations of stores is that they operate in a generally asynchronous\r\n\t\t//\t\tmanner, therefore callbacks are always used to return items located by the fetch parameters.\r\n\t\t// description:\r\n\t\t//\t\tA Request object will always be returned and is returned immediately.\r\n\t\t//\t\tThe basic request is nothing more than the keyword args passed to fetch and\r\n\t\t//\t\tan additional function attached, abort().  The returned request object may then be used\r\n\t\t//\t\tto cancel a fetch.  All data items returns are passed through the callbacks defined in the\r\n\t\t//\t\tfetch parameters and are not present on the 'request' object.\r\n\t\t//\r\n\t\t//\t\tThis does not mean that custom stores can not add methods and properties to the request object\r\n\t\t//\t\treturned, only that the API does not require it.  For more info about the Request API,\r\n\t\t//\t\tsee dojo/data/api/Request\r\n\t\t// keywordArgs:\r\n\t\t//\t\tThe keywordArgs parameter may either be an instance of\r\n\t\t//\t\tconforming to dojo/data/api/Request or may be a simple anonymous object\r\n\t\t//\t\tthat may contain any of the following:\r\n\t\t// |\t{\r\n\t\t// |\t\tquery: query-object or query-string,\r\n\t\t// |\t\tqueryOptions: object,\r\n\t\t// |\t\tonBegin: Function,\r\n\t\t// |\t\tonItem: Function,\r\n\t\t// |\t\tonComplete: Function,\r\n\t\t// |\t\tonError: Function,\r\n\t\t// |\t\tscope: object,\r\n\t\t// |\t\tstart: int\r\n\t\t// |\t\tcount: int\r\n\t\t// |\t\tsort: array\r\n\t\t// |\t}\r\n\t\t//\t\tAll implementations should accept keywordArgs objects with any of\r\n\t\t//\t\tthe 9 standard properties: query, onBegin, onItem, onComplete, onError\r\n\t\t//\t\tscope, sort, start, and count.  Some implementations may accept additional\r\n\t\t//\t\tproperties in the keywordArgs object as valid parameters, such as\r\n\t\t//\t\t{includeOutliers:true}.\r\n\t\t//\r\n\t\t//\t\t####The *query* parameter\r\n\t\t//\r\n\t\t//\t\tThe query may be optional in some data store implementations.\r\n\t\t//\t\tThe dojo/data/api/Read API does not specify the syntax or semantics\r\n\t\t//\t\tof the query itself -- each different data store implementation\r\n\t\t//\t\tmay have its own notion of what a query should look like.\r\n\t\t//\t\tHowever, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data\r\n\t\t//\t\tand dojox.data support an object structure query, where the object is a set of\r\n\t\t//\t\tname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the\r\n\t\t//\t\tdijit widgets, such as ComboBox assume this to be the case when working with a datastore\r\n\t\t//\t\twhen they dynamically update the query.  Therefore, for maximum compatibility with dijit\r\n\t\t//\t\twidgets the recommended query parameter is a key/value object.  That does not mean that the\r\n\t\t//\t\tthe datastore may not take alternative query forms, such as a simple string, a Date, a number,\r\n\t\t//\t\tor a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query\r\n\t\t//\t\tformat.\r\n\t\t//\r\n\t\t//\t\tFurther note:  In general for query objects that accept strings as attribute\r\n\t\t//\t\tvalue matches, the store should also support basic filtering capability, such as *\r\n\t\t//\t\t(match any character) and ? (match single character).  An example query that is a query object\r\n\t\t//\t\twould be like: { attrFoo: \"value*\"}.  Which generally means match all items where they have\r\n\t\t//\t\tan attribute named attrFoo, with a value that starts with 'value'.\r\n\t\t//\r\n\t\t//\t\t####The *queryOptions* parameter\r\n\t\t//\r\n\t\t//\t\tThe queryOptions parameter is an optional parameter used to specify options that may modify\r\n\t\t//\t\tthe query in some fashion, such as doing a case insensitive search, or doing a deep search\r\n\t\t//\t\twhere all items in a hierarchical representation of data are scanned instead of just the root\r\n\t\t//\t\titems.  It currently defines two options that all datastores should attempt to honor if possible:\r\n\t\t// |\t{\r\n\t\t// |\t\tignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.\r\n\t\t// |\t\tdeep: boolean \t// Whether or not a fetch should do a deep search of items and all child\r\n\t\t// |\t\t\t\t\t\t// items instead of just root-level items in a datastore.  Default is false.\r\n\t\t// |\t}\r\n\t\t//\r\n\t\t//\t\t####The *onBegin* parameter.\r\n\t\t//\r\n\t\t//\t\tfunction(size, request);\r\n\t\t//\t\tIf an onBegin callback function is provided, the callback function\r\n\t\t//\t\twill be called just once, before the first onItem callback is called.\r\n\t\t//\t\tThe onBegin callback function will be passed two arguments, the\r\n\t\t//\t\tthe total number of items identified and the Request object.  If the total number is\r\n\t\t//\t\tunknown, then size will be -1.  Note that size is not necessarily the size of the\r\n\t\t//\t\tcollection of items returned from the query, as the request may have specified to return only a\r\n\t\t//\t\tsubset of the total set of items through the use of the start and count parameters.\r\n\t\t//\r\n\t\t//\t\t####The *onItem* parameter.\r\n\t\t//\r\n\t\t//\t\tfunction(item, request);\r\n\t\t//\r\n\t\t//\t\tIf an onItem callback function is provided, the callback function\r\n\t\t//\t\twill be called as each item in the result is received. The callback\r\n\t\t//\t\tfunction will be passed two arguments: the item itself, and the\r\n\t\t//\t\tRequest object.\r\n\t\t//\r\n\t\t//\t\t####The *onComplete* parameter.\r\n\t\t//\r\n\t\t//\t\tfunction(items, request);\r\n\t\t//\r\n\t\t//\t\tIf an onComplete callback function is provided, the callback function\r\n\t\t//\t\twill be called just once, after the last onItem callback is called.\r\n\t\t//\t\tNote that if the onItem callback is not present, then onComplete will be passed\r\n\t\t//\t\tan array containing all items which matched the query and the request object.\r\n\t\t//\t\tIf the onItem callback is present, then onComplete is called as:\r\n\t\t//\t\tonComplete(null, request).\r\n\t\t//\r\n\t\t//\t\t####The *onError* parameter.\r\n\t\t//\r\n\t\t//\t\tfunction(errorData, request);\r\n\t\t//\r\n\t\t//\t\tIf an onError callback function is provided, the callback function\r\n\t\t//\t\twill be called if there is any sort of error while attempting to\r\n\t\t//\t\texecute the query.\r\n\t\t//\t\tThe onError callback function will be passed two arguments:\r\n\t\t//\t\tan Error object and the Request object.\r\n\t\t//\r\n\t\t//\t\t####The *scope* parameter.\r\n\t\t//\r\n\t\t//\t\tIf a scope object is provided, all of the callback functions (onItem,\r\n\t\t//\t\tonComplete, onError, etc) will be invoked in the context of the scope\r\n\t\t//\t\tobject.  In the body of the callback function, the value of the \"this\"\r\n\t\t//\t\tkeyword will be the scope object.   If no scope object is provided,\r\n\t\t//\t\tthe callback functions will be called in the context of dojo.global().\r\n\t\t//\t\tFor example, onItem.call(scope, item, request) vs.\r\n\t\t//\t\tonItem.call(dojo.global(), item, request)\r\n\t\t//\r\n\t\t//\t\t####The *start* parameter.\r\n\t\t//\r\n\t\t//\t\tIf a start parameter is specified, this is a indication to the datastore to\r\n\t\t//\t\tonly start returning items once the start number of items have been located and\r\n\t\t//\t\tskipped.  When this parameter is paired with 'count', the store should be able\r\n\t\t//\t\tto page across queries with millions of hits by only returning subsets of the\r\n\t\t//\t\thits for each query\r\n\t\t//\r\n\t\t//\t\t####The *count* parameter.\r\n\t\t//\r\n\t\t//\t\tIf a count parameter is specified, this is a indication to the datastore to\r\n\t\t//\t\tonly return up to that many items.  This allows a fetch call that may have\r\n\t\t//\t\tmillions of item matches to be paired down to something reasonable.\r\n\t\t//\r\n\t\t//\t\t####The *sort* parameter.\r\n\t\t//\r\n\t\t//\t\tIf a sort parameter is specified, this is a indication to the datastore to\r\n\t\t//\t\tsort the items in some manner before returning the items.  The array is an array of\r\n\t\t//\t\tjavascript objects that must conform to the following format to be applied to the\r\n\t\t//\t\tfetching of items:\r\n\t\t// |\t{\r\n\t\t// |\t\tattribute: attribute || attribute-name-string,\r\n\t\t// |\t\tdescending: true|false;   // Optional.  Default is false.\r\n\t\t// |\t}\r\n\t\t//\t\tNote that when comparing attributes, if an item contains no value for the attribute\r\n\t\t//\t\t(undefined), then it the default ascending sort logic should push it to the bottom\r\n\t\t//\t\tof the list.  In the descending order case, it such items should appear at the top of the list.\r\n\t\t// returns:\r\n\t\t//\t\tThe fetch() method will return a javascript object conforming to the API\r\n\t\t//\t\tdefined in dojo/data/api/Request.  In general, it will be the keywordArgs\r\n\t\t//\t\tobject returned with the required functions in Request.js attached.\r\n\t\t//\t\tIts general purpose is to provide a convenient way for a caller to abort an\r\n\t\t//\t\tongoing fetch.\r\n\t\t//\r\n\t\t//\t\tThe Request object may also have additional properties when it is returned\r\n\t\t//\t\tsuch as request.store property, which is a pointer to the datastore object that\r\n\t\t//\t\tfetch() is a method of.\r\n\t\t// exceptions:\r\n\t\t//\t\tThrows an exception if the query is not valid, or if the query\r\n\t\t//\t\tis required but was not supplied.\r\n\t\t// example:\r\n\t\t//\t\tFetch all books identified by the query and call 'showBooks' when complete\r\n\t\t//\t\t|\tvar request = store.fetch({query:\"all books\", onComplete: showBooks});\r\n\t\t// example:\r\n\t\t//\t\tFetch all items in the story and call 'showEverything' when complete.\r\n\t\t//\t\t|\tvar request = store.fetch(onComplete: showEverything);\r\n\t\t// example:\r\n\t\t//\t\tFetch only 10 books that match the query 'all books', starting at the fifth book found during the search.\r\n\t\t//\t\tThis demonstrates how paging can be done for specific queries.\r\n\t\t//\t\t|\tvar request = store.fetch({query:\"all books\", start: 4, count: 10, onComplete: showBooks});\r\n\t\t// example:\r\n\t\t//\t\tFetch all items that match the query, calling 'callback' each time an item is located.\r\n\t\t//\t\t|\tvar request = store.fetch({query:\"foo/bar\", onItem:callback});\r\n\t\t// example:\r\n\t\t//\t\tFetch the first 100 books by author King, call showKing when up to 100 items have been located.\r\n\t\t//\t\t|\tvar request = store.fetch({query:{author:\"King\"}, start: 0, count:100, onComplete: showKing});\r\n\t\t// example:\r\n\t\t//\t\tLocate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.\r\n\t\t//\t\t|\tvar request = store.fetch({query:{author:\"King\"}, sort: [{ attribute: \"title\", descending: true}, {attribute: \"publisher\"}], ,start: 0, count:100, onComplete: 'showKing'});\r\n\t\t// example:\r\n\t\t//\t\tFetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.\r\n\t\t//\t\t|\tvar request = store.fetch({query:{author:\"King*\"}, start: 0, count:100, onComplete: showKing});\r\n\t\t// example:\r\n\t\t//\t\tFetch the first 100 books by authors ending with 'ing', but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.\r\n\t\t//\t\t|\tvar request = store.fetch({query:{author:\"?ing\"}, start: 0, count:100, onComplete: showBooks});\r\n\t\t// example:\r\n\t\t//\t\tFetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.\r\n\t\t//\t\t|\tvar request = store.fetch({query:{author:\"King\"}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});\r\n\t\t// example:\r\n\t\t//\t\tPaging\r\n\t\t//\t\t|\tvar store = new LargeRdbmsStore({url:\"jdbc:odbc:foobar\"});\r\n\t\t//\t\t|\tvar fetchArgs = {\r\n\t\t//\t\t|\t\tquery: {type:\"employees\", name:\"Hillary *\"}, // string matching\r\n\t\t//\t\t|\t\tsort: [{attribute:\"department\", descending:true}],\r\n\t\t//\t\t|\t\tstart: 0,\r\n\t\t//\t\t|\t\tcount: 20,\r\n\t\t//\t\t|\t\tscope: displayer,\r\n\t\t//\t\t|\t\tonBegin: showThrobber,\r\n\t\t//\t\t|\t\tonItem: displayItem,\r\n\t\t//\t\t|\t\tonComplete: stopThrobber,\r\n\t\t//\t\t|\t\tonError: handleFetchError,\r\n\t\t//\t\t|\t};\r\n\t\t//\t\t|\tstore.fetch(fetchArgs);\r\n\t\t//\t\t|\t...\r\n\t\t//\t\tand then when the user presses the \"Next Page\" button...\r\n\t\t//\t\t|\tfetchArgs.start += 20;\r\n\t\t//\t\t|\tstore.fetch(fetchArgs);  // get the next 20 items\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.fetch');\r\n\t},\r\n\r\n\tgetFeatures: function(){\r\n\t\t// summary:\r\n\t\t//\t\tThe getFeatures() method returns an simple keyword values object\r\n\t\t//\t\tthat specifies what interface features the datastore implements.\r\n\t\t//\t\tA simple CsvStore may be read-only, and the only feature it\r\n\t\t//\t\timplements will be the 'dojo/data/api/Read' interface, so the\r\n\t\t//\t\tgetFeatures() method will return an object like this one:\r\n\t\t//\t\t{'dojo.data.api.Read': true}.\r\n\t\t//\t\tA more sophisticated datastore might implement a variety of\r\n\t\t//\t\tinterface features, like 'dojo.data.api.Read', 'dojo/data/api/Write',\r\n\t\t//\t\t'dojo.data.api.Identity', and 'dojo/data/api/Attribution'.\r\n\t\treturn {\r\n\t\t\t'dojo.data.api.Read': true\r\n\t\t};\r\n\t},\r\n\r\n\tclose: function(/*dojo/data/api/Request|Object?*/ request){\r\n\t\t// summary:\r\n\t\t//\t\tThe close() method is intended for instructing the store to 'close' out\r\n\t\t//\t\tany information associated with a particular request.\r\n\t\t// description:\r\n\t\t//\t\tThe close() method is intended for instructing the store to 'close' out\r\n\t\t//\t\tany information associated with a particular request.  In general, this API\r\n\t\t//\t\texpects to receive as a parameter a request object returned from a fetch.\r\n\t\t//\t\tIt will then close out anything associated with that request, such as\r\n\t\t//\t\tclearing any internal datastore caches and closing any 'open' connections.\r\n\t\t//\t\tFor some store implementations, this call may be a no-op.\r\n\t\t// request:\r\n\t\t//\t\tAn instance of a request for the store to use to identify what to close out.\r\n\t\t//\t\tIf no request is passed, then the store should clear all internal caches (if any)\r\n\t\t//\t\tand close out all 'open' connections.  It does not render the store unusable from\r\n\t\t//\t\tthere on, it merely cleans out any current data and resets the store to initial\r\n\t\t//\t\tstate.\r\n\t\t// example:\r\n\t\t//\t|\tvar request = store.fetch({onComplete: doSomething});\r\n\t\t//\t|\t...\r\n\t\t//\t|\tstore.close(request);\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.close');\r\n\t},\r\n\r\n\tgetLabel: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tMethod to inspect the item and return a user-readable 'label' for the item\r\n\t\t//\t\tthat provides a general/adequate description of what the item is.\r\n\t\t// description:\r\n\t\t//\t\tMethod to inspect the item and return a user-readable 'label' for the item\r\n\t\t//\t\tthat provides a general/adequate description of what the item is.  In general\r\n\t\t//\t\tmost labels will be a specific attribute value or collection of the attribute\r\n\t\t//\t\tvalues that combine to label the item in some manner.  For example for an item\r\n\t\t//\t\tthat represents a person it may return the label as:  \"firstname lastlame\" where\r\n\t\t//\t\tthe firstname and lastname are attributes on the item.  If the store is unable\r\n\t\t//\t\tto determine an adequate human readable label, it should return undefined.  Users that wish\r\n\t\t//\t\tto customize how a store instance labels items should replace the getLabel() function on\r\n\t\t//\t\ttheir instance of the store, or extend the store and replace the function in\r\n\t\t//\t\tthe extension class.\r\n\t\t// item:\r\n\t\t//\t\tThe item to return the label for.\r\n\t\t// returns:\r\n\t\t//\t\tA user-readable string representing the item or undefined if no user-readable label can\r\n\t\t//\t\tbe generated.\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.getLabel');\r\n\t},\r\n\r\n\tgetLabelAttributes: function(/* dojo/data/api/Item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tMethod to inspect the item and return an array of what attributes of the item were used\r\n\t\t//\t\tto generate its label, if any.\r\n\t\t// description:\r\n\t\t//\t\tMethod to inspect the item and return an array of what attributes of the item were used\r\n\t\t//\t\tto generate its label, if any.  This function is to assist UI developers in knowing what\r\n\t\t//\t\tattributes can be ignored out of the attributes an item has when displaying it, in cases\r\n\t\t//\t\twhere the UI is using the label as an overall identifer should they wish to hide\r\n\t\t//\t\tredundant information.\r\n\t\t// item:\r\n\t\t//\t\tThe item to return the list of label attributes for.\r\n\t\t// returns:\r\n\t\t//\t\tAn array of attribute names that were used to generate the label, or null if public attributes\r\n\t\t//\t\twere not used to generate the label.\r\n\t\tthrow new Error('Unimplemented API: dojo.data.api.Read.getLabelAttributes');\r\n\t}\r\n});\r\n\r\n});\r\n"]}