{"version":3,"sources":["i18n.js"],"names":["define","dojo","require","has","array","config","lang","xhr","json","module","isBrowser","load","name","req","onLoad","add","thisModule","i18n","nlsRe","cache","getBundleName","moduleName","bundleName","locale","toLowerCase","replace","test","getL10nName","id","split","preloadDemand","preloadL10n","parse","waitForPreloads","match","exec","bundlePath","bundlePathAndName","localeSpecified","targetLocale","loadTarget","loadList","list","extraLocale","isArray","push","getLocalesToLoad","remaining","length","finish","delegate","forEach","target","checkForLegacyModules","root","current","clone","ROOT","availableLocales","result","localeParts","i","specificity","getAvailableLocales","_v1x","mixin","arguments","$locale","doLoad","unitTests","normalizeLocale","isXd","mid","contextRequire","isXdUrl","toUrl","preloading","preloadWaitQueue","_preloadLocalizations","bundlePrefix","localesGenerated","guaranteedAmdFormat","forEachLocale","func","parts","join","pop","preloadingAddLock","preloadingRelLock","apply","shift","cacheId","path","loc","toAbsMid","preload","indexOf","callback","syncRequire","doRequire","rollup","p","bundle","localized","_localized","improveBundle","requiredBundles","cacheIds","amdValue","evalBundle","Function","deps","results","url","text","Error","console","error","syncLoadNls","get","sync","getText","e","names","object","global","getLocalization","l10nName","result_","doh","register","t","check","is","prop","undefined","prop-x","dynamic","normalize"],"mappings":"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","file":"../i18n.js","sourcesContent":["define([\"./_base/kernel\", \"require\", \"./has\", \"./_base/array\", \"./_base/config\", \"./_base/lang\", \"has!host-browser?./_base/xhr\", \"./json\", \"module\"],\r\n\r\n\tfunction(dojo, require, has, array, config, lang, xhr, json, module){\r\n\r\n\tif (require.isBrowser===false) { // for build,will be changed with better implementation. by LWF\r\n\t\treturn {\r\n\t        load: function (name, req, onLoad, config) {\r\n\t            onLoad();\r\n\t        }\t\t\t\r\n\t\t};\r\n\t}\r\n\r\n\t// module:\r\n\t// module:\r\n\t// module:\r\n\t//\t\tdojo/i18n\r\n\r\n\thas.add(\"dojo-preload-i18n-Api\",\r\n\t\t// if true, define the preload localizations machinery\r\n\t\t1\r\n\t);\r\n\r\n\thas.add(\"dojo-v1x-i18n-Api\",\r\n\t\t// if true, define the v1.x i18n functions\r\n\t\t1\r\n\t);\r\n\r\n\tvar\r\n\t\tthisModule = dojo.i18n =\r\n\t\t\t{\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tThis module implements the dojo/i18n! plugin and the v1.6- i18n API\r\n\t\t\t\t// description:\r\n\t\t\t\t//\t\tWe choose to include our own plugin to leverage functionality already contained in dojo\r\n\t\t\t\t//\t\tand thereby reduce the size of the plugin compared to various loader implementations. Also, this\r\n\t\t\t\t//\t\tallows foreign AMD loaders to be used without their plugins.\r\n\t\t\t},\r\n\r\n\t\tnlsRe =\r\n\t\t\t// regexp for reconstructing the master bundle name from parts of the regexp match\r\n\t\t\t// nlsRe.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\r\n\t\t\t// [\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\r\n\t\t\t// nlsRe.exec(\"foo/bar/baz/nls/foo\") gives:\r\n\t\t\t// [\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\r\n\t\t\t// so, if match[5] is blank, it means this is the top bundle definition.\r\n\t\t\t// courtesy of http://requirejs.org\r\n\t\t\t/(^.*(^|\\/)nls)(\\/|$)([^\\/]*)\\/?([^\\/]*)/,\r\n\r\n\t\tgetAvailableLocales = function(\r\n\t\t\troot,\r\n\t\t\tlocale,\r\n\t\t\tbundlePath,\r\n\t\t\tbundleName\r\n\t\t){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn a vector of module ids containing all available locales with respect to the target locale\r\n\t\t\t//\t\tFor example, assuming:\r\n\t\t\t//\r\n\t\t\t//\t\t- the root bundle indicates specific bundles for \"fr\" and \"fr-ca\",\r\n\t\t\t//\t\t-  bundlePath is \"myPackage/nls\"\r\n\t\t\t//\t\t- bundleName is \"myBundle\"\r\n\t\t\t//\r\n\t\t\t//\t\tThen a locale argument of \"fr-ca\" would return\r\n\t\t\t//\r\n\t\t\t//\t\t\t[\"myPackage/nls/myBundle\", \"myPackage/nls/fr/myBundle\", \"myPackage/nls/fr-ca/myBundle\"]\r\n\t\t\t//\r\n\t\t\t//\t\tNotice that bundles are returned least-specific to most-specific, starting with the root.\r\n\t\t\t//\r\n\t\t\t//\t\tIf root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;\r\n\t\t\t//\t\ttherefore, assume everything is available and get 404 errors that indicate a particular localization is not available\r\n\r\n\t\t\tfor(var result = [bundlePath + bundleName], localeParts = locale.split(\"-\"), current = \"\", i = 0; i<localeParts.length; i++){\r\n\t\t\t\tcurrent += (current ? \"-\" : \"\") + localeParts[i];\r\n\t\t\t\tif(!root || root[current]){\r\n\t\t\t\t\tresult.push(bundlePath + current + \"/\" + bundleName);\r\n\t\t\t\t\tresult.specificity = current;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tcache = {},\r\n\r\n\t\tgetBundleName = function(moduleName, bundleName, locale){\r\n\t\t\tlocale = locale ? locale.toLowerCase() : dojo.locale;\r\n\t\t\tmoduleName = moduleName.replace(/\\./g, \"/\");\r\n\t\t\tbundleName = bundleName.replace(/\\./g, \"/\");\r\n\t\t\treturn (/root/i.test(locale)) ?\r\n\t\t\t\t(moduleName + \"/nls/\" + bundleName) :\r\n\t\t\t\t(moduleName + \"/nls/\" + locale + \"/\" + bundleName);\r\n\t\t},\r\n\r\n\t\tgetL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){\r\n\t\t\treturn moduleName = module.id + \"!\" + getBundleName(moduleName, bundleName, locale);\r\n\t\t},\r\n\r\n\t\tdoLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tget the root bundle which instructs which other bundles are required to construct the localized bundle\r\n\t\t\trequire([bundlePathAndName], function(root){\r\n\t\t\t\tvar current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT\r\n\t\t\t\t\tavailableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);\r\n\t\t\t\trequire(availableLocales, function(){\r\n\t\t\t\t\tfor (var i = 1; i<availableLocales.length; i++){\r\n\t\t\t\t\t\tcurrent = lang.mixin(lang.clone(current), arguments[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// target may not have been resolve (e.g., maybe only \"fr\" exists when \"fr-ca\" was requested)\r\n\t\t\t\t\tvar target = bundlePathAndName + \"/\" + locale;\r\n\t\t\t\t\tcache[target] = current;\r\n\t\t\t\t\tcurrent.$locale = availableLocales.specificity;\r\n\t\t\t\t\tload();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tnormalize = function(id, toAbsMid){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tid may be relative.\r\n\t\t\t//\t\tpreload has form `*preload*<path>/nls/<module>*<flattened locales>` and\r\n\t\t\t//\t\ttherefore never looks like a relative\r\n\t\t\treturn /^\\./.test(id) ? toAbsMid(id) : id;\r\n\t\t},\r\n\r\n\t\tgetLocalesToLoad = function(targetLocale){\r\n\t\t\tvar list = config.extraLocale || [];\r\n\t\t\tlist = lang.isArray(list) ? list : [list];\r\n\t\t\tlist.push(targetLocale);\r\n\t\t\treturn list;\r\n\t\t},\r\n\r\n\t\tload = function(id, require, load){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tid is in one of the following formats\r\n\t\t\t//\r\n\t\t\t//\t\t1. <path>/nls/<bundle>\r\n\t\t\t//\t\t\t=> load the bundle, localized to config.locale; load all bundles localized to\r\n\t\t\t//\t\t\tconfig.extraLocale (if any); return the loaded bundle localized to config.locale.\r\n\t\t\t//\r\n\t\t\t//\t\t2. <path>/nls/<locale>/<bundle>\r\n\t\t\t//\t\t\t=> load then return the bundle localized to <locale>\r\n\t\t\t//\r\n\t\t\t//\t\t3. *preload*<path>/nls/<module>*<JSON array of available locales>\r\n\t\t\t//\t\t\t=> for config.locale and all config.extraLocale, load all bundles found\r\n\t\t\t//\t\t\tin the best-matching bundle rollup. A value of 1 is returned, which\r\n\t\t\t//\t\t\tis meaningless other than to say the plugin is executing the requested\r\n\t\t\t//\t\t\tpreloads\r\n\t\t\t//\r\n\t\t\t//\t\tIn cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see\r\n\t\t\t//\t\tnormalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.\r\n\t\t\t//\r\n\t\t\t//\t\tTo load a bundle means to insert the bundle into the plugin's cache and publish the bundle\r\n\t\t\t//\t\tvalue to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key\r\n\t\t\t//\r\n\t\t\t//\t\t\t<path>/nls/<bundle>/<locale>\r\n\t\t\t//\r\n\t\t\t//\t\twill hold the value. Similarly, then plugin will publish this value to the loader by\r\n\t\t\t//\r\n\t\t\t//\t\t\tdefine(\"<path>/nls/<bundle>/<locale>\", <bundle-value>);\r\n\t\t\t//\r\n\t\t\t//\t\tGiven this algorithm, other machinery can provide fast load paths be preplacing\r\n\t\t\t//\t\tvalues in the plugin's cache, which is public. When a load is demanded the\r\n\t\t\t//\t\tcache is inspected before starting any loading. Explicitly placing values in the plugin\r\n\t\t\t//\t\tcache is an advanced/experimental feature that should not be needed; use at your own risk.\r\n\t\t\t//\r\n\t\t\t//\t\tFor the normal AMD algorithm, the root bundle is loaded first, which instructs the\r\n\t\t\t//\t\tplugin what additional localized bundles are required for a particular locale. These\r\n\t\t\t//\t\tadditional locales are loaded and a mix of the root and each progressively-specific\r\n\t\t\t//\t\tlocale is returned. For example:\r\n\t\t\t//\r\n\t\t\t//\t\t1. The client demands \"dojo/i18n!some/path/nls/someBundle\r\n\t\t\t//\r\n\t\t\t//\t\t2. The loader demands load(some/path/nls/someBundle)\r\n\t\t\t//\r\n\t\t\t//\t\t3. This plugin require's \"some/path/nls/someBundle\", which is the root bundle.\r\n\t\t\t//\r\n\t\t\t//\t\t4. Assuming config.locale is \"ab-cd-ef\" and the root bundle indicates that localizations\r\n\t\t\t//\t\tare available for \"ab\" and \"ab-cd-ef\" (note the missing \"ab-cd\", then the plugin\r\n\t\t\t//\t\trequires \"some/path/nls/ab/someBundle\" and \"some/path/nls/ab-cd-ef/someBundle\"\r\n\t\t\t//\r\n\t\t\t//\t\t5. Upon receiving all required bundles, the plugin constructs the value of the bundle\r\n\t\t\t//\t\tab-cd-ef as...\r\n\t\t\t//\r\n\t\t\t//\t\t\t\tmixin(mixin(mixin({}, require(\"some/path/nls/someBundle\"),\r\n\t\t\t//\t\t  \t\t\trequire(\"some/path/nls/ab/someBundle\")),\r\n\t\t\t//\t\t\t\t\trequire(\"some/path/nls/ab-cd-ef/someBundle\"));\r\n\t\t\t//\r\n\t\t\t//\t\tThis value is inserted into the cache and published to the loader at the\r\n\t\t\t//\t\tkey/module-id some/path/nls/someBundle/ab-cd-ef.\r\n\t\t\t//\r\n\t\t\t//\t\tThe special preload signature (case 3) instructs the plugin to stop servicing all normal requests\r\n\t\t\t//\t\t(further preload requests will be serviced) until all ongoing preloading has completed.\r\n\t\t\t//\r\n\t\t\t//\t\tThe preload signature instructs the plugin that a special rollup module is available that contains\r\n\t\t\t//\t\tone or more flattened, localized bundles. The JSON array of available locales indicates which locales\r\n\t\t\t//\t\tare available. Here is an example:\r\n\t\t\t//\r\n\t\t\t//\t\t\t*preload*some/path/nls/someModule*[\"root\", \"ab\", \"ab-cd-ef\"]\r\n\t\t\t//\r\n\t\t\t//\t\tThis indicates the following rollup modules are available:\r\n\t\t\t//\r\n\t\t\t//\t\t\tsome/path/nls/someModule_ROOT\r\n\t\t\t//\t\t\tsome/path/nls/someModule_ab\r\n\t\t\t//\t\t\tsome/path/nls/someModule_ab-cd-ef\r\n\t\t\t//\r\n\t\t\t//\t\tEach of these modules is a normal AMD module that contains one or more flattened bundles in a hash.\r\n\t\t\t//\t\tFor example, assume someModule contained the bundles some/bundle/path/someBundle and\r\n\t\t\t//\t\tsome/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:\r\n\t\t\t//\r\n\t\t\t//\t\t\tdefine({\r\n\t\t\t//\t\t\t\tsome/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,\r\n\t\t\t//\t\t\t\tsome/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,\r\n\t\t\t//\t\t\t});\r\n\t\t\t//\r\n\t\t\t//\t\tE.g., given this design, preloading for locale==\"ab\" can execute the following algorithm:\r\n\t\t\t//\r\n\t\t\t//\t\t\trequire([\"some/path/nls/someModule_ab\"], function(rollup){\r\n\t\t\t//\t\t\t\tfor(var p in rollup){\r\n\t\t\t//\t\t\t\t\tvar id = p + \"/ab\",\r\n\t\t\t//\t\t\t\t\tcache[id] = rollup[p];\r\n\t\t\t//\t\t\t\t\tdefine(id, rollup[p]);\r\n\t\t\t//\t\t\t\t}\r\n\t\t\t//\t\t\t});\r\n\t\t\t//\r\n\t\t\t//\t\tSimilarly, if \"ab-cd\" is requested, the algorithm can determine that \"ab\" is the best available and\r\n\t\t\t//\t\tload accordingly.\r\n\t\t\t//\r\n\t\t\t//\t\tThe builder will write such rollups for every layer if a non-empty localeList  profile property is\r\n\t\t\t//\t\tprovided. Further, the builder will include the following cache entry in the cache associated with\r\n\t\t\t//\t\tany layer.\r\n\t\t\t//\r\n\t\t\t//\t\t\t\"*now\":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}\r\n\t\t\t//\r\n\t\t\t//\t\tThe *now special cache module instructs the loader to apply the provided function to context-require\r\n\t\t\t//\t\twith respect to the particular layer being defined. This causes the plugin to hold all normal service\r\n\t\t\t//\t\trequests until all preloading is complete.\r\n\t\t\t//\r\n\t\t\t//\t\tNotice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case\r\n\t\t\t//\t\twhere the target locale has a single segment and a layer depends on a single bundle:\r\n\t\t\t//\r\n\t\t\t//\t\tWithout Preloads:\r\n\t\t\t//\r\n\t\t\t//\t\t1. Layer loads root bundle.\r\n\t\t\t//\t\t2. bundle is demanded; plugin loads single localized bundle.\r\n\t\t\t//\r\n\t\t\t//\t\tWith Preloads:\r\n\t\t\t//\r\n\t\t\t//\t\t1. Layer causes preloading of target bundle.\r\n\t\t\t//\t\t2. bundle is demanded; service is delayed until preloading complete; bundle is returned.\r\n\t\t\t//\r\n\t\t\t//\t\tIn each case a single transaction is required to load the target bundle. In cases where multiple bundles\r\n\t\t\t//\t\tare required and/or the locale has multiple segments, preloads still requires a single transaction whereas\r\n\t\t\t//\t\tthe normal path requires an additional transaction for each additional bundle/locale-segment. However all\r\n\t\t\t//\t\tof these additional transactions can be done concurrently. Owing to this analysis, the entire preloading\r\n\t\t\t//\t\talgorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.\r\n\r\n\t\t\tif(has(\"dojo-preload-i18n-Api\")){\r\n\t\t\t\tvar split = id.split(\"*\"),\r\n\t\t\t\t\tpreloadDemand = split[1] == \"preload\";\r\n\t\t\t\tif(preloadDemand){\r\n\t\t\t\t\tif(!cache[id]){\r\n\t\t\t\t\t\t// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but\r\n\t\t\t\t\t\t// who knows what over-aggressive human optimizers may attempt\r\n\t\t\t\t\t\tcache[id] = 1;\r\n\t\t\t\t\t\tpreloadL10n(split[2], json.parse(split[3]), 1, require);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// don't stall the loader!\r\n\t\t\t\t\tload(1);\r\n\t\t\t\t}\r\n\t\t\t\tif(preloadDemand || waitForPreloads(id, require, load)){\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar match = nlsRe.exec(id),\r\n\t\t\t\tbundlePath = match[1] + \"/\",\r\n\t\t\t\tbundleName = match[5] || match[4],\r\n\t\t\t\tbundlePathAndName = bundlePath + bundleName,\r\n\t\t\t\tlocaleSpecified = (match[5] && match[4]),\r\n\t\t\t\ttargetLocale =\tlocaleSpecified || dojo.locale || \"\",\r\n\t\t\t\tloadTarget = bundlePathAndName + \"/\" + targetLocale,\r\n\t\t\t\tloadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),\r\n\t\t\t\tremaining = loadList.length,\r\n\t\t\t\tfinish = function(){\r\n\t\t\t\t\tif(!--remaining){\r\n\t\t\t\t\t\tload(lang.delegate(cache[loadTarget]));\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\tarray.forEach(loadList, function(locale){\r\n\t\t\t\tvar target = bundlePathAndName + \"/\" + locale;\r\n\t\t\t\tif(has(\"dojo-preload-i18n-Api\")){\r\n\t\t\t\t\tcheckForLegacyModules(target);\r\n\t\t\t\t}\r\n\t\t\t\tif(!cache[target]){\r\n\t\t\t\t\tdoLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfinish();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\r\n\tif(has(\"dojo-unit-tests\")){\r\n\t\tvar unitTests = thisModule.unitTests = [];\r\n\t}\r\n\r\n\tif(has(\"dojo-preload-i18n-Api\") || has(\"dojo-v1x-i18n-Api\")){\r\n\t\tvar normalizeLocale = thisModule.normalizeLocale = function(locale){\r\n\t\t\t\tvar result = locale ? locale.toLowerCase() : dojo.locale;\r\n\t\t\t\treturn result == \"root\" ? \"ROOT\" : result;\r\n\t\t\t},\r\n\r\n\t\t\tisXd = function(mid, contextRequire){\r\n\t\t\t\treturn (has(\"dojo-sync-loader\") && has(\"dojo-v1x-i18n-Api\")) ?\r\n\t\t\t\t\tcontextRequire.isXdUrl(require.toUrl(mid + \".js\")) :\r\n\t\t\t\t\ttrue;\r\n\t\t\t},\r\n\r\n\t\t\tpreloading = 0,\r\n\r\n\t\t\tpreloadWaitQueue = [],\r\n\r\n\t\t\tpreloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tLoad available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)\r\n\t\t\t\t// description:\r\n\t\t\t\t//\t\tOnly called by built layer files. The entire locale hierarchy is loaded. For example,\r\n\t\t\t\t//\t\tif locale==\"ab-cd\", then ROOT, \"ab\", and \"ab-cd\" are loaded. This is different than v1.6-\r\n\t\t\t\t//\t\tin that the v1.6- would only load ab-cd...which was *always* flattened.\r\n\t\t\t\t//\r\n\t\t\t\t//\t\tIf guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm\r\n\t\t\t\t//\t\tand the extra possible extra transaction.\r\n\r\n\t\t\t\t// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function\r\n\t\t\t\t// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which\r\n\t\t\t\t// itself may have been mapped.\r\n\t\t\t\tcontextRequire = contextRequire || require;\r\n\r\n\t\t\t\tfunction doRequire(mid, callback){\r\n\t\t\t\t\tif(isXd(mid, contextRequire) || guaranteedAmdFormat){\r\n\t\t\t\t\t\tcontextRequire([mid], callback);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tsyncRequire([mid], callback, contextRequire);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction forEachLocale(locale, func){\r\n\t\t\t\t\t// given locale= \"ab-cd-ef\", calls func on \"ab-cd-ef\", \"ab-cd\", \"ab\", \"ROOT\"; stops calling the first time func returns truthy\r\n\t\t\t\t\tvar parts = locale.split(\"-\");\r\n\t\t\t\t\twhile(parts.length){\r\n\t\t\t\t\t\tif(func(parts.join(\"-\"))){\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparts.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunc(\"ROOT\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\tfunction preloadingAddLock(){\r\n\t\t\t\t\t\tpreloading++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfunction preloadingRelLock(){\r\n\t\t\t\t\t\t--preloading;\r\n\t\t\t\t\t\twhile(!preloading && preloadWaitQueue.length){\r\n\t\t\t\t\t\t\tload.apply(null, preloadWaitQueue.shift());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfunction cacheId(path, name, loc, require){\r\n\t\t\t\t\t\t// path is assumed to have a trailing \"/\"\r\n\t\t\t\t\t\treturn require.toAbsMid(path + name + \"/\" + loc)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfunction preload(locale){\r\n\t\t\t\t\t\tlocale = normalizeLocale(locale);\r\n\t\t\t\t\t\tforEachLocale(locale, function(loc){\r\n\t\t\t\t\t\t\tif(array.indexOf(localesGenerated, loc) >= 0){\r\n\t\t\t\t\t\t\t\tvar mid = bundlePrefix.replace(/\\./g, \"/\") + \"_\" + loc;\r\n\t\t\t\t\t\t\t\tpreloadingAddLock();\r\n\t\t\t\t\t\t\t\tdoRequire(mid, function(rollup){\r\n\t\t\t\t\t\t\t\t\tfor(var p in rollup){\r\n\t\t\t\t\t\t\t\t\t\tvar bundle = rollup[p],\r\n\t\t\t\t\t\t\t\t\t\t\tmatch = p.match(/(.+)\\/([^\\/]+)$/),\r\n\t\t\t\t\t\t\t\t\t\t\tbundleName, bundlePath;\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// If there is no match, the bundle is not a regular bundle from an AMD layer.\r\n\t\t\t\t\t\t\t\t\t\t\tif (!match){continue;}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbundleName = match[2];\r\n\t\t\t\t\t\t\t\t\t\t\tbundlePath = match[1] + \"/\";\r\n\r\n\t\t\t\t\t\t\t\t\t\t// backcompat\r\n\t\t\t\t\t\t\t\t\t\tbundle._localized = bundle._localized || {};\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar localized;\r\n\t\t\t\t\t\t\t\t\t\tif(loc === \"ROOT\"){\r\n\t\t\t\t\t\t\t\t\t\t\tvar root = localized = bundle._localized;\r\n\t\t\t\t\t\t\t\t\t\t\tdelete bundle._localized;\r\n\t\t\t\t\t\t\t\t\t\t\troot.root = bundle;\r\n\t\t\t\t\t\t\t\t\t\t\tcache[require.toAbsMid(p)] = root;\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\tlocalized = bundle._localized;\r\n\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, loc, require)] = bundle;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif(loc !== locale){\r\n\t\t\t\t\t\t\t\t\t\t\t// capture some locale variables\r\n\t\t\t\t\t\t\t\t\t\t\tfunction improveBundle(bundlePath, bundleName, bundle, localized){\r\n\t\t\t\t\t\t\t\t\t\t\t\t// locale was not flattened and we've fallen back to a less-specific locale that was flattened\r\n\t\t\t\t\t\t\t\t\t\t\t\t// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and\r\n\t\t\t\t\t\t\t\t\t\t\t\t// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by\r\n\t\t\t\t\t\t\t\t\t\t\t\t// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'\r\n\t\t\t\t\t\t\t\t\t\t\t\t// version of the bundle.\r\n\t\t\t\t\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Remember, different bundles may have different sets of locales available.\r\n\t\t\t\t\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t\t\t\t\t// we are really falling back on the regular algorithm here, but--hopefully--starting with most\r\n\t\t\t\t\t\t\t\t\t\t\t\t// of the required bundles already on board as given by the rollup and we need to \"manually\" load\r\n\t\t\t\t\t\t\t\t\t\t\t\t// only one locale from a few bundles...or even better...we won't find anything better to load.\r\n\t\t\t\t\t\t\t\t\t\t\t\t// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.\r\n\t\t\t\t\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t\t\t\t\t// note: this feature is only available in async mode\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// inspect the loaded bundle that came from the rollup to see if something better is available\r\n\t\t\t\t\t\t\t\t\t\t\t\t// for any bundle in a rollup, more-specific available locales are given at localized.\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar requiredBundles = [],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheIds = [];\r\n\t\t\t\t\t\t\t\t\t\t\t\tforEachLocale(locale, function(loc){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(localized[loc]){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequiredBundles.push(require.toAbsMid(bundlePath + loc + \"/\" + bundleName));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcacheIds.push(cacheId(bundlePath, bundleName, loc, require));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(requiredBundles.length){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpreloadingAddLock();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontextRequire(requiredBundles, function(){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(var i = 0; i < requiredBundles.length; i++){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbundle = lang.mixin(lang.clone(bundle), arguments[i]);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheIds[i]] = bundle;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// this is the best possible (maybe a perfect match, maybe not), accept it\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpreloadingRelLock();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// this is the best possible (definitely not a perfect match), accept it\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, locale, require)] = bundle;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\timproveBundle(bundlePath, bundleName, bundle, localized);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tpreloadingRelLock();\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tpreload();\r\n\t\t\t\tarray.forEach(dojo.config.extraLocale, preload);\r\n\t\t\t},\r\n\r\n\t\t\twaitForPreloads = function(id, require, load){\r\n\t\t\t\tif(preloading){\r\n\t\t\t\t\tpreloadWaitQueue.push([id, require, load]);\r\n\t\t\t\t}\r\n\t\t\t\treturn preloading;\r\n\t\t\t},\r\n\r\n\t\t\tcheckForLegacyModules = function()\r\n\t\t\t\t{};\r\n\t}\r\n\r\n\tif(has(\"dojo-v1x-i18n-Api\")){\r\n\t\t// this code path assumes the dojo loader and won't work with a standard AMD loader\r\n\t\tvar amdValue = {},\r\n\t\t\tevalBundle =\r\n\t\t\t\t// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)\r\n\t\t\t\tnew Function(\r\n\t\t\t\t\t\"__bundle\",\t\t\t\t   // the bundle to evalutate\r\n\t\t\t\t\t\"__checkForLegacyModules\", // a function that checks if __bundle defined __mid in the global space\r\n\t\t\t\t\t\"__mid\",\t\t\t\t   // the mid that __bundle is intended to define\r\n\t\t\t\t\t\"__amdValue\",\r\n\r\n\t\t\t\t\t// returns one of:\r\n\t\t\t\t\t//\t\t1 => the bundle was an AMD bundle\r\n\t\t\t\t\t//\t\ta legacy bundle object that is the value of __mid\r\n\t\t\t\t\t//\t\tinstance of Error => could not figure out how to evaluate bundle\r\n\r\n\t\t\t\t\t  // used to detect when __bundle calls define\r\n\t\t\t\t\t  \"var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},\"\r\n\t\t\t\t\t+ \"\t   require = function(){define.called = 1;};\"\r\n\r\n\t\t\t\t\t+ \"try{\"\r\n\t\t\t\t\t+\t\t\"define.called = 0;\"\r\n\t\t\t\t\t+\t\t\"eval(__bundle);\"\r\n\t\t\t\t\t+\t\t\"if(define.called==1)\"\r\n\t\t\t\t\t\t\t\t// bundle called define; therefore signal it's an AMD bundle\r\n\t\t\t\t\t+\t\t\t\"return __amdValue;\"\r\n\r\n\t\t\t\t\t+\t\t\"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))\"\r\n\t\t\t\t\t\t\t\t// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space\r\n\t\t\t\t\t+\t\t\t\"return __checkForLegacyModules;\"\r\n\r\n\t\t\t\t\t+ \"}catch(e){}\"\r\n\t\t\t\t\t// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle\r\n\t\t\t\t\t// either way, re-eval *after* surrounding with parentheses\r\n\r\n\t\t\t\t\t+ \"try{\"\r\n\t\t\t\t\t+\t\t\"return eval('('+__bundle+')');\"\r\n\t\t\t\t\t+ \"}catch(e){\"\r\n\t\t\t\t\t+\t\t\"return e;\"\r\n\t\t\t\t\t+ \"}\"\r\n\t\t\t\t),\r\n\r\n\t\t\tsyncRequire = function(deps, callback, require){\r\n\t\t\t\tvar results = [];\r\n\t\t\t\tarray.forEach(deps, function(mid){\r\n\t\t\t\t\tvar url = require.toUrl(mid + \".js\");\r\n\r\n\t\t\t\t\tfunction load(text){\r\n\t\t\t\t\t\tvar result = evalBundle(text, checkForLegacyModules, mid, amdValue);\r\n\t\t\t\t\t\tif(result===amdValue){\r\n\t\t\t\t\t\t\t// the bundle was an AMD module; re-inject it through the normal AMD path\r\n\t\t\t\t\t\t\t// we gotta do this since it could be an anonymous module and simply evaluating\r\n\t\t\t\t\t\t\t// the text here won't provide the loader with the context to know what\r\n\t\t\t\t\t\t\t// module is being defined()'d. With browser caching, this should be free; further\r\n\t\t\t\t\t\t\t// this entire code path can be circumvented by using the AMD format to begin with\r\n\t\t\t\t\t\t\tresults.push(cache[url] = amdValue.result);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(result instanceof Error){\r\n\t\t\t\t\t\t\t\tconsole.error(\"failed to evaluate i18n bundle; url=\" + url, result);\r\n\t\t\t\t\t\t\t\tresult = {};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// nls/<locale>/<bundle-name> indicates not the root.\r\n\t\t\t\t\t\t\tresults.push(cache[url] = (/nls\\/[^\\/]+\\/[^\\/]+$/.test(url) ? result : {root:result, _v1x:1}));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(cache[url]){\r\n\t\t\t\t\t\tresults.push(cache[url]);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar bundle = require.syncLoadNls(mid);\r\n\t\t\t\t\t\t// don't need to check for legacy since syncLoadNls returns a module if the module\r\n\t\t\t\t\t\t// (1) was already loaded, or (2) was in the cache. In case 1, if syncRequire is called\r\n\t\t\t\t\t\t// from getLocalization --> load, then load will have called checkForLegacyModules() before\r\n\t\t\t\t\t\t// calling syncRequire; if syncRequire is called from preloadLocalizations, then we\r\n\t\t\t\t\t\t// don't care about checkForLegacyModules() because that will be done when a particular\r\n\t\t\t\t\t\t// bundle is actually demanded. In case 2, checkForLegacyModules() is never relevant\r\n\t\t\t\t\t\t// because cached modules are always v1.7+ built modules.\r\n\t\t\t\t\t\tif(bundle){\r\n\t\t\t\t\t\t\tresults.push(bundle);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(!xhr){\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\trequire.getText(url, true, load);\r\n\t\t\t\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\t\t\t\tresults.push(cache[url] = {});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\txhr.get({\r\n\t\t\t\t\t\t\t\t\turl:url,\r\n\t\t\t\t\t\t\t\t\tsync:true,\r\n\t\t\t\t\t\t\t\t\tload:load,\r\n\t\t\t\t\t\t\t\t\terror:function(){\r\n\t\t\t\t\t\t\t\t\t\tresults.push(cache[url] = {});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tcallback && callback.apply(null, results);\r\n\t\t\t};\r\n\r\n\t\tcheckForLegacyModules = function(target){\r\n\t\t\t// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache\r\n\t\t\tfor(var result, names = target.split(\"/\"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}\r\n\t\t\tif(object){\r\n\t\t\t\tresult = object[names[i]];\r\n\t\t\t\tif(!result){\r\n\t\t\t\t\t// fallback for incorrect bundle build of 1.6\r\n\t\t\t\t\tresult = object[names[i].replace(/-/g,\"_\")];\r\n\t\t\t\t}\r\n\t\t\t\tif(result){\r\n\t\t\t\t\tcache[target] = result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tthisModule.getLocalization = function(moduleName, bundleName, locale){\r\n\t\t\tvar result,\r\n\t\t\t\tl10nName = getBundleName(moduleName, bundleName, locale);\r\n\t\t\tload(\r\n\t\t\t\tl10nName,\r\n\r\n\t\t\t\t// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.\r\n\t\t\t\t// Since this legacy function does not have the concept of a reference module, resolve with respect to this\r\n\t\t\t\t// dojo/i18n module, which, itself may have been mapped.\r\n\t\t\t\t(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),\r\n\r\n\t\t\t\tfunction(result_){ result = result_; }\r\n\t\t\t);\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tif(has(\"dojo-unit-tests\")){\r\n\t\t\tunitTests.push(function(doh){\r\n\t\t\t\tdoh.register(\"tests.i18n.unit\", function(t){\r\n\t\t\t\t\tvar check;\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"{prop:1}\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is({prop:1}, check); t.is(undefined, check[1]);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"({prop:1})\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is({prop:1}, check); t.is(undefined, check[1]);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"{'prop-x':1}\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is({'prop-x':1}, check); t.is(undefined, check[1]);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"({'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is({'prop-x':1}, check); t.is(undefined, check[1]);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"define({'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"define('some/module', {'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);\r\n\r\n\t\t\t\t\tcheck = evalBundle(\"this is total nonsense and should throw an error\", checkForLegacyModules, \"nonsense\", amdValue);\r\n\t\t\t\t\tt.is(check instanceof Error, true);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn lang.mixin(thisModule, {\r\n\t\tdynamic:true,\r\n\t\tnormalize:normalize,\r\n\t\tload:load,\r\n\t\tcache:cache,\r\n\t\tgetL10nName: getL10nName\r\n\t});\r\n});\r\n"]}