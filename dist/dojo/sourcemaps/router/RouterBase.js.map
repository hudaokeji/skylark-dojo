{"version":3,"sources":["router/RouterBase.js"],"names":["define","declare","hash","topic","trim","fireRoute","params","currentPath","newPath","queue","isStopped","isPrevented","callbackArgs","i","l","this","callbackQueue","stopImmediatePropagation","preventDefault","oldPath","Array","concat","key","push","length","apply","String","prototype","str","replace","_routes","_routeIndex","_started","_currentPath","idMatch","idReplacement","globMatch","globReplacement","constructor","kwArgs","hasOwnProperty","register","route","callback","_registerRoute","registerBefore","go","path","applyChange","_handlePathChange","startup","defaultPath","self","startingPath","_hashchangeHandle","subscribe","arguments","destroy","remove","j","li","lj","routeObj","result","allowChange","parameterNames","routes","exec","slice","fire","_convertRouteToRegExp","RegExp","_getParameterNames","match","lastIndex","_indexRoutes","routeIndex","isBefore","index","exists","removed","unshift","splice"],"mappings":";;;;;;;AAAAA,QACC,qBACA,YACA,cACE,SAASC,EAASC,EAAMC,GAO1B,IAAIC,EAUJ,SAASC,EAAUC,EAAQC,EAAaC,GACvC,IAAIC,EAAOC,EAAWC,EAAuBC,EAAcC,EAAGC,EAe9D,GAbAL,EAAQM,KAAKC,cACbN,GAAY,EACZC,GAAc,EASdC,IAPCK,yBAA0B,WAAYP,GAAY,GAClDQ,eAAgB,WAAYP,GAAc,GAC1CQ,QAASZ,EACTC,QAASA,EACTF,OAAQA,IAKNA,aAAkBc,MACpBR,EAAeA,EAAaS,OAAOf,QAEnC,IAAI,IAAIgB,KAAOhB,EACdM,EAAaW,KAAKjB,EAAOgB,IAI3B,IAAIT,EAAE,EAAGC,EAAEL,EAAMe,OAAQX,EAAEC,IAAKD,EAC3BH,GACHD,EAAMI,GAAGY,MAAM,KAAMb,GAIvB,OAAQD,EAqUT,OA3WCP,EADEsB,OAAOC,UAAUvB,KACZ,SAASwB,GAAM,OAAOA,EAAIxB,QAE1B,SAASwB,GAAM,OAAOA,EAAIC,QAAQ,SAAU,IAAIA,QAAQ,SAAU,KAwCzD5B,EAAQ,MAkBxB6B,QAAS,KACTC,YAAa,KACbC,UAAU,EACVC,aAAc,GAEdC,QAAS,gBACTC,cAAe,YACfC,UAAW,gBACXC,gBAAiB,OAEjBC,YAAa,SAASC,GAMrB,IAAI,IAAI1B,KAJRE,KAAKe,WACLf,KAAKgB,eAGQQ,EACTA,EAAOC,eAAe3B,KACxBE,KAAKF,GAAK0B,EAAO1B,KAKpB4B,SAAU,SAA2BC,EAAoBC,GA6DxD,OAAO5B,KAAK6B,eAAeF,EAAOC,IAGnCE,eAAgB,SAA2BH,EAAoBC,GAU9D,OAAO5B,KAAK6B,eAAeF,EAAOC,GAAU,IAG7CG,GAAI,SAASC,EAAMlB,GAQlB,IAAImB,EAEJ,MAAmB,iBAATD,IAEVA,EAAO3C,EAAK2C,IACZC,EAAcjC,KAAKkC,kBAAkBF,KAGpC7C,EAAK6C,EAAMlB,GAGLmB,IAGRE,QAAS,SAASC,GAMjB,IAAGpC,KAAKiB,SAAR,CAEA,IAAIoB,EAAOrC,KACVsC,EAAenD,IAEhBa,KAAKiB,UAAW,EAChBjB,KAAKuC,kBAAoBnD,EAAMoD,UAAU,mBAAoB,WAC5DH,EAAKH,kBAAkBxB,MAAM2B,EAAMI,aAGhCH,EAMHtC,KAAKkC,kBAAkBI,GAHvBtC,KAAK+B,GAAGK,GAAa,KAOvBM,QAAS,WACL1C,KAAKuC,mBACPvC,KAAKuC,kBAAkBI,SAExB3C,KAAKe,QAAU,KACff,KAAKgB,YAAc,MAGpBkB,kBAAmB,SAASzC,GAC3B,IAAIK,EAAG8C,EAAGC,EAAIC,EAAIC,EAAUC,EAC3BC,EAAaC,EAAgB3D,EAC7B4D,EAASnD,KAAKe,QACdvB,EAAcQ,KAAKkB,aAEpB,IAAIlB,KAAKiB,UAAYxB,IAAYD,EAAc,OAAOyD,EAItD,IAFAA,GAAc,EAEVnD,EAAE,EAAG+C,EAAGM,EAAO1C,OAAQX,EAAE+C,IAAM/C,EAIlC,GAFAkD,GADAD,EAAWI,EAAOrD,IACA6B,MAAMyB,KAAK3D,GAEnB,CACT,GAAGsD,EAASG,eAIX,IAFA3D,KAEIqD,EAAE,EAAGE,GAHTI,EAAiBH,EAASG,gBAGCzC,OAAQmC,EAAEE,IAAMF,EAC1CrD,EAAO2D,EAAeN,IAAMI,EAAOJ,EAAE,QAGtCrD,EAASyD,EAAOK,MAAM,GAEvBJ,EAAcF,EAASO,KAAK/D,EAAQC,EAAaC,GAQnD,OAJGwD,IACFjD,KAAKkB,aAAezB,GAGdwD,GAGRM,sBAAuB,SAAS5B,GAO/B,OAFAA,EAAQ,KAFRA,GADAA,EAAQA,EAAMb,QAAQd,KAAKmB,QAASnB,KAAKoB,gBAC3BN,QAAQd,KAAKqB,UAAWrB,KAAKsB,kBAErB,IAEf,IAAIkC,OAAO7B,IAGnB8B,mBAAoB,SAAS9B,GAC5B,IAEsB+B,EAFlBvC,EAAUnB,KAAKmB,QAClBE,EAAYrB,KAAKqB,UACjB6B,KAID,IAFA/B,EAAQwC,UAAY,EAEoB,QAAjCD,EAAQvC,EAAQiC,KAAKzB,KAC3BuB,EAAe1C,KAAKkD,EAAM,IAM3B,OAJuC,QAAnCA,EAAQrC,EAAU+B,KAAKzB,KAC1BuB,EAAe1C,KAAKkD,EAAM,IAGpBR,EAAezC,OAAS,EAAIyC,EAAiB,MAGrDU,aAAc,WACb,IAAI9D,EAAGC,EAAU8D,EAAYV,EAASnD,KAAKe,QAM3C,IAHA8C,EAAa7D,KAAKgB,eAGdlB,EAAE,EAAGC,EAAEoD,EAAO1C,OAAQX,EAAEC,IAAKD,EAEhC+D,EADQV,EAAOrD,GACE6B,OAAS7B,GAI5B+B,eAAgB,SAA0BF,EAAmBC,EAAsBkC,GAClF,IAAIC,EAAOC,EAAQjB,EAAU9C,EAAegE,EAC3C5B,EAAOrC,KAAMmD,EAASnD,KAAKe,QAC3B8C,EAAa7D,KAAKgB,YAyCnB,OApCAgD,OAA0B,KAD1BD,EAAQ/D,KAAKgB,YAAYW,OAGxBoB,EAAWI,EAAOY,IAIfhB,IACHA,GACCpB,MAAOA,EACP1B,iBACAqD,KAAMhE,IAIRW,EAAgB8C,EAAS9C,cAEN,iBAAT0B,IACToB,EAASG,eAAiBlD,KAAKyD,mBAAmB9B,GAClDoB,EAASpB,MAAQ3B,KAAKuD,sBAAsB5B,IAG1CmC,EACF7D,EAAciE,QAAQtC,GAEtB3B,EAAcO,KAAKoB,GAGhBoC,IACHD,EAAQZ,EAAO1C,OACfoD,EAAWlC,GAASoC,EACpBZ,EAAO3C,KAAKuC,IAIbkB,GAAU,GAGTtB,OAAQ,WACP,IAAI7C,EAAGC,EAEP,IAAGkE,EAAH,CAEA,IAAInE,EAAE,EAAGC,EAAEE,EAAcQ,OAAQX,EAAEC,IAAKD,EACpCG,EAAcH,KAAO8B,GACvB3B,EAAckE,OAAOrE,EAAG,GAKE,IAAzBG,EAAcQ,SAChB0C,EAAOgB,OAAOJ,EAAO,GACrB1B,EAAKuB,gBAGNK,GAAU,IAEXvC,SAAU,SAASE,EAAUkC,GAC5B,OAAOzB,EAAKX,SAASC,EAAOC,EAAUkC","file":"../../router/RouterBase.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/hash\",\r\n\t\"dojo/topic\"\r\n], function(declare, hash, topic){\r\n\r\n\t// module:\r\n\t//\t\tdojo/router/RouterBase\r\n\r\n\t// Creating a basic trim to avoid needing the full dojo/string module\r\n\t// similarly to dojo/_base/lang's trim\r\n\tvar trim;\r\n\tif(String.prototype.trim){\r\n\t\ttrim = function(str){ return str.trim(); };\r\n\t}else{\r\n\t\ttrim = function(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); };\r\n\t}\r\n\r\n\t// Firing of routes on the route object is always the same,\r\n\t// no clean way to expose this on the prototype since it's for the\r\n\t// internal router objects.\r\n\tfunction fireRoute(params, currentPath, newPath){\r\n\t\tvar queue, isStopped, isPrevented, eventObj, callbackArgs, i, l;\r\n\r\n\t\tqueue = this.callbackQueue;\r\n\t\tisStopped = false;\r\n\t\tisPrevented = false;\r\n\t\teventObj = {\r\n\t\t\tstopImmediatePropagation: function(){ isStopped = true; },\r\n\t\t\tpreventDefault: function(){ isPrevented = true; },\r\n\t\t\toldPath: currentPath,\r\n\t\t\tnewPath: newPath,\r\n\t\t\tparams: params\r\n\t\t};\r\n\r\n\t\tcallbackArgs = [eventObj];\r\n\r\n\t\tif(params instanceof Array){\r\n\t\t\tcallbackArgs = callbackArgs.concat(params);\r\n\t\t}else{\r\n\t\t\tfor(var key in params){\r\n\t\t\t\tcallbackArgs.push(params[key]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(i=0, l=queue.length; i<l; ++i){\r\n\t\t\tif(!isStopped){\r\n\t\t\t\tqueue[i].apply(null, callbackArgs);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn !isPrevented;\r\n\t}\r\n\r\n\t// Our actual class-like object\r\n\tvar RouterBase = declare(null, {\r\n\t\t// summary:\r\n\t\t//\t\tA module that allows one to easily map hash-based structures into\r\n\t\t//\t\tcallbacks. The router module is a singleton, offering one central\r\n\t\t//\t\tpoint for all registrations of this type.\r\n\t\t// example:\r\n\t\t//\t|\tvar router = new RouterBase({});\r\n\t\t//\t|\trouter.register(\"/widgets/:id\", function(evt){\r\n\t\t//\t|\t\t// If \"/widgets/3\" was matched,\r\n\t\t//\t|\t\t// evt.params.id === \"3\"\r\n\t\t//\t|\t\txhr.get({\r\n\t\t//\t|\t\t\turl: \"/some/path/\" + evt.params.id,\r\n\t\t//\t|\t\t\tload: function(data){\r\n\t\t//\t|\t\t\t\t// ...\r\n\t\t//\t|\t\t\t}\r\n\t\t//\t|\t\t});\r\n\t\t//\t|\t});\r\n\r\n\t\t_routes: null,\r\n\t\t_routeIndex: null,\r\n\t\t_started: false,\r\n\t\t_currentPath: \"\",\r\n\r\n\t\tidMatch: /:(\\w[\\w\\d]*)/g,\r\n\t\tidReplacement: \"([^\\\\/]+)\",\r\n\t\tglobMatch: /\\*(\\w[\\w\\d]*)/,\r\n\t\tglobReplacement: \"(.+)\",\r\n\r\n\t\tconstructor: function(kwArgs){\r\n\t\t\t// A couple of safety initializations\r\n\t\t\tthis._routes = [];\r\n\t\t\tthis._routeIndex = {};\r\n\r\n\t\t\t// Simple constructor-style \"Decorate myself all over\" for now\r\n\t\t\tfor(var i in kwArgs){\r\n\t\t\t\tif(kwArgs.hasOwnProperty(i)){\r\n\t\t\t\t\tthis[i] = kwArgs[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tregister: function(/*String|RegExp*/ route, /*Function*/ callback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRegisters a route to a handling callback\r\n\t\t\t// description:\r\n\t\t\t//\t\tGiven either a string or a regular expression, the router\r\n\t\t\t//\t\twill monitor the page's hash and respond to changes that\r\n\t\t\t//\t\tmatch the string or regex as provided.\r\n\t\t\t//\r\n\t\t\t//\t\tWhen provided a regex for the route:\r\n\t\t\t//\r\n\t\t\t//\t\t- Matching is performed, and the resulting capture groups\r\n\t\t\t//\t\tare passed through to the callback as an array.\r\n\t\t\t//\r\n\t\t\t//\t\tWhen provided a string for the route:\r\n\t\t\t//\r\n\t\t\t//\t\t- The string is parsed as a URL-like structure, like\r\n\t\t\t//\t\t\"/foo/bar\"\r\n\t\t\t//\t\t- If any portions of that URL are prefixed with a colon\r\n\t\t\t//\t\t(:), they will be parsed out and provided to the callback\r\n\t\t\t//\t\tas properties of an object.\r\n\t\t\t//\t\t- If the last piece of the URL-like structure is prefixed\r\n\t\t\t//\t\twith a star (*) instead of a colon, it will be replaced in\r\n\t\t\t//\t\tthe resulting regex with a greedy (.+) match and\r\n\t\t\t//\t\tanything remaining on the hash will be provided as a\r\n\t\t\t//\t\tproperty on the object passed into the callback. Think of\r\n\t\t\t//\t\tit like a basic means of globbing the end of a route.\r\n\t\t\t// example:\r\n\t\t\t//\t|\trouter.register(\"/foo/:bar/*baz\", function(object){\r\n\t\t\t//\t|\t\t// If the hash was \"/foo/abc/def/ghi\",\r\n\t\t\t//\t|\t\t// object.bar === \"abc\"\r\n\t\t\t//\t|\t\t// object.baz === \"def/ghi\"\r\n\t\t\t//\t|\t});\r\n\t\t\t// returns: Object\r\n\t\t\t//\t\tA plain JavaScript object to be used as a handle for\r\n\t\t\t//\t\teither removing this specific callback's registration, as\r\n\t\t\t//\t\twell as to add new callbacks with the same route initially\r\n\t\t\t//\t\tused.\r\n\t\t\t// route: String|RegExp\r\n\t\t\t//\t\tA string or regular expression which will be used when\r\n\t\t\t//\t\tmonitoring hash changes.\r\n\t\t\t// callback: Function\r\n\t\t\t//\t\tWhen the hash matches a pattern as described in the route,\r\n\t\t\t//\t\tthis callback will be executed. It will receive an event\r\n\t\t\t//\t\tobject that will have several properties:\r\n\t\t\t//\r\n\t\t\t//\t\t- params: Either an array or object of properties pulled\r\n\t\t\t//\t\tfrom the new hash\r\n\t\t\t//\t\t- oldPath: The hash in its state before the change\r\n\t\t\t//\t\t- newPath: The new hash being shifted to\r\n\t\t\t//\t\t- preventDefault: A method that will stop hash changes\r\n\t\t\t//\t\tfrom being actually applied to the active hash. This only\r\n\t\t\t//\t\tworks if the hash change was initiated using `router.go`,\r\n\t\t\t//\t\tas changes initiated more directly to the location.hash\r\n\t\t\t//\t\tproperty will already be in place\r\n\t\t\t//\t\t- stopImmediatePropagation: When called, will stop any\r\n\t\t\t//\t\tfurther bound callbacks on this particular route from\r\n\t\t\t//\t\tbeing executed. If two distinct routes are bound that are\r\n\t\t\t//\t\tdifferent, but both happen to match the current hash in\r\n\t\t\t//\t\tsome way, this will *not* keep other routes from receiving\r\n\t\t\t//\t\tnotice of the change.\r\n\r\n\t\t\treturn this._registerRoute(route, callback);\r\n\t\t},\r\n\r\n\t\tregisterBefore: function(/*String|RegExp*/ route, /*Function*/ callback){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRegisters a route to a handling callback, except before\r\n\t\t\t//\t\tany previously registered callbacks\r\n\t\t\t// description:\r\n\t\t\t//\t\tMuch like the `register` method, `registerBefore` allows\r\n\t\t\t//\t\tus to register route callbacks to happen before any\r\n\t\t\t//\t\tpreviously registered callbacks. See the documentation for\r\n\t\t\t//\t\t`register` for more details and examples.\r\n\r\n\t\t\treturn this._registerRoute(route, callback, true);\r\n\t\t},\r\n\r\n\t\tgo: function(path, replace){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tA simple pass-through to make changing the hash easy,\r\n\t\t\t//\t\twithout having to require dojo/hash directly. It also\r\n\t\t\t//\t\tsynchronously fires off any routes that match.\r\n\t\t\t// example:\r\n\t\t\t//\t|\trouter.go(\"/foo/bar\");\r\n\r\n\t\t\tvar applyChange;\r\n\r\n\t\t\tif(typeof path !== \"string\"){return false;}\r\n\r\n\t\t\tpath = trim(path);\r\n\t\t\tapplyChange = this._handlePathChange(path);\r\n\r\n\t\t\tif(applyChange){\r\n\t\t\t\thash(path, replace);\r\n\t\t\t}\r\n\r\n\t\t\treturn applyChange;\r\n\t\t},\r\n\r\n\t\tstartup: function(defaultPath){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis method must be called to activate the router. Until\r\n\t\t\t//\t\tstartup is called, no hash changes will trigger route\r\n\t\t\t//\t\tcallbacks.\r\n\r\n\t\t\tif(this._started){ return; }\r\n\r\n\t\t\tvar self = this,\r\n\t\t\t\tstartingPath = hash();\r\n\r\n\t\t\tthis._started = true;\r\n\t\t\tthis._hashchangeHandle = topic.subscribe(\"/dojo/hashchange\", function(){\r\n\t\t\t\tself._handlePathChange.apply(self, arguments);\r\n\t\t\t});\r\n\r\n\t\t\tif(!startingPath){\r\n\t\t\t\t// If there is no initial starting point, push our defaultPath into our\r\n\t\t\t\t// history as the starting point\r\n\t\t\t\tthis.go(defaultPath, true);\r\n\t\t\t}else{\r\n\t\t\t\t// Handle the starting path\r\n\t\t\t\tthis._handlePathChange(startingPath);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tif(this._hashchangeHandle){\r\n\t\t\t\tthis._hashchangeHandle.remove();\r\n\t\t\t} \t\t\t\r\n\t\t\tthis._routes = null;\r\n\t\t\tthis._routeIndex = null;\r\n\t\t},\r\n\r\n\t\t_handlePathChange: function(newPath){\r\n\t\t\tvar i, j, li, lj, routeObj, result,\r\n\t\t\t\tallowChange, parameterNames, params,\r\n\t\t\t\troutes = this._routes,\r\n\t\t\t\tcurrentPath = this._currentPath;\r\n\r\n\t\t\tif(!this._started || newPath === currentPath){ return allowChange; }\r\n\r\n\t\t\tallowChange = true;\r\n\r\n\t\t\tfor(i=0, li=routes.length; i<li; ++i){\r\n\t\t\t\trouteObj = routes[i];\r\n\t\t\t\tresult = routeObj.route.exec(newPath);\r\n\r\n\t\t\t\tif(result){\r\n\t\t\t\t\tif(routeObj.parameterNames){\r\n\t\t\t\t\t\tparameterNames = routeObj.parameterNames;\r\n\t\t\t\t\t\tparams = {};\r\n\r\n\t\t\t\t\t\tfor(j=0, lj=parameterNames.length; j<lj; ++j){\r\n\t\t\t\t\t\t\tparams[parameterNames[j]] = result[j+1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tparams = result.slice(1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tallowChange = routeObj.fire(params, currentPath, newPath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(allowChange){\r\n\t\t\t\tthis._currentPath = newPath;\r\n\t\t\t}\r\n\r\n\t\t\treturn allowChange;\r\n\t\t},\r\n\r\n\t\t_convertRouteToRegExp: function(route){\r\n\t\t\t// Sub in based on IDs and globs\r\n\t\t\troute = route.replace(this.idMatch, this.idReplacement);\r\n\t\t\troute = route.replace(this.globMatch, this.globReplacement);\r\n\t\t\t// Make sure it's an exact match\r\n\t\t\troute = \"^\" + route + \"$\";\r\n\r\n\t\t\treturn new RegExp(route);\r\n\t\t},\r\n\r\n\t\t_getParameterNames: function(route){\r\n\t\t\tvar idMatch = this.idMatch,\r\n\t\t\t\tglobMatch = this.globMatch,\r\n\t\t\t\tparameterNames = [], match;\r\n\r\n\t\t\tidMatch.lastIndex = 0;\r\n\r\n\t\t\twhile((match = idMatch.exec(route)) !== null){\r\n\t\t\t\tparameterNames.push(match[1]);\r\n\t\t\t}\r\n\t\t\tif((match = globMatch.exec(route)) !== null){\r\n\t\t\t\tparameterNames.push(match[1]);\r\n\t\t\t}\r\n\r\n\t\t\treturn parameterNames.length > 0 ? parameterNames : null;\r\n\t\t},\r\n\r\n\t\t_indexRoutes: function(){\r\n\t\t\tvar i, l, route, routeIndex, routes = this._routes;\r\n\r\n\t\t\t// Start a new route index\r\n\t\t\trouteIndex = this._routeIndex = {};\r\n\r\n\t\t\t// Set it up again\r\n\t\t\tfor(i=0, l=routes.length; i<l; ++i){\r\n\t\t\t\troute = routes[i];\r\n\t\t\t\trouteIndex[route.route] = i;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_registerRoute: function(/*String|RegExp*/route, /*Function*/callback, /*Boolean?*/isBefore){\r\n\t\t\tvar index, exists, routeObj, callbackQueue, removed,\r\n\t\t\t\tself = this, routes = this._routes,\r\n\t\t\t\trouteIndex = this._routeIndex;\r\n\r\n\t\t\t// Try to fetch the route if it already exists.\r\n\t\t\t// This works thanks to stringifying of regex\r\n\t\t\tindex = this._routeIndex[route];\r\n\t\t\texists = typeof index !== \"undefined\";\r\n\t\t\tif(exists){\r\n\t\t\t\trouteObj = routes[index];\r\n\t\t\t}\r\n\r\n\t\t\t// If we didn't get one, make a default start point\r\n\t\t\tif(!routeObj){\r\n\t\t\t\trouteObj = {\r\n\t\t\t\t\troute: route,\r\n\t\t\t\t\tcallbackQueue: [],\r\n\t\t\t\t\tfire: fireRoute\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tcallbackQueue = routeObj.callbackQueue;\r\n\r\n\t\t\tif(typeof route == \"string\"){\r\n\t\t\t\trouteObj.parameterNames = this._getParameterNames(route);\r\n\t\t\t\trouteObj.route = this._convertRouteToRegExp(route);\r\n\t\t\t}\r\n\r\n\t\t\tif(isBefore){\r\n\t\t\t\tcallbackQueue.unshift(callback);\r\n\t\t\t}else{\r\n\t\t\t\tcallbackQueue.push(callback);\r\n\t\t\t}\r\n\r\n\t\t\tif(!exists){\r\n\t\t\t\tindex = routes.length;\r\n\t\t\t\trouteIndex[route] = index;\r\n\t\t\t\troutes.push(routeObj);\r\n\t\t\t}\r\n\r\n\t\t\t// Useful in a moment to keep from re-removing routes\r\n\t\t\tremoved = false;\r\n\r\n\t\t\treturn { // Object\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tvar i, l;\r\n\r\n\t\t\t\t\tif(removed){ return; }\r\n\r\n\t\t\t\t\tfor(i=0, l=callbackQueue.length; i<l; ++i){\r\n\t\t\t\t\t\tif(callbackQueue[i] === callback){\r\n\t\t\t\t\t\t\tcallbackQueue.splice(i, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif(callbackQueue.length === 0){\r\n\t\t\t\t\t\troutes.splice(index, 1);\r\n\t\t\t\t\t\tself._indexRoutes();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tremoved = true;\r\n\t\t\t\t},\r\n\t\t\t\tregister: function(callback, isBefore){\r\n\t\t\t\t\treturn self.register(route, callback, isBefore);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n\r\n\treturn RouterBase;\r\n});\r\n"]}