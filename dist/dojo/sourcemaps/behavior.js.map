{"version":3,"sources":["behavior.js"],"names":["define","dojo","lang","darray","connect","query","domReady","deprecated","behavior","arrIn","obj","name","_inc","forIn","scope","func","tmpObj","x","call","this","_behaviors","add","behaviorObj","tBehavior","id","cversion","push","isString","isFunction","found","rule","ruleName","_applyToNode","node","action","ruleSetName","publish","arguments","apply","forEach","elem","runFrom","bid","tver","ruleSet","isArray","length"],"mappings":";;;;;;;AAAAA,QAAQ,iBAAkB,eAAgB,gBAAiB,kBAAmB,UAAW,cACzF,SAASC,EAAMC,EAAMC,EAAQC,EAASC,EAAOC,GAK7CL,EAAKM,WAAW,gBAAiB,qDAiPjC,OAJAN,EAAKO,SAAW,IA3OD,WAed,SAASC,EAAMC,EAAKC,GAEnB,OADID,EAAIC,KAAQD,EAAIC,OACbD,EAAIC,GAGZ,IAAIC,EAAO,EAEX,SAASC,EAAMH,EAAKI,EAAOC,GAC1B,IAAIC,KACJ,IAAI,IAAIC,KAAKP,OACW,IAAbM,EAAOC,KACZF,EAGHA,EAAKG,KAAKJ,EAAOJ,EAAIO,GAAIA,GAFzBH,EAAMJ,EAAIO,GAAIA,IASlBE,KAAKC,cACLD,KAAKE,IAAM,SAAqBC,GA8G/BT,EAAMS,EAAaH,KAAM,SAASX,EAAUG,GAC3C,IAAIY,EAAYd,EAAMU,KAAKC,WAAYT,GACV,iBAAnBY,EAAc,KACvBA,EAAUC,GAAKZ,KAEhB,IAAIa,KACJF,EAAUG,KAAKD,IACXvB,EAAKyB,SAASnB,IAAaN,EAAK0B,WAAWpB,MAC9CA,GAAaqB,MAAOrB,IAErBK,EAAML,EAAU,SAASsB,EAAMC,GAC9BtB,EAAMgB,EAAUM,GAAUL,KAAKI,QAKlC,IAAIE,EAAe,SAASC,EAAMC,EAAQC,GACtCjC,EAAKyB,SAASO,GACE,SAAfC,EACF/B,EAAQgC,QAAQF,GAAUD,IAE1B7B,EAAQA,QAAQ6B,EAAME,EAAa,WAClC/B,EAAQgC,QAAQF,EAAQG,aAGlBnC,EAAK0B,WAAWM,KACN,SAAfC,EACFD,EAAOD,GAEP7B,EAAQA,QAAQ6B,EAAME,EAAaD,KAKtCf,KAAKmB,MAAQ,WAuBZzB,EAAMM,KAAKC,WAAY,SAASG,EAAWC,GAC1CnB,EAAMmB,GAAIe,QACT,SAASC,GACR,IAAIC,EAAU,EACVC,EAAM,gBAAgBnB,EAAUC,GACpC,GAAuB,iBAAbgB,EAAKE,KACdD,EAAUD,EAAKE,KACAnB,EAAgB,OAFhC,CAQA,IAAI,IAAeoB,EAAX1B,EAAEwB,EAAeE,EAAOpB,EAAUN,GAAIA,IAC7CJ,EAAM8B,EAAM,SAASC,EAAST,GAC1BjC,EAAK2C,QAAQD,IACfzC,EAAOoC,QAAQK,EAAS,SAASV,GAChCF,EAAaQ,EAAMN,EAAQC,OAO/BK,EAAKE,GAAOnB,EAAUuB,cAS3BxC,EAAU,WAAYL,EAAKO,SAAS8B,UAE7BrC,EAAKO","file":"../behavior.js","sourcesContent":["define([\"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/connect\", \"./query\", \"./domReady\"],\r\nfunction(dojo, lang, darray, connect, query, domReady){\r\n\r\n// module:\r\n//\t\tdojo/behavior\r\n\r\ndojo.deprecated(\"dojo.behavior\", \"Use dojo/on with event delegation (on.selector())\");\r\n\r\nvar Behavior = function(){\r\n\t// summary:\r\n\t//\t\tDeprecated.   dojo/behavior's functionality can be achieved using event delegation using dojo/on\r\n\t//\t\tand on.selector().\r\n\t// description:\r\n\t//\t\tA very simple, lightweight mechanism for applying code to\r\n\t//\t\texisting documents, based around `dojo/query` (CSS3 selectors) for node selection,\r\n\t//\t\tand a simple two-command API: `add()` and `apply()`;\r\n\t//\r\n\t//\t\tBehaviors apply to a given page, and are registered following the syntax\r\n\t//\t\toptions described by `add()` to match nodes to actions, or \"behaviors\".\r\n\t//\r\n\t//\t\tAdded behaviors are applied to the current DOM when .apply() is called,\r\n\t//\t\tmatching only new nodes found since .apply() was last called.\r\n\r\n\tfunction arrIn(obj, name){\r\n\t\tif(!obj[name]){ obj[name] = []; }\r\n\t\treturn obj[name];\r\n\t}\r\n\r\n\tvar _inc = 0;\r\n\r\n\tfunction forIn(obj, scope, func){\r\n\t\tvar tmpObj = {};\r\n\t\tfor(var x in obj){\r\n\t\t\tif(typeof tmpObj[x] == \"undefined\"){\r\n\t\t\t\tif(!func){\r\n\t\t\t\t\tscope(obj[x], x);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfunc.call(scope, obj[x], x);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// FIXME: need a better test so we don't exclude nightly Safari's!\r\n\tthis._behaviors = {};\r\n\tthis.add = function(/* Object */behaviorObj){\r\n\t\t// summary:\r\n\t\t//\t\tAdd the specified behavior to the list of behaviors, ignoring existing\r\n\t\t//\t\tmatches.\r\n\t\t// behaviorObj: Object\r\n\t\t//\t\tThe behavior object that will be added to behaviors list. The behaviors\r\n\t\t//\t\tin the list will be applied the next time apply() is called.\r\n\t\t// description:\r\n\t\t//\t\tAdd the specified behavior to the list of behaviors which will\r\n\t\t//\t\tbe applied the next time apply() is called. Calls to add() for\r\n\t\t//\t\tan already existing behavior do not replace the previous rules,\r\n\t\t//\t\tbut are instead additive. New nodes which match the rule will\r\n\t\t//\t\thave all add()-ed behaviors applied to them when matched.\r\n\t\t//\r\n\t\t//\t\tThe \"found\" method is a generalized handler that's called as soon\r\n\t\t//\t\tas the node matches the selector. Rules for values that follow also\r\n\t\t//\t\tapply to the \"found\" key.\r\n\t\t//\r\n\t\t//\t\tThe \"on*\" handlers are attached with `dojo.connect()`, using the\r\n\t\t//\t\tmatching node\r\n\t\t//\r\n\t\t//\t\tIf the value corresponding to the ID key is a function and not a\r\n\t\t//\t\tlist, it's treated as though it was the value of \"found\".\r\n\t\t//\r\n\t\t//\t\tdojo/behavior.add() can be called any number of times before\r\n\t\t//\t\tthe DOM is ready. `dojo/behavior.apply()` is called automatically\r\n\t\t//\t\tby `dojo.addOnLoad`, though can be called to re-apply previously added\r\n\t\t//\t\tbehaviors anytime the DOM changes.\r\n\t\t//\r\n\t\t//\t\tThere are a variety of formats permitted in the behaviorObject\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tSimple list of properties. \"found\" is special. \"Found\" is assumed if\r\n\t\t//\t\tno property object for a given selector, and property is a function.\r\n\t\t//\r\n\t\t//\t|\tbehavior.add({\r\n\t\t//\t|\t\t\"#id\": {\r\n\t\t//\t|\t\t\t\"found\": function(element){\r\n\t\t//\t|\t\t\t\t// node match found\r\n\t\t//\t|\t\t\t},\r\n\t\t//\t|\t\t\t\"onclick\": function(evt){\r\n\t\t//\t|\t\t\t\t// register onclick handler for found node\r\n\t\t//\t|\t\t\t}\r\n\t\t//\t|\t\t},\r\n\t\t// \t|\t\t\"#otherid\": function(element){\r\n\t\t//\t|\t\t\t// assumes \"found\" with this syntax\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\t If property is a string, a dojo.publish will be issued on the channel:\r\n\t\t//\r\n\t\t//\t|\tbehavior.add({\r\n\t\t//\t|\t\t// topic.publish() whenever class=\"noclick\" found on anchors\r\n\t\t//\t|\t\t\"a.noclick\": \"/got/newAnchor\",\r\n\t\t//\t|\t\t\"div.wrapper\": {\r\n\t\t//\t|\t\t\t\"onclick\": \"/node/wasClicked\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\t|\ttopic.subscribe(\"/got/newAnchor\", function(node){\r\n\t\t//\t|\t\t// handle node finding when dojo/behavior.apply() is called,\r\n\t\t//\t|\t\t// provided a newly matched node is found.\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tScoping can be accomplished by passing an object as a property to\r\n\t\t//\t\ta connection handle (on*):\r\n\t\t//\r\n\t\t//\t|\tbehavior.add({\r\n\t\t//\t|\t\t \t\"#id\": {\r\n\t\t//\t|\t\t\t\t// like calling dojo.hitch(foo,\"bar\"). execute foo.bar() in scope of foo\r\n\t\t//\t|\t\t\t\t\"onmouseenter\": { targetObj: foo, targetFunc: \"bar\" },\r\n\t\t//\t|\t\t\t\t\"onmouseleave\": { targetObj: foo, targetFunc: \"baz\" }\r\n\t\t//\t|\t\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tBehaviors match on CSS3 Selectors, powered by dojo/query. Example selectors:\r\n\t\t//\r\n\t\t//\t|\tbehavior.add({\r\n\t\t//\t|\t\t// match all direct descendants\r\n\t\t//\t|\t\t\"#id4 > *\": function(element){\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\r\n\t\t//\t|\t\t// match the first child node that's an element\r\n\t\t//\t|\t\t\"#id4 > :first-child\": { ... },\r\n\t\t//\t|\r\n\t\t//\t|\t\t// match the last child node that's an element\r\n\t\t//\t|\t\t\"#id4 > :last-child\":  { ... },\r\n\t\t//\t|\r\n\t\t//\t|\t\t// all elements of type tagname\r\n\t\t//\t|\t\t\"tagname\": {\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\r\n\t\t//\t|\t\t\"tagname1 tagname2 tagname3\": {\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\r\n\t\t//\t|\t\t\".classname\": {\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t},\r\n\t\t//\t|\r\n\t\t//\t|\t\t\"tagname.classname\": {\r\n\t\t//\t|\t\t\t// ...\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t});\r\n\t\t//\r\n\r\n\t\tforIn(behaviorObj, this, function(behavior, name){\r\n\t\t\tvar tBehavior = arrIn(this._behaviors, name);\r\n\t\t\tif(typeof tBehavior[\"id\"] != \"number\"){\r\n\t\t\t\ttBehavior.id = _inc++;\r\n\t\t\t}\r\n\t\t\tvar cversion = [];\r\n\t\t\ttBehavior.push(cversion);\r\n\t\t\tif((lang.isString(behavior))||(lang.isFunction(behavior))){\r\n\t\t\t\tbehavior = { found: behavior };\r\n\t\t\t}\r\n\t\t\tforIn(behavior, function(rule, ruleName){\r\n\t\t\t\tarrIn(cversion, ruleName).push(rule);\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\tvar _applyToNode = function(node, action, ruleSetName){\r\n\t\tif(lang.isString(action)){\r\n\t\t\tif(ruleSetName == \"found\"){\r\n\t\t\t\tconnect.publish(action, [ node ]);\r\n\t\t\t}else{\r\n\t\t\t\tconnect.connect(node, ruleSetName, function(){\r\n\t\t\t\t\tconnect.publish(action, arguments);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}else if(lang.isFunction(action)){\r\n\t\t\tif(ruleSetName == \"found\"){\r\n\t\t\t\taction(node);\r\n\t\t\t}else{\r\n\t\t\t\tconnect.connect(node, ruleSetName, action);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.apply = function(){\r\n\t\t// summary:\r\n\t\t//\t\tApplies all currently registered behaviors to the document.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tApplies all currently registered behaviors to the document,\r\n\t\t//\t\ttaking care to ensure that only incremental updates are made\r\n\t\t//\t\tsince the last time add() or apply() were called.\r\n\t\t//\r\n\t\t//\t\tIf new matching nodes have been added, all rules in a behavior will be\r\n\t\t//\t\tapplied to that node. For previously matched nodes, only\r\n\t\t//\t\tbehaviors which have been added since the last call to apply()\r\n\t\t//\t\twill be added to the nodes.\r\n\t\t//\r\n\t\t//\t\tapply() is called once automatically by `dojo.addOnLoad`, so\r\n\t\t//\t\tregistering behaviors with `dojo/behavior.add()` before the DOM is\r\n\t\t//\t\tready is acceptable, provided the dojo.behavior module is ready.\r\n\t\t//\r\n\t\t//\t\tCalling appy() manually after manipulating the DOM is required\r\n\t\t//\t\tto rescan the DOM and apply newly .add()ed behaviors, or to match\r\n\t\t//\t\tnodes that match existing behaviors when those nodes are added to\r\n\t\t//\t\tthe DOM.\r\n\t\t//\r\n\t\tforIn(this._behaviors, function(tBehavior, id){\r\n\t\t\tquery(id).forEach(\r\n\t\t\t\tfunction(elem){\r\n\t\t\t\t\tvar runFrom = 0;\r\n\t\t\t\t\tvar bid = \"_dj_behavior_\"+tBehavior.id;\r\n\t\t\t\t\tif(typeof elem[bid] == \"number\"){\r\n\t\t\t\t\t\trunFrom = elem[bid];\r\n\t\t\t\t\t\tif(runFrom == (tBehavior.length)){\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// run through the versions, applying newer rules at each step\r\n\r\n\t\t\t\t\tfor(var x=runFrom, tver; tver = tBehavior[x]; x++){\r\n\t\t\t\t\t\tforIn(tver, function(ruleSet, ruleSetName){\r\n\t\t\t\t\t\t\tif(lang.isArray(ruleSet)){\r\n\t\t\t\t\t\t\t\tdarray.forEach(ruleSet, function(action){\r\n\t\t\t\t\t\t\t\t\t_applyToNode(elem, action, ruleSetName);\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// ensure that re-application only adds new rules to the node\r\n\t\t\t\t\telem[bid] = tBehavior.length;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t};\r\n};\r\n\r\ndojo.behavior = new Behavior();\r\n\r\ndomReady( function(){ dojo.behavior.apply(); } );\r\n\r\nreturn dojo.behavior;\r\n});\r\n"]}