{"version":3,"sources":["aspect.js"],"names":["define","undefined","nextId","aspect","type","target","methodName","advice","receiveArguments","dispatcher","existing","executionId","args","arguments","before","apply","this","next","around","results","after","id","newResults","call","signal","previous","advised","remove","advise"],"mappings":";;;;;;;AAAAA,UAAW,WAKV,aACA,IAAIC,EAAWC,EAAS,EAqExB,SAASC,EAAOC,GACf,OAAO,SAASC,EAAQC,EAAYC,EAAQC,GAC3C,IAAmCC,EAA/BC,EAAWL,EAAOC,GAClBI,GAAYA,EAASL,QAAUA,IAElCA,EAAOC,GAAcG,EAAa,WAKjC,IAJA,IAAIE,EAAcT,EAEdU,EAAOC,UACPC,EAASL,EAAWK,OAClBA,GACLF,EAAOE,EAAOP,OAAOQ,MAAMC,KAAMJ,IAASA,EAC1CE,EAASA,EAAOG,KAGjB,GAAGR,EAAWS,OACb,IAAIC,EAAUV,EAAWS,OAAOX,OAAOS,KAAMJ,GAI9C,IADA,IAAIQ,EAAQX,EAAWW,MACjBA,GAASA,EAAMC,GAAKV,GAAY,CACrC,GAAGS,EAAMZ,iBAAiB,CACzB,IAAIc,EAAaF,EAAMb,OAAOQ,MAAMC,KAAMJ,GAE1CO,EAAUG,IAAerB,EAAYkB,EAAUG,OAE/CH,EAAUC,EAAMb,OAAOgB,KAAKP,KAAMG,EAASP,GAE5CQ,EAAQA,EAAMH,KAEf,OAAOE,GAELT,IACFD,EAAWS,QAAUX,OAAQ,SAASF,EAAQO,GAC7C,OAAOF,EAASK,MAAMV,EAAQO,MAGhCH,EAAWJ,OAASA,GAErB,IAAIc,EA3GN,SAAgBV,EAAYL,EAAMG,EAAQC,GACzC,IAEIgB,EAFAC,EAAWhB,EAAWL,GACtBc,EAAiB,UAARd,EAEb,GAAGc,EAAO,CACT,IAAIQ,EAAUnB,EAAO,WACpB,OAAOkB,EAASlB,OAAOS,KAAMH,aAE9BW,GACCG,OAAQ,WACJD,IACFA,EAAUjB,EAAaF,EAAS,OAGlCA,OAAQ,SAASF,EAAQO,GACxB,OAAOc,EACNA,EAAQX,MAAMV,EAAQO,GACtBa,EAASlB,OAAOF,EAAQO,UAK3BY,GACCG,OAAQ,WACP,GAAGH,EAAOjB,OAAO,CAChB,IAAIkB,EAAWD,EAAOC,SAClBR,EAAOO,EAAOP,KACdA,GAASQ,GAGTA,EACFA,EAASR,KAAOA,EAEhBR,EAAWL,GAAQa,EAEjBA,IACFA,EAAKQ,SAAWA,WARVhB,EAAWL,GAanBK,EAAaF,EAASiB,EAAOjB,OAAS,OAGxCc,GAAInB,IACJK,OAAQA,EACRC,iBAAkBA,GAGpB,GAAGiB,IAAaP,EACf,GAAW,SAARd,EAAgB,CAGlB,KAAMqB,EAASR,OAASQ,EAAWA,EAASR,QAC5CQ,EAASR,KAAOO,EAChBA,EAAOC,SAAWA,MACF,UAARrB,IAERK,EAAWL,GAAQoB,EACnBA,EAAOP,KAAOQ,EACdA,EAASA,SAAWD,QAIrBf,EAAWL,GAAQoB,EAEpB,OAAOA,EAyCQI,CAAQnB,GAAcC,EAAWN,EAAMG,EAAQC,GAE7D,OADAD,EAAS,KACFY,GAMT,IAAIC,EAAQjB,EAAO,SA+EnB,OAiBCW,OAtEYX,EAAO,UAuEnBe,OAlDYf,EAAO,UAmDnBiB,MAAOA","file":"../aspect.js","sourcesContent":["define([], function(){\r\n\r\n\t// module:\r\n\t//\t\tdojo/aspect\r\n\r\n\t\"use strict\";\r\n\tvar undefined, nextId = 0;\r\n\tfunction advise(dispatcher, type, advice, receiveArguments){\r\n\t\tvar previous = dispatcher[type];\r\n\t\tvar around = type == \"around\";\r\n\t\tvar signal;\r\n\t\tif(around){\r\n\t\t\tvar advised = advice(function(){\r\n\t\t\t\treturn previous.advice(this, arguments);\r\n\t\t\t});\r\n\t\t\tsignal = {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tif(advised){\r\n\t\t\t\t\t\tadvised = dispatcher = advice = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tadvice: function(target, args){\r\n\t\t\t\t\treturn advised ?\r\n\t\t\t\t\t\tadvised.apply(target, args) :  // called the advised function\r\n\t\t\t\t\t\tprevious.advice(target, args); // cancelled, skip to next one\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}else{\r\n\t\t\t// create the remove handler\r\n\t\t\tsignal = {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tif(signal.advice){\r\n\t\t\t\t\t\tvar previous = signal.previous;\r\n\t\t\t\t\t\tvar next = signal.next;\r\n\t\t\t\t\t\tif(!next && !previous){\r\n\t\t\t\t\t\t\tdelete dispatcher[type];\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(previous){\r\n\t\t\t\t\t\t\t\tprevious.next = next;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tdispatcher[type] = next;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(next){\r\n\t\t\t\t\t\t\t\tnext.previous = previous;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// remove the advice to signal that this signal has been removed\r\n\t\t\t\t\t\tdispatcher = advice = signal.advice = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tid: nextId++,\r\n\t\t\t\tadvice: advice,\r\n\t\t\t\treceiveArguments: receiveArguments\r\n\t\t\t};\r\n\t\t}\r\n\t\tif(previous && !around){\r\n\t\t\tif(type == \"after\"){\r\n\t\t\t\t// add the listener to the end of the list\r\n\t\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\r\n\t\t\t\twhile(previous.next && (previous = previous.next)){}\r\n\t\t\t\tprevious.next = signal;\r\n\t\t\t\tsignal.previous = previous;\r\n\t\t\t}else if(type == \"before\"){\r\n\t\t\t\t// add to beginning\r\n\t\t\t\tdispatcher[type] = signal;\r\n\t\t\t\tsignal.next = previous;\r\n\t\t\t\tprevious.previous = signal;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// around or first one just replaces\r\n\t\t\tdispatcher[type] = signal;\r\n\t\t}\r\n\t\treturn signal;\r\n\t}\r\n\tfunction aspect(type){\r\n\t\treturn function(target, methodName, advice, receiveArguments){\r\n\t\t\tvar existing = target[methodName], dispatcher;\r\n\t\t\tif(!existing || existing.target != target){\r\n\t\t\t\t// no dispatcher in place\r\n\t\t\t\ttarget[methodName] = dispatcher = function(){\r\n\t\t\t\t\tvar executionId = nextId;\r\n\t\t\t\t\t// before advice\r\n\t\t\t\t\tvar args = arguments;\r\n\t\t\t\t\tvar before = dispatcher.before;\r\n\t\t\t\t\twhile(before){\r\n\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\r\n\t\t\t\t\t\tbefore = before.next;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// around advice\r\n\t\t\t\t\tif(dispatcher.around){\r\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// after advice\r\n\t\t\t\t\tvar after = dispatcher.after;\r\n\t\t\t\t\twhile(after && after.id < executionId){\r\n\t\t\t\t\t\tif(after.receiveArguments){\r\n\t\t\t\t\t\t\tvar newResults = after.advice.apply(this, args);\r\n\t\t\t\t\t\t\t// change the return value only if a new value was returned\r\n\t\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresults = after.advice.call(this, results, args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tafter = after.next;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t};\r\n\t\t\t\tif(existing){\r\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\r\n\t\t\t\t\t\treturn existing.apply(target, args);\r\n\t\t\t\t\t}};\r\n\t\t\t\t}\r\n\t\t\t\tdispatcher.target = target;\r\n\t\t\t}\r\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\r\n\t\t\tadvice = null;\r\n\t\t\treturn results;\r\n\t\t};\r\n\t}\r\n\r\n\t// TODOC: after/before/around return object\r\n\r\n\tvar after = aspect(\"after\");\r\n\t/*=====\r\n\tafter = function(target, methodName, advice, receiveArguments){\r\n\t\t// summary:\r\n\t\t//\t\tThe \"after\" export of the aspect module is a function that can be used to attach\r\n\t\t//\t\t\"after\" advice to a method. This function will be executed after the original method\r\n\t\t//\t\tis executed. By default the function will be called with a single argument, the return\r\n\t\t//\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\r\n\t\t//\t\tThe fourth (optional) argument can be set to true to so the function receives the original\r\n\t\t//\t\targuments (from when the original method was called) rather than the return value.\r\n\t\t//\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\r\n\t\t// target: Object\r\n\t\t//\t\tThis is the target object\r\n\t\t// methodName: String\r\n\t\t//\t\tThis is the name of the method to attach to.\r\n\t\t// advice: Function\r\n\t\t//\t\tThis is function to be called after the original method\r\n\t\t// receiveArguments: Boolean?\r\n\t\t//\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\r\n\t\t//\t\twas called) rather than the return value of the original/previous method.\r\n\t\t// returns:\r\n\t\t//\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\r\n\t\t//\t\tstop the advice function from being executed.\r\n\t};\r\n\t=====*/\r\n\r\n\tvar before = aspect(\"before\");\r\n\t/*=====\r\n\tbefore = function(target, methodName, advice){\r\n\t\t// summary:\r\n\t\t//\t\tThe \"before\" export of the aspect module is a function that can be used to attach\r\n\t\t//\t\t\"before\" advice to a method. This function will be executed before the original method\r\n\t\t//\t\tis executed. This function will be called with the arguments used to call the method.\r\n\t\t//\t\tThis function may optionally return an array as the new arguments to use to call\r\n\t\t//\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\r\n\t\t//\t\tIf the before method doesn't return anything (returns undefined) the original arguments\r\n\t\t//\t\twill be preserved.\r\n\t\t//\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\r\n\t\t// target: Object\r\n\t\t//\t\tThis is the target object\r\n\t\t// methodName: String\r\n\t\t//\t\tThis is the name of the method to attach to.\r\n\t\t// advice: Function\r\n\t\t//\t\tThis is function to be called before the original method\r\n\t};\r\n\t=====*/\r\n\r\n\tvar around = aspect(\"around\");\r\n\t/*=====\r\n\t around = function(target, methodName, advice){\r\n\t\t// summary:\r\n\t\t//\t\tThe \"around\" export of the aspect module is a function that can be used to attach\r\n\t\t//\t\t\"around\" advice to a method. The advisor function is immediately executed when\r\n\t\t//\t\tthe around() is called, is passed a single argument that is a function that can be\r\n\t\t//\t\tcalled to continue execution of the original method (or the next around advisor).\r\n\t\t//\t\tThe advisor function should return a function, and this function will be called whenever\r\n\t\t//\t\tthe method is called. It will be called with the arguments used to call the method.\r\n\t\t//\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\r\n\t\t// example:\r\n\t\t//\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\r\n\t\t//\t\twhich can then delegate to the next one and so on. For example:\r\n\t\t//\t\t|\taround(obj, \"foo\", function(originalFoo){\r\n\t\t//\t\t|\t\treturn function(){\r\n\t\t//\t\t|\t\t\tvar start = new Date().getTime();\r\n\t\t//\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); // call the original\r\n\t\t//\t\t|\t\t\tvar end = new Date().getTime();\r\n\t\t//\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\r\n\t\t//\t\t|\t\t\treturn results;\r\n\t\t//\t\t|\t\t};\r\n\t\t//\t\t|\t});\r\n\t\t// target: Object\r\n\t\t//\t\tThis is the target object\r\n\t\t// methodName: String\r\n\t\t//\t\tThis is the name of the method to attach to.\r\n\t\t// advice: Function\r\n\t\t//\t\tThis is function to be called around the original method\r\n\t};\r\n\t=====*/\r\n\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tprovides aspect oriented programming functionality, allowing for\r\n\t\t//\t\tone to add before, around, or after advice on existing methods.\r\n\t\t// example:\r\n\t\t//\t|\tdefine([\"dojo/aspect\"], function(aspect){\r\n\t\t//\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\r\n\t\t//\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\r\n\t\t//\t|\t\t});\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\tThe returned signal object can be used to cancel the advice.\r\n\t\t//\t|\tsignal.remove(); // this will stop the advice from being executed anymore\r\n\t\t//\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\r\n\t\t//\t|\t\t// this will be called when targetObject.methodName() is called, before the original function is called\r\n\t\t//\t|\t });\r\n\r\n\t\tbefore: before,\r\n\t\taround: around,\r\n\t\tafter: after\r\n\t};\r\n});\r\n"]}